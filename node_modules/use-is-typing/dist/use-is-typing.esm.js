import { useState, useRef, useCallback, useEffect } from 'react';

function useIsTyping(_temp) {
  var _ref = _temp === void 0 ? {} : _temp,
      _ref$timeout = _ref.timeout,
      timeout = _ref$timeout === void 0 ? 1000 : _ref$timeout;

  var _useState = useState(false),
      isTyping = _useState[0],
      setIsTyping = _useState[1];

  var _useState2 = useState(null),
      currentEl = _useState2[0],
      setCurrentEl = _useState2[1];

  var timeoutRef = useRef(null);
  var reset = useCallback(function () {
    // Debounce `reset()` based on `timeout`
    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current);
    }

    timeoutRef.current = setTimeout(function () {
      setIsTyping(false);
    }, timeout);
  }, [timeout]);
  var register = useCallback(function (el) {
    setCurrentEl(el);

    if (!el) {
      setIsTyping(false);
    }
  }, []);
  useEffect(function () {
    // Clear timeout on unmount
    return function () {
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current);
      }
    };
  }, []);
  useEffect(function () {
    setIsTyping(false);

    if (!currentEl) {
      return;
    }

    var keyUpDownListener = function keyUpDownListener(e) {
      var hasValue = e.target.value !== '';
      setIsTyping(hasValue);
      reset();
    };

    var blurListener = function blurListener() {
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current);
      }

      setIsTyping(false);
    };

    currentEl.addEventListener('keyup', keyUpDownListener);
    currentEl.addEventListener('keydown', keyUpDownListener);
    currentEl.addEventListener('blur', blurListener);
    return function () {
      currentEl.removeEventListener('keydown', keyUpDownListener);
      currentEl.removeEventListener('keyup', keyUpDownListener);
      currentEl.removeEventListener('blur', blurListener);
    };
  }, [currentEl, reset]);
  return [isTyping, register];
}

export default useIsTyping;
export { useIsTyping };
//# sourceMappingURL=use-is-typing.esm.js.map
