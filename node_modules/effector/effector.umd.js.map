{"version":3,"file":"effector.umd.js","sources":["../../src/effector/is.ts","../../src/effector/region.ts","../../src/effector/createNode.ts","../../src/effector/kernel.ts","../../src/effector/naming.ts","../../src/effector/collection.ts","../../src/effector/createUnit.ts","../../src/effector/combine.ts","../../src/effector/defer.ts","../../src/effector/createEffect.ts","../../src/effector/merge.ts","../../src/effector/sample.ts","../../src/effector/fork.ts","../../src/effector/observable.ts","../../src/effector/tag.ts","../../src/effector/validate.ts","../../src/effector/throw.ts","../../src/effector/id.ts","../../src/effector/bind.ts","../../src/effector/step.ts","../../src/effector/stateRef.ts","../../src/effector/caller.ts","../../src/effector/getter.ts","../../src/effector/own.ts","../../src/effector/config.ts","../../src/effector/clearNode.ts","../../src/effector/subscription.ts","../../src/effector/forward.ts","../../src/effector/watch.ts","../../src/effector/createDomain.ts","../../src/effector/split.ts","../../src/effector/attach.ts","../../src/effector/createApi.ts","../../src/effector/fromObservable.ts","../../src/effector/guard.ts","../../src/effector/restore.ts"],"sourcesContent":["//eslint-disable-next-line\nexport * as is from './validate'\nimport {throwError} from './throw'\n\nexport const isObject = (value: any) =>\n  typeof value === 'object' && value !== null\nexport const isFunction = (value: any) => typeof value === 'function'\n\nexport const assertObject = (value: any) => {\n  if (!isObject(value) && !isFunction(value))\n    throwError('expect first argument be an object') // or function\n}\n\nfunction assertNodeSetItem(value: any, method: string, valueName: string, reason: string) {\n  if ((!isObject(value) && !isFunction(value)) || (!('family' in value) && !('graphite' in value))) {\n    throwError(`${method}: expect ${valueName} to be a unit (store, event or effect)${reason}`)\n  }\n}\nexport function assertNodeSet(value: any, method: string, valueName: string) {\n  if (Array.isArray(value)) {\n    for (let i = 0; i < value.length; i++) {\n      const item = value[i]\n      assertNodeSetItem(item, method, `${i} item of ${valueName}`, '')\n    }\n  } else {\n    assertNodeSetItem(value, method, valueName, ' or array of units')\n  }\n}\n","import {getValue, getGraph, getParent} from './getter'\nimport {own} from './own'\nimport {createNode} from './createNode'\n\ntype RegionStack = {\n  parent: RegionStack | null\n  value: any\n  template: any\n  sidRoot?: string\n}\n\nexport let regionStack: RegionStack | null = null\n\nexport const readTemplate = () => regionStack && regionStack.template\nexport const readSidRoot = (sid?: string | null) => {\n  if (sid && regionStack && regionStack.sidRoot)\n    sid = `${regionStack.sidRoot}ɔ${sid}`\n  return sid\n}\n\nexport function withRegion(unit: any, cb: () => void) {\n  const unitMeta = getGraph(unit).meta\n  regionStack = {\n    parent: regionStack,\n    value: unit,\n    template: unitMeta.template || readTemplate(),\n    sidRoot: unitMeta.sidRoot || (regionStack && regionStack.sidRoot),\n  }\n  try {\n    return cb()\n  } finally {\n    regionStack = getParent(regionStack)\n  }\n}\n\nexport const withFactory = ({\n  sid,\n  name,\n  loc,\n  method,\n  fn,\n}: {\n  sid: string\n  name?: string\n  loc?: any\n  method?: string\n  fn: () => any\n}) => {\n  const sidNode = createNode({\n    meta: {\n      sidRoot: readSidRoot(sid),\n      name,\n      loc,\n      method,\n    },\n  })\n  return withRegion(sidNode, fn)\n}\n","import {Node, NodeUnit, Cmd, StateRef} from './index.h'\nimport {getGraph, getOwners, getLinks, getValue} from './getter'\nimport {nextNodeID} from './id'\nimport {CROSSLINK, STORE} from './tag'\nimport {regionStack} from './region'\nimport {own} from './own'\n\nconst arrifyNodes = (\n  list: NodeUnit | Array<NodeUnit | NodeUnit[]> = [],\n): Node[] => {\n  const result = []\n  if (Array.isArray(list)) {\n    for (let i = 0; i < list.length; i++) {\n      if (Array.isArray(list[i])) result.push(...(list[i] as any))\n      else result.push(list[i])\n    }\n  } else {\n    result.push(list)\n  }\n  return result.map(getGraph)\n}\nexport const addToReg = (\n  {hasRef, type, data}: any,\n  reg: Record<string, StateRef>,\n) => {\n  let store\n  if (hasRef) {\n    store = data.store\n    reg[store.id] = store\n  }\n  if (type === 'mov' && data.to === STORE) {\n    store = data.target\n    reg[store.id] = store\n  }\n}\nexport function createNode({\n  node = [],\n  from,\n  source,\n  parent = from || source,\n  to,\n  target,\n  child = to || target,\n  scope = {},\n  meta = {},\n  family: familyRaw = {type: 'regular'},\n  regional,\n}: {\n  node?: Array<Cmd | false | void | null>\n  from?: NodeUnit | NodeUnit[]\n  source?: NodeUnit | NodeUnit[]\n  parent?: NodeUnit | NodeUnit[]\n  to?: NodeUnit | NodeUnit[]\n  target?: NodeUnit | NodeUnit[]\n  child?: NodeUnit | NodeUnit[]\n  scope?: {[name: string]: any}\n  meta?: {[name: string]: any}\n  family?: {\n    type?: 'regular' | 'crosslink' | 'domain'\n    links?: NodeUnit | NodeUnit[]\n    owners?: NodeUnit | Array<NodeUnit | NodeUnit[]>\n  }\n  regional?: boolean\n} = {}): Node {\n  const sources = arrifyNodes(parent)\n  const links = arrifyNodes(familyRaw.links)\n  const owners = arrifyNodes(familyRaw.owners)\n  const seq: Cmd[] = []\n  const reg: {[id: string]: StateRef} = {}\n  for (let i = 0; i < node.length; i++) {\n    const item = node[i]\n    if (!item) continue\n    seq.push(item)\n    addToReg(item, reg)\n  }\n  const result: Node = {\n    id: nextNodeID(),\n    seq,\n    next: arrifyNodes(child),\n    meta,\n    scope,\n    family: {\n      type: familyRaw.type || CROSSLINK,\n      links,\n      owners,\n    },\n    reg,\n  }\n  for (let i = 0; i < links.length; i++) {\n    getOwners(links[i]).push(result)\n  }\n  for (let i = 0; i < owners.length; i++) {\n    getLinks(owners[i]).push(result)\n  }\n  for (let i = 0; i < sources.length; i++) {\n    sources[i].next.push(result)\n  }\n  if (regional && regionStack) {\n    own(getValue(regionStack), [result])\n  }\n  return result\n}\n","import {Node, NodeUnit} from './index.h'\nimport {readRef} from './stateRef'\nimport {getForkPage, getGraph, getParent, getValue} from './getter'\nimport {\n  STORE,\n  EFFECT,\n  SAMPLER,\n  STACK,\n  BARRIER,\n  VALUE,\n  FILTER,\n  REG_A,\n} from './tag'\n\n/** Names of priority groups */\ntype PriorityTag = 'child' | 'pure' | 'barrier' | 'sampler' | 'effect'\n\n/**\n * Position in the current branch,\n * including call stack, priority type\n * and index of next step in the executed Node\n */\ntype Layer = {\n  idx: number\n  stack: Stack\n  type: PriorityTag\n  id: number\n}\n\n/** Call stack */\ntype Stack = {\n  value: any\n  a: any\n  b: any\n  parent: Stack | null\n  node: Node\n  page: {[id: string]: any} | null\n  forkPage?: any\n}\n\n/** Queue as linked list or skew heap */\ntype QueueItem = {\n  /** node value */\n  v: Layer\n  /** left node. always null in queue but used in skew heap */\n  l: QueueItem | null\n  /** right node */\n  r: QueueItem | null\n}\ntype QueueBucket = {\n  first: QueueItem | null\n  last: QueueItem | null\n  size: number\n}\n\n/** Dedicated local metadata */\ntype Local = {\n  fail: boolean\n  scope: {[key: string]: any}\n}\n\nlet heap: QueueItem | null = null\n\nconst merge = (a: QueueItem | null, b: QueueItem | null): QueueItem | null => {\n  if (!a) return b\n  if (!b) return a\n\n  let ret\n  const isSameType = a.v.type === b.v.type\n  if (\n    /**\n     * if both nodes has the same PriorityType\n     * and first node is created after second one\n     */\n    (isSameType && a.v.id > b.v.id) ||\n    /** if first node is \"sampler\" and second node is \"barrier\" */\n    (!isSameType && a.v.type === SAMPLER)\n  ) {\n    ret = a\n    a = b\n    b = ret\n  }\n  ret = merge(a.r, b)\n  a.r = a.l\n  a.l = ret\n\n  return a\n}\n\n/** queue buckets for each PriorityType */\nconst queue: QueueBucket[] = []\nlet ix = 0\nwhile (ix < 5) {\n  /**\n   * although \"sampler\" and \"barrier\" are using heap instead of linked list,\n   * their buckets are still useful: they maintains size of heap queue\n   */\n  queue.push({first: null, last: null, size: 0})\n  ix += 1\n}\n\nconst deleteMin = () => {\n  for (let i = 0; i < 5; i++) {\n    const list = queue[i]\n    if (list.size > 0) {\n      /**\n       * second bucket is for \"barrier\" PriorityType (used in combine)\n       * and third bucket is for \"sampler\" PriorityType (used in sample and guard)\n       */\n      if (i === 2 || i === 3) {\n        list.size -= 1\n        const value = heap!.v\n        heap = merge(heap!.l, heap!.r)\n        return value\n      }\n      if (list.size === 1) {\n        list.last = null\n      }\n      const item = list.first\n      list.first = item!.r\n      list.size -= 1\n      return item!.v\n    }\n  }\n}\nconst pushFirstHeapItem = (\n  type: PriorityTag,\n  page: {[id: string]: any} | null,\n  node: Node,\n  parent: Stack | null,\n  value: any,\n  forkPage: any | void,\n) =>\n  pushHeap(\n    0,\n    {\n      a: null,\n      b: null,\n      node,\n      parent,\n      value,\n      page,\n      forkPage,\n    },\n    type,\n  )\nconst pushHeap = (idx: number, stack: Stack, type: PriorityTag, id = 0) => {\n  const priority = getPriority(type)\n  const bucket: QueueBucket = queue[priority]\n  const item: QueueItem = {\n    v: {\n      idx,\n      stack,\n      type,\n      id,\n    },\n    //@ts-ignore\n    l: 0,\n    //@ts-ignore\n    r: 0,\n  }\n  /**\n   * second bucket is for \"barrier\" PriorityType (used in combine)\n   * and third bucket is for \"sampler\" PriorityType (used in sample and guard)\n   */\n  if (priority === 2 || priority === 3) {\n    heap = merge(heap, item)\n  } else {\n    if (bucket.size === 0) {\n      bucket.first = item\n    } else {\n      bucket.last!.r = item\n    }\n    bucket.last = item\n  }\n  bucket.size += 1\n}\n\nconst getPriority = (t: PriorityTag) => {\n  switch (t) {\n    case 'child':\n      return 0\n    case 'pure':\n      return 1\n    case BARRIER:\n      return 2\n    case SAMPLER:\n      return 3\n    case EFFECT:\n      return 4\n    default:\n      return -1\n  }\n}\n\nconst barriers = new Set()\n\nlet isRoot = true\nexport let isWatch = false\nexport let currentPage: any = null\nexport let forkPage: any\nexport const setForkPage = (newForkPage: any) => {\n  forkPage = newForkPage\n}\nexport const setCurrentPage = (newPage: any) => {\n  currentPage = newPage\n}\n\nconst getPageForRef = (page: any, id: string) => {\n  if (page) {\n    while (page && !page.reg[id]) {\n      page = getParent(page)\n    }\n    if (page) return page\n  }\n  return null\n}\nconst getPageRef = (page: any, node: Node, id: string) => {\n  const pageForRef = getPageForRef(page, id)\n  return (pageForRef ? pageForRef : node).reg[id]\n}\n\nexport function launch(config: {\n  target: NodeUnit | NodeUnit[]\n  params?: any\n  defer?: boolean\n  page?: any\n  forkPage?: any\n  stack?: Stack\n}): void\nexport function launch(unit: NodeUnit, payload?: any, upsert?: boolean): void\nexport function launch(unit: any, payload?: any, upsert?: boolean) {\n  let pageForLaunch = currentPage\n  let stackForLaunch = null\n  let forkPageForLaunch = forkPage\n  if (unit.target) {\n    payload = unit.params\n    upsert = unit.defer\n    pageForLaunch = 'page' in unit ? unit.page : pageForLaunch\n    if (unit[STACK]) stackForLaunch = unit[STACK]\n    forkPageForLaunch = getForkPage(unit) || forkPageForLaunch\n    unit = unit.target\n  }\n  if (forkPageForLaunch && forkPage && forkPageForLaunch !== forkPage) {\n    forkPage = null\n  }\n  if (Array.isArray(unit)) {\n    for (let i = 0; i < unit.length; i++) {\n      pushFirstHeapItem(\n        'pure',\n        pageForLaunch,\n        getGraph(unit[i]),\n        stackForLaunch,\n        payload[i],\n        forkPageForLaunch,\n      )\n    }\n  } else {\n    pushFirstHeapItem(\n      'pure',\n      pageForLaunch,\n      getGraph(unit),\n      stackForLaunch,\n      payload,\n      forkPageForLaunch,\n    )\n  }\n  if (upsert && !isRoot) return\n  /** main execution code */\n  const lastStartedState = {isRoot, currentPage, forkPage, isWatch}\n  isRoot = false\n  let stop\n  let skip\n  let node\n  let value\n  let page\n  let reg\n  kernelLoop: while ((value = deleteMin())) {\n    const {idx, stack, type} = value\n    node = stack.node\n    currentPage = page = stack.page\n    forkPage = getForkPage(stack)\n    reg = (page ? page : node).reg\n    const local: Local = {\n      fail: false,\n      scope: node.scope,\n    }\n    stop = skip = false\n    for (let stepn = idx; stepn < node.seq.length && !stop; stepn++) {\n      const step = node.seq[stepn]\n      const data = step.data\n      switch (step.type) {\n        case BARRIER: {\n          let id = data.barrierID\n          if (page) {\n            id = `${page.fullID}_${id}`\n          }\n          const priority = data.priority\n          if (stepn !== idx || type !== priority) {\n            if (!barriers.has(id)) {\n              barriers.add(id)\n              pushHeap(stepn, stack, priority, id)\n            }\n            continue kernelLoop\n          }\n          barriers.delete(id)\n          break\n        }\n        case 'mov': {\n          let value\n          //prettier-ignore\n          switch (data.from) {\n            case STACK: value = getValue(stack); break\n            case REG_A: /** fall-through case */\n            case 'b':\n              value = stack[data.from]\n              break\n            case VALUE: value = data.store; break\n            case STORE:\n              if (!reg[data.store.id]) {\n                // if (!page.parent) {\n                stack.page = page = getPageForRef(page, data.store.id)\n                reg = page ? page.reg : node.reg\n                // }\n              }\n              // value = getPageRef(page, node, data.store.id).current\n              value = readRef(reg[data.store.id])\n              break\n          }\n          //prettier-ignore\n          switch (data.to) {\n            case STACK: stack.value = value; break\n            case REG_A: /** fall-through case */\n            case 'b':\n              stack[data.to] = value\n              break\n            case STORE:\n              getPageRef(page, node, data.target.id).current = value\n              break\n          }\n          break\n        }\n        case 'check':\n          switch (data.type) {\n            case 'defined':\n              skip = getValue(stack) === undefined\n              break\n            case 'changed':\n              skip =\n                getValue(stack) ===\n                readRef(getPageRef(page, node, data.store.id))\n              break\n          }\n          break\n        case FILTER:\n          /**\n           * handled edge case: if step.fn will throw,\n           * tryRun will return null\n           * thereby forcing that branch to stop\n           */\n          skip = !tryRun(local, data, stack)\n          break\n        case 'run':\n          /** exec 'compute' step when stepn === idx */\n          if (stepn !== idx || type !== EFFECT) {\n            pushHeap(stepn, stack, EFFECT)\n            continue kernelLoop\n          }\n        case 'compute':\n          isWatch = node.meta.op === 'watch'\n          stack.value = tryRun(local, data, stack)\n          isWatch = lastStartedState.isWatch\n          break\n      }\n      stop = local.fail || skip\n    }\n    if (!stop) {\n      for (let stepn = 0; stepn < node.next.length; stepn++) {\n        pushFirstHeapItem(\n          'child',\n          page,\n          node.next[stepn],\n          stack,\n          getValue(stack),\n          getForkPage(stack),\n        )\n      }\n    }\n  }\n  isRoot = lastStartedState.isRoot\n  currentPage = lastStartedState.currentPage\n  forkPage = getForkPage(lastStartedState)\n}\n\n/** try catch for external functions */\nconst tryRun = (local: Local, {fn}: any, stack: Stack) => {\n  try {\n    return fn(getValue(stack), local.scope, stack)\n  } catch (err) {\n    console.error(err)\n    local.fail = true\n  }\n}\n","import {Store, Domain} from './unit.h'\nimport {is} from './is'\nimport {getParent} from './getter'\n\nexport const joinName = (unit: any, tag: string) => '' + unit.shortName + tag\n\nexport const mapName = (unit: any, name?: string) =>\n  name == null ? joinName(unit, ' → *') : name\n\nexport function unitObjectName(objOrArr: any, method: string = 'combine') {\n  let name = method + '('\n  let comma = ''\n  let i = 0\n  //@ts-ignore\n  for (const key in objOrArr) {\n    //@ts-ignore\n    const unit = objOrArr[key]\n    if (unit != null) {\n      name += comma\n      //@ts-ignore\n      name += is.unit(unit) ? unit.compositeName.fullName : unit.toString()\n    }\n    i += 1\n    /* inlined max object names constant */\n    if (i === 25) break\n    comma = ', '\n  }\n  name += ')'\n  return name\n}\n\nexport function setStoreName<State>(store: Store<State>, rawName: string) {\n  const compositeName = createName(rawName, getParent(store))\n  store.shortName = rawName\n  if (!store.compositeName) {\n    store.compositeName = compositeName\n    return\n  }\n  const currentComposite = store.compositeName\n  currentComposite.path = compositeName.path\n  currentComposite.shortName = compositeName.shortName\n  currentComposite.fullName = compositeName.fullName\n}\n\nexport type CompositeName = {\n  shortName: string\n  fullName: string\n  path: string[]\n}\n\nexport function createName(name: string, parent?: Domain): CompositeName {\n  let path: string[]\n  let fullName\n  let composite\n  const shortName = name\n  if (!parent) {\n    if (name.length === 0) {\n      path = []\n    } else {\n      path = [name]\n    }\n    fullName = name\n  } else {\n    composite = parent.compositeName\n    if (name.length === 0) {\n      path = composite.path\n      fullName = composite.fullName\n    } else {\n      path = composite.path.concat([name])\n      if (composite.fullName.length === 0) {\n        fullName = name\n      } else {\n        fullName = '' + composite.fullName + '/' + name\n      }\n    }\n  }\n  return {shortName, fullName, path}\n}\n","export function forIn<T>(\n  obj: Record<string, T>,\n  cb: (value: T, key: string) => void,\n) {\n  for (const key in obj) {\n    cb(obj[key], key)\n  }\n}\n\nexport const includes = (list: any[], item: any) => list.includes(item)\n\nexport const removeItem = (list: any[], item: any) => {\n  const pos = list.indexOf(item)\n  if (pos !== -1) {\n    list.splice(pos, 1)\n  }\n}\n\nexport function forEach<T>(\n  list: T[],\n  fn: (item: T, index: number, list: T[]) => void,\n): void\nexport function forEach<T>(list: Set<T>, fn: (item: T) => void): void\nexport function forEach(list: any, fn: Function) {\n  list.forEach(fn)\n}\n","import {observableSymbol} from './observable'\n\nimport {is, isObject, isFunction, assertObject, assertNodeSet} from './is'\nimport {Store, Event} from './unit.h'\n\nimport {step} from './typedef'\nimport {createStateRef, readRef} from './stateRef'\nimport {nextUnitID} from './id'\nimport {callStackAReg, callARegStack, callStack} from './caller'\nimport {bind} from './bind'\nimport {own} from './own'\nimport {createNode} from './createNode'\nimport {launch, currentPage, forkPage, setCurrentPage} from './kernel'\n\nimport {Subscriber, Config} from './index.h'\nimport {createName, mapName, joinName} from './naming'\nimport {createLinkNode} from './forward'\nimport {watchUnit} from './watch'\nimport {createSubscription} from './subscription'\nimport {readTemplate, readSidRoot} from './region'\nimport {\n  getSubscribers,\n  getConfig,\n  getNestedConfig,\n  getStoreState,\n  getGraph,\n  getParent,\n} from './getter'\nimport {includes} from './collection'\nimport {throwError} from './throw'\nimport {DOMAIN, STORE, EVENT, MAP, FILTER, REG_A} from './tag'\n\nconst normalizeConfig = (part: any, config: any) => {\n  if (isObject(part)) {\n    normalizeConfig(getConfig(part), config)\n    if (part.name != null) {\n      if (isObject(part.name)) normalizeConfig(part.name, config)\n      else if (isFunction(part.name)) config.handler = part.name\n      else config.name = part.name\n    }\n    if (part.loc) config.loc = part.loc\n    if (part.sid || part.sid === null) config.sid = part.sid\n    if (part.handler) config.handler = part.handler\n    if (part.updateFilter) config.updateFilter = part.updateFilter\n    if (getParent(part)) config.parent = getParent(part)\n    if ('strict' in part) config.strict = part.strict\n    if (part.named) config.named = part.named\n    normalizeConfig(getNestedConfig(part), config)\n  }\n  return config\n}\n\nexport const applyParentHook = (\n  source: any,\n  target: any,\n  hookType: 'event' | 'effect' = EVENT,\n) => {\n  if (getParent(source)) getParent(source).hooks[hookType](target)\n}\n\nlet isStrict: boolean\nexport const initUnit = (\n  kind: any,\n  unit: any,\n  rawConfigA: any,\n  rawConfigB?: any,\n) => {\n  const config = normalizeConfig(\n    {\n      name: rawConfigB,\n      config: rawConfigA,\n    },\n    {},\n  )\n  const isDomain = kind === DOMAIN\n  const id = nextUnitID()\n  let {parent = null, sid = null, strict = true, named = null} = config\n  const name = named ? named : config.name || (isDomain ? '' : id)\n  const compositeName = createName(name, parent)\n\n  const meta: Record<string, any> = {\n    unit: unit.kind = kind,\n    name: unit.shortName = name,\n    sid: unit.sid = readSidRoot(sid),\n    named,\n    unitId: unit.id = id,\n  }\n  unit.parent = parent\n  unit.compositeName = compositeName\n  unit.defaultConfig = config\n  unit.thru = (fn: Function) => fn(unit)\n  unit.getType = () => compositeName.fullName\n  if (!isDomain) {\n    unit.subscribe = (observer: Subscriber<any>) => {\n      assertObject(observer)\n      return unit.watch(\n        isFunction(observer)\n          ? observer\n          : (upd: any) => {\n              if (observer.next) {\n                observer.next(upd)\n              }\n            },\n      )\n    }\n    unit[observableSymbol] = () => unit\n    const template = readTemplate()\n    if (template) meta.nativeTemplate = template\n  }\n  isStrict = strict\n  return meta\n}\nexport const createNamedEvent = (named: string) => createEvent({named})\n\nconst createComputation = (from: any, to: any, op: any, fn: Function) =>\n  createLinkNode(from, to, {\n    scope: {fn},\n    node: [step.compute({fn: callStack})],\n    meta: {op},\n  })\n\nconst createEventFiltration = (event: any, op: string, fn: any, node: any) => {\n  let config\n  if (isObject(fn)) {\n    config = fn\n    fn = fn.fn\n  }\n  const mapped = createEvent(joinName(event, ' →? *'), config)\n  createLinkNode(event, mapped, {\n    scope: {fn},\n    node,\n    meta: {op},\n  })\n  return mapped\n}\n\nfunction callCreate(unit: any, template: any, payload: any, args: any[]): any {\n  const oldPage = currentPage\n  let page = null\n  if (template) {\n    page = currentPage\n    while (page && page.template !== template) {\n      page = getParent(page)\n    }\n  }\n  setCurrentPage(page)\n  const result = unit.create(payload, args)\n  setCurrentPage(oldPage)\n  return result\n}\n\nexport function createEvent<Payload = any>(\n  nameOrConfig?: any,\n  maybeConfig?: any,\n): Event<Payload> {\n  const event: any = (payload: Payload, ...args: any[]) => {\n    if (currentPage) {\n      return callCreate(event, template, payload, args)\n    }\n    return event.create(payload, args)\n  }\n  event.graphite = createNode({\n    meta: initUnit(EVENT, event, maybeConfig, nameOrConfig),\n    regional: true,\n  })\n  //eslint-disable-next-line no-unused-vars\n  event.create = (params: any, _: any) => {\n    const target = forkPage ? forkPage.find(event) : event\n    launch(target, params)\n    return params\n  }\n  event.watch = bind(watchUnit, event)\n  event.map = (fn: any) => {\n    let config\n    let name\n    if (isObject(fn)) {\n      config = fn\n      name = fn.name\n      fn = fn.fn\n    }\n    const mapped = createEvent(mapName(event, name), config)\n    createComputation(event, mapped, MAP, fn)\n    return mapped\n  }\n  event.filter = (fn: any) =>\n    createEventFiltration(event, FILTER, fn.fn ? fn : fn.fn, [\n      step.filter({fn: callStack}),\n    ])\n  event.filterMap = (fn: any) =>\n    createEventFiltration(event, 'filterMap', fn, [\n      step.compute({fn: callStack}),\n      step.check.defined(),\n    ])\n  event.prepend = (fn: any) => {\n    const contramapped: Event<any> = createEvent('* → ' + event.shortName, {\n      parent: getParent(event),\n    })\n    const template = readTemplate()\n    if (template) {\n      getGraph(contramapped).seq.push(template.upward)\n    }\n    createComputation(contramapped, event, 'prepend', fn)\n    applyParentHook(event, contramapped)\n    return contramapped\n  }\n  const template = readTemplate()\n  return event\n}\n\nexport function createStore<State>(\n  defaultState: State,\n  props?: Config,\n): Store<State> {\n  const plainState = createStateRef(defaultState)\n  const oldState = createStateRef(defaultState)\n  const updates = createNamedEvent('updates')\n  const template = readTemplate()\n  plainState.after = [{type: 'copy', to: oldState}]\n  if (template) {\n    template.plain.push(plainState, oldState)\n  }\n  const plainStateId = plainState.id\n  const store: any = {\n    subscribers: new Map(),\n    updates,\n    defaultState,\n    stateRef: plainState,\n    getState() {\n      let targetRef = plainState\n      let reachedPage\n      if (currentPage) {\n        let page = currentPage\n        while (page && !page.reg[plainStateId]) {\n          page = getParent(page)\n        }\n        if (page) reachedPage = page\n      }\n      if (!reachedPage && forkPage && forkPage.reg[plainStateId]) {\n        reachedPage = forkPage\n      }\n      if (reachedPage) targetRef = reachedPage.reg[plainStateId]\n      return readRef(targetRef)\n    },\n    setState(state: any) {\n      let target\n      if (forkPage) {\n        target = forkPage.nodeMap[getGraph(store).id]\n      }\n      if (!target) target = store\n      launch({\n        target,\n        params: state,\n        defer: true,\n      })\n    },\n    reset(...units: any[]) {\n      for (const unit of units) store.on(unit, () => store.defaultState)\n      return store\n    },\n    on(nodeSet: any, fn: Function) {\n      assertNodeSet(nodeSet, '.on', 'first argument')\n      if (Array.isArray(nodeSet)) {\n        for (const event of nodeSet) {\n          onEvent(event, fn)\n        }\n      } else {\n        onEvent(nodeSet, fn)\n      }\n      return store\n    },\n    off(unit: any) {\n      const currentSubscription = getSubscribers(store).get(unit)\n      if (currentSubscription) {\n        currentSubscription()\n        getSubscribers(store).delete(unit)\n      }\n      return store\n    },\n    map(fn: any, firstState?: any) {\n      let config\n      let name\n      if (isObject(fn)) {\n        config = fn\n        name = fn.name\n        firstState = fn.firstState\n        fn = fn.fn\n      }\n      let lastResult\n      const storeState = store.getState()\n      const template = readTemplate()\n      if (template) {\n        lastResult = null\n      } else if (storeState !== undefined) {\n        lastResult = fn(storeState, firstState)\n      }\n\n      const innerStore: Store<any> = createStore(lastResult, {\n        name: mapName(store, name),\n        config,\n        strict: false,\n      })\n      const linkNode = updateStore(store, innerStore, MAP, false, fn)\n\n      getStoreState(innerStore).before = [\n        {\n          type: MAP,\n          fn,\n          from: plainState,\n        },\n      ]\n      if (template) {\n        if (!includes(template.plain, plainState)) {\n          if (!includes(linkNode.seq, template.loader)) {\n            linkNode.seq.unshift(template.loader)\n          }\n        }\n      }\n      return innerStore\n    },\n    watch(eventOrFn: any, fn?: Function) {\n      if (!fn || !is.unit(eventOrFn)) {\n        const subscription = watchUnit(store, eventOrFn)\n        const template = readTemplate()\n        if (template) {\n          template.watch.push({\n            of: plainState,\n            fn: eventOrFn,\n          })\n        } else {\n          eventOrFn(store.getState())\n        }\n        return subscription\n      }\n      if (!isFunction(fn)) throwError('second argument should be a function')\n      return eventOrFn.watch((payload: any) => fn(store.getState(), payload))\n    },\n  }\n  function onEvent(event: any, fn: Function) {\n    store.off(event)\n    getSubscribers(store).set(\n      event,\n      createSubscription(\n        updateStore(event, store, 'on', true, fn, updateFilter),\n      ),\n    )\n  }\n  const meta = initUnit(STORE, store, props)\n  const updateFilter = store.defaultConfig.updateFilter\n  store.graphite = createNode({\n    scope: {state: plainState},\n    node: [\n      step.check.defined(),\n      step.check.changed({\n        store: oldState,\n      }),\n      updateFilter && step.mov({store: oldState, to: REG_A}),\n      updateFilter &&\n        step.filter({\n          fn: (update, _, {a}) => updateFilter(update, a),\n        }),\n      step.update({\n        store: plainState,\n      }),\n      step.update({\n        store: oldState,\n      }),\n    ],\n    child: updates,\n    meta,\n    regional: true,\n  })\n  if (isStrict && defaultState === undefined)\n    throwError(\"current state can't be undefined, use null instead\")\n  own(store, [updates])\n  return store\n}\n\nconst updateStore = (\n  from: any,\n  store: Store<any>,\n  op: string,\n  stateFirst: boolean,\n  fn: Function,\n  updateFilter?: Function,\n) => {\n  const storeRef = getStoreState(store)\n  const node = [\n    step.mov({store: storeRef, to: REG_A}),\n    step.compute({\n      fn: stateFirst ? callARegStack : callStackAReg,\n    }),\n    step.check.defined(),\n    step.check.changed({store: storeRef}),\n    updateFilter &&\n      step.filter({\n        fn: (update, _, {a}) => updateFilter(update, a),\n      }),\n    step.update({store: storeRef}),\n  ]\n  const template = readTemplate()\n  if (template) {\n    node.unshift(template.loader)\n    node.push(template.upward)\n    if (is.store(from)) {\n      const ref = getStoreState(from)\n      if (!includes(template.plain, ref)) {\n        //if (!includes(node, template.loader)) {\n        //  node.unshift(template.loader)\n        //}\n        if (!includes(template.closure, ref)) {\n          template.closure.push(ref)\n        }\n        if (!storeRef.before) storeRef.before = []\n        storeRef.before.push({\n          type: 'closure',\n          of: ref,\n        })\n      }\n    } else {\n      //if (!includes(node, template.loader)) {\n      //  node.unshift(template.loader)\n      //}\n    }\n  }\n  return createLinkNode(from, store, {\n    scope: {fn},\n    node,\n    meta: {op},\n  })\n}\n","import {Store} from './unit.h'\nimport {createStore} from './createUnit'\nimport {createStateRef} from './stateRef'\nimport {step} from './typedef'\nimport {onConfigNesting} from './config'\nimport {getGraph, getStoreState} from './getter'\nimport {is, isFunction, isObject} from './is'\nimport {unitObjectName} from './naming'\nimport {createLinkNode} from './forward'\nimport {throwError} from './throw'\nimport {readTemplate} from './region'\nimport {forIn, includes} from './collection'\nimport {BARRIER, MAP, REG_A, VALUE} from './tag'\n\nexport function combine(...args: any[]): Store<any> {\n  let handler\n  let stores\n  let config\n  onConfigNesting(args[0], (injectedData, userConfig) => {\n    config = injectedData\n    args = userConfig\n  })\n  const rawHandler = args[args.length - 1]\n  if (isFunction(rawHandler)) {\n    stores = args.slice(0, -1)\n    handler = rawHandler\n  } else {\n    stores = args\n  }\n\n  let structStoreShape\n  let shapeReady\n  if (stores.length === 1) {\n    const obj = stores[0]\n    /*\n      without edge case combine(Color, (Color) => '~')\n      */\n    if (!is.store(obj)) {\n      /*\n      case combine([R,G,B], ([R,G,B]) => '~')\n      case combine({R,G,B}, ({R,G,B}) => '~')\n\n      edge case combine([Color], ([Color]) => '~')\n      edge case combine({Color}, ({Color}) => '~')\n\n      edge case combine([R,G,B])\n      edge case combine({R,G,B})\n\n      edge case combine([Color])\n      edge case combine({Color})\n      */\n      structStoreShape = obj\n      shapeReady = true\n    }\n  }\n  if (!shapeReady) {\n    /*\n    case combine(R,G,B, (R,G,B) => '~')\n    */\n    structStoreShape = stores\n    /*\n    without edge case combine(R,G,B)\n    without edge case combine(Color)\n    */\n    if (handler) {\n      handler = spreadArgs(handler)\n    }\n  }\n  if (!isObject(structStoreShape)) throwError('shape should be an object')\n  return storeCombination(\n    Array.isArray(structStoreShape),\n    structStoreShape,\n    config,\n    handler,\n  )\n}\n\nconst spreadArgs = (fn: Function) => (list: any[]) => fn(...list)\n\nconst storeCombination = (\n  isArray: boolean,\n  obj: any,\n  config?: string,\n  fn?: (upd: any) => any,\n) => {\n  const clone = isArray ? (list: any) => list.slice() : (obj: any) => ({...obj})\n  const defaultState: any = isArray ? [] : {}\n  const template = readTemplate()\n  const stateNew = clone(defaultState)\n  const rawShape = createStateRef(stateNew)\n  const isFresh = createStateRef(true)\n  rawShape.type = isArray ? 'list' : 'shape'\n  if (template) {\n    template.plain.push(rawShape, isFresh)\n  }\n  const store = createStore(stateNew, {\n    name: config ? config : unitObjectName(obj),\n  })\n  getGraph(store).meta.isCombine = true\n  const node = [\n    step.check.defined(),\n    step.mov({\n      store: rawShape,\n      to: REG_A,\n    }),\n    //prettier-ignore\n    step.filter({\n      fn: (upd, {key}, {a}) => upd !== a[key],\n    }),\n    step.mov({\n      store: isFresh,\n      to: 'b',\n    }),\n    step.compute({\n      fn(upd, {clone, key}, reg) {\n        if (reg.b) {\n          reg.a = clone(reg.a)\n        }\n        reg.a[key] = upd\n      },\n    }),\n    step.mov({\n      from: REG_A,\n      target: rawShape,\n    }),\n    step.mov({\n      from: VALUE,\n      store: false,\n      target: isFresh,\n    }),\n    step.barrier({priority: BARRIER}),\n    step.mov({\n      from: VALUE,\n      store: true,\n      target: isFresh,\n    }),\n    step.mov({store: rawShape}),\n    fn && step.compute({fn}),\n    step.check.changed({\n      store: getStoreState(store),\n    }),\n  ]\n  const before: any[] = (rawShape.before = [])\n  forIn(obj, (child: Store<any> | any, key) => {\n    if (!is.store(child)) {\n      stateNew[key] = defaultState[key] = child\n      return\n    }\n    defaultState[key] = child.defaultState\n    stateNew[key] = child.getState()\n    const linkNode = createLinkNode(child, store, {\n      scope: {key, clone},\n      node,\n      meta: {op: 'combine'},\n    })\n    const childRef = getStoreState(child)\n    before.push({\n      type: 'field',\n      field: key,\n      from: childRef,\n    })\n    if (template) {\n      if (!includes(template.plain, childRef)) {\n        linkNode.seq.unshift(template.loader)\n      }\n    }\n  })\n\n  store.defaultShape = obj\n  rawShape.after = [\n    fn\n      ? {\n          type: MAP,\n          to: getStoreState(store),\n          fn,\n        }\n      : {\n          type: 'copy',\n          to: getStoreState(store),\n        },\n  ]\n  if (!template) {\n    store.defaultState = fn\n      ? (getStoreState(store).current = fn(stateNew))\n      : defaultState\n  }\n  return store\n}\n","export function createDefer(): {\n  rs: (value: any) => any\n  rj: (value: any) => any\n  req: Promise<any>\n} {\n  const result = {} as {\n    rs: (value: any) => any\n    rj: (value: any) => any\n    req: Promise<any>\n  }\n  result.req = new Promise((rs, rj) => {\n    result.rs = rs\n    result.rj = rj\n  })\n  result.req.catch(err => {})\n  return result\n}\n","import {step} from './typedef'\nimport {getForkPage, getGraph, getParent} from './getter'\nimport {own} from './own'\nimport {createNode} from './createNode'\nimport {launch, setForkPage, forkPage, isWatch} from './kernel'\nimport {createNamedEvent, createStore, createEvent} from './createUnit'\nimport {createDefer} from './defer'\nimport {isObject, isFunction} from './is'\nimport {throwError} from './throw'\nimport {EFFECT} from './tag'\n\nexport function createEffect<Payload, Done>(\n  nameOrConfig: any,\n  maybeConfig: any,\n) {\n  const instance: any = createEvent(nameOrConfig, maybeConfig)\n  let handler =\n    instance.defaultConfig.handler ||\n    (() => throwError(`no handler used in ${instance.getType()}`))\n  const node = getGraph(instance)\n  node.meta.onCopy = ['runner']\n  node.meta.unit = instance.kind = EFFECT\n  instance.use = (fn: Function) => {\n    if (!isFunction(fn)) throwError('.use argument should be a function')\n    handler = fn\n    return instance\n  }\n  const anyway = (instance.finally = createNamedEvent('finally'))\n  const done = (instance.done = (anyway as any).filterMap({\n    named: 'done',\n    fn({status, params, result}: any) {\n      if (status === 'done') return {params, result}\n    },\n  }))\n  const fail = (instance.fail = (anyway as any).filterMap({\n    named: 'fail',\n    fn({status, params, error}: any) {\n      if (status === 'fail') return {params, error}\n    },\n  }))\n  const doneData = (instance.doneData = done.map({\n    named: 'doneData',\n    fn: ({result}: any) => result,\n  }))\n  const failData = (instance.failData = fail.map({\n    named: 'failData',\n    fn: ({error}: any) => error,\n  }))\n\n  const effectRunner = createNode({\n    scope: {\n      getHandler: instance.use.getCurrent = () => handler,\n      finally: anyway,\n    },\n    node: [\n      step.run({\n        fn({params, req}, {finally: anyway, getHandler}, stack) {\n          const onResolve = onSettled({\n            params,\n            req,\n            ok: true,\n            anyway,\n            stack,\n          })\n          const onReject = onSettled({\n            params,\n            req,\n            ok: false,\n            anyway,\n            stack,\n          })\n          let result\n          try {\n            result = getHandler()(params)\n          } catch (err) {\n            return void onReject(err)\n          }\n          if (isObject(result) && isFunction(result.then)) {\n            result.then(onResolve, onReject)\n          } else {\n            onResolve(result)\n          }\n        },\n      }),\n    ],\n    meta: {\n      op: 'fx',\n      fx: 'runner',\n      onCopy: ['finally'],\n    },\n  })\n  node.scope.runner = effectRunner\n  node.seq.push(\n    step.compute({\n      fn(params, scope, stack) {\n        // empty stack means that this node was launched directly\n        if (!getParent(stack)) return params\n        return {\n          params,\n          req: {\n            rs(data: any) {},\n            rj(data: any) {},\n          },\n        }\n      },\n    }),\n    step.run({\n      fn(upd, {runner}, stack) {\n        launch({\n          target: runner,\n          params: upd,\n          defer: true,\n          forkPage: getForkPage(stack),\n        })\n        return upd.params\n      },\n    }),\n  )\n  instance.create = (params: Payload) => {\n    const req = createDefer()\n    const payload = {params, req}\n    if (forkPage) {\n      if (!isWatch) {\n        const savedFork = forkPage\n        req.req\n          .finally(() => {\n            setForkPage(savedFork)\n          })\n          .catch(() => {})\n      }\n      launch(forkPage.find(instance), payload)\n    } else {\n      launch(instance, payload)\n    }\n    return req.req\n  }\n\n  const inFlight = (instance.inFlight = createStore(0, {named: 'inFlight'})\n    .on(instance, x => x + 1)\n    .on(anyway, x => x - 1))\n\n  const pending = (instance.pending = inFlight.map({\n    //@ts-ignore\n    fn: amount => amount > 0,\n    named: 'pending',\n  }))\n\n  own(instance, [\n    anyway,\n    done,\n    fail,\n    doneData,\n    failData,\n    pending,\n    inFlight,\n    effectRunner,\n  ])\n  return instance\n}\n\nexport const onSettled = ({\n  params,\n  req,\n  ok,\n  anyway,\n  stack,\n}: {\n  params: any\n  req: {\n    rs(_: any): any\n    rj(_: any): any\n  }\n  ok: boolean\n  anyway: any\n  stack: any\n}) => (data: any) =>\n  launch({\n    target: [anyway, sidechain],\n    params: [\n      ok\n        ? {\n            status: 'done',\n            params,\n            result: data,\n          }\n        : {\n            status: 'fail',\n            params,\n            error: data,\n          },\n      {\n        fn: ok ? req.rs : req.rj,\n        value: data,\n      },\n    ],\n    defer: true,\n    page: stack.page,\n    forkPage: getForkPage(stack),\n  })\n\nexport const sidechain = createNode({\n  node: [\n    step.run({\n      fn({fn, value}) {\n        fn(value)\n      },\n    }),\n  ],\n  meta: {op: 'fx', fx: 'sidechain'},\n})\n","import {Store, Event, Effect} from './unit.h'\nimport {createEvent} from './createUnit'\nimport {forward} from './forward'\nimport {unitObjectName} from './naming'\nimport {assertNodeSet} from './is'\n\nexport function merge<T>(\n  events: Array<Event<T> | Store<T> | Effect<T, any, any>>,\n  config?: object,\n): Event<T> {\n  const result = createEvent(config || unitObjectName(events, 'merge'))\n  assertNodeSet(events, 'merge', 'first argument')\n  forward({\n    from: events,\n    to: result,\n    meta: {op: 'merge'},\n  })\n  return result\n}\n","import {combine} from './combine'\nimport {step} from './typedef'\nimport {createStateRef, readRef} from './stateRef'\nimport {callStackAReg, callARegStack} from './caller'\nimport {processArgsToConfig} from './config'\nimport {getStoreState, getGraph} from './getter'\nimport {own} from './own'\nimport {assertNodeSet, is, isObject} from './is'\nimport {createStore} from './createUnit'\nimport {createEvent} from './createUnit'\nimport {createLinkNode} from './forward'\nimport {createNode} from './createNode'\nimport {readTemplate} from './region'\nimport {throwError} from './throw'\nimport {includes, forEach} from './collection'\nimport {REG_A, SAMPLE, SAMPLER, STACK, STORE, VALUE} from './tag'\nimport {merge} from './merge'\n\nconst sampleConfigFields = ['source', 'clock', 'target']\n\nfunction validateSampleConfig(config: any) {\n  let atLeastOneFieldExists = false\n  forEach(sampleConfigFields, field => {\n    if (field in config) {\n      if (config[field] == null) {\n        throwError(`sample: ${field} should be defined`)\n      }\n      atLeastOneFieldExists = true\n    }\n  })\n  return atLeastOneFieldExists\n}\n\nexport function sample(...args: any): any {\n  let target\n  let name\n  let [[source, clock, fn], metadata] = processArgsToConfig(args)\n  let sid\n  let greedy\n  //config case\n  if (clock === undefined && isObject(source) && validateSampleConfig(source)) {\n    clock = source.clock\n    fn = source.fn\n    greedy = source.greedy\n    //optional target & name accepted only from config\n    target = source.target\n    name = source.name\n    sid = source.sid\n    source = source.source\n  }\n  let needToCombine = true\n  if (source === undefined) {\n    assertNodeSet(clock, 'sample', 'clock')\n    if (Array.isArray(clock)) {\n      clock = merge(clock)\n    }\n    source = clock\n    needToCombine = false\n  }\n  if (needToCombine && !is.unit(source)) {\n    source = combine(source)\n  }\n  if (clock === undefined) {\n    //still undefined!\n    clock = source\n  }\n  assertNodeSet(clock, 'sample', 'clock')\n  name = metadata || name || source.shortName\n  const template = readTemplate()\n  const isUpward = !!target\n  if (!target) {\n    if (is.store(source) && is.store(clock)) {\n      const initialState = fn\n        ? fn(readRef(getStoreState(source)), readRef(getStoreState(clock)))\n        : readRef(getStoreState(source))\n      target = createStore(initialState, {name, sid})\n    } else {\n      target = createEvent(name)\n      if (template) {\n        getGraph(target).seq.push(template.loader)\n      }\n    }\n  }\n  const targetTemplate =\n    isUpward && is.unit(target) && getGraph(target).meta.nativeTemplate\n  if (is.store(source)) {\n    const sourceRef = getStoreState(source)\n    own(source, [\n      createLinkNode(clock, target, {\n        scope: {fn, targetTemplate},\n        node: [\n          template && template.loader,\n          //@ts-ignore\n          !greedy && step.barrier({priority: SAMPLER}),\n          step.mov({\n            store: sourceRef,\n            to: fn ? REG_A : STACK,\n          }),\n          fn && step.compute({fn: callARegStack}),\n          template && isUpward && template.upward,\n        ],\n        meta: {op: SAMPLE, sample: STORE},\n      }),\n    ])\n    if (template) {\n      if (\n        !includes(template.plain, sourceRef) &&\n        !includes(template.closure, sourceRef)\n      ) {\n        template.closure.push(sourceRef)\n      }\n    }\n  } else {\n    const hasSource = createStateRef(false)\n    const sourceState = createStateRef()\n    const clockState = createStateRef()\n    if (template) {\n      template.plain.push(hasSource, sourceState, clockState)\n    }\n    createNode({\n      parent: source,\n      node: [\n        step.update({store: sourceState}),\n        step.mov({\n          from: VALUE,\n          store: true,\n          target: hasSource,\n        }),\n      ],\n      family: {\n        owners: [source, target, clock],\n        links: target,\n      },\n      meta: {op: SAMPLE, sample: 'source'},\n      regional: true,\n    })\n    own(source, [\n      createLinkNode(clock, target, {\n        scope: {\n          fn,\n          targetTemplate,\n        },\n        node: [\n          template && template.loader,\n          step.update({store: clockState}),\n          step.mov({store: hasSource}),\n          step.filter({fn: hasSource => hasSource}),\n          //@ts-ignore\n          !greedy && step.barrier({priority: SAMPLER}),\n          step.mov({store: sourceState}),\n          step.mov({\n            store: clockState,\n            to: REG_A,\n          }),\n          fn && step.compute({fn: callStackAReg}),\n          template && isUpward && template.upward,\n        ],\n        meta: {op: SAMPLE, sample: 'clock'},\n      }),\n    ])\n  }\n  return target\n}\n","import {getForkPage, getGraph, getLinks, getOwners, getParent} from './getter'\nimport {bind} from './bind'\nimport {createDefer} from './defer'\nimport {watchUnit} from './watch'\nimport {is, isObject} from './is'\nimport {throwError} from './throw'\nimport {launch, forkPage, setForkPage, currentPage} from './kernel'\nimport {createNode} from './createNode'\nimport {step} from './typedef'\nimport {Domain, Store} from './unit.h'\nimport {Node, StateRef} from './index.h'\nimport {removeItem, forEach, includes, forIn} from './collection'\nimport {DOMAIN, STORE, EVENT, EFFECT, SAMPLER, MAP, FORK_COUNTER} from './tag'\n\n/**\n hydrate state on client\n\n const root = createDomain()\n hydrate(root, {\n  values: window.__initialState__\n})\n\n */\nexport function hydrate(domain: Domain, {values}: {values: any}) {\n  const isScope = isObject(domain) && (domain as any).cloneOf\n  if (!is.domain(domain) && !isScope) {\n    throwError('first argument of hydrate should be domain or scope')\n  }\n  if (!isObject(values)) {\n    throwError('values property should be an object')\n  }\n  const normalizedValues = normalizeValues(values)\n  let storeWatches: Node[]\n  let storeWatchesRefs: any[]\n  if (isScope) {\n    storeWatches = []\n    storeWatchesRefs = []\n    forIn(normalizedValues, (val, sid) => {\n      //@ts-ignore\n      const node = domain.sidMap[sid]\n      if (node) {\n        storeWatches.push(node)\n        storeWatchesRefs.push(val)\n        ;(domain as any).changedStores.add(node.meta.forkOf.id)\n      }\n    })\n  } else {\n    const fillResult = fillValues({\n      flatGraphUnits: flatGraph(domain),\n      values: normalizedValues,\n      collectWatches: true,\n    })\n    storeWatches = fillResult.storeWatches\n    storeWatchesRefs = fillResult.storeWatchesRefs.map(({current}) => current)\n  }\n\n  launch({\n    target: storeWatches,\n    params: storeWatchesRefs,\n    forkPage: isScope ? domain : false,\n  })\n}\n\nfunction fillValues({\n  flatGraphUnits,\n  values,\n  collectWatches,\n}: {\n  flatGraphUnits: Node[]\n  values: Record<string, any>\n  collectWatches: boolean\n}) {\n  const storeWatches: Node[] = []\n  const storeWatchesRefs: StateRef[] = []\n  const refsMap = {} as Record<string, StateRef>\n  const predefinedRefs = new Set()\n  const valuesSidList = Object.getOwnPropertyNames(values)\n  forEach(flatGraphUnits, node => {\n    const {reg} = node\n    const {op, unit, sid} = node.meta\n    if (unit === STORE) {\n      if (sid && includes(valuesSidList, sid)) {\n        const {state} = node.scope\n        state.current = values[sid]\n        predefinedRefs.add(state)\n      }\n    }\n    if (collectWatches && op === 'watch') {\n      const owner = node.family.owners[0]\n      if (owner.meta.unit === STORE) {\n        storeWatches.push(node)\n        storeWatchesRefs.push(owner.scope.state)\n      }\n    }\n    forIn(reg, (ref, id) => {\n      refsMap[id] = ref\n    })\n  })\n  const refGraph = createRefGraph(refsMap)\n  const result = toposort(refGraph)\n  forEach(result, id => {\n    execRef(refsMap[id])\n  })\n\n  return {\n    storeWatches,\n    storeWatchesRefs,\n  }\n\n  function execRef(ref: StateRef) {\n    let isFresh = false\n    if (ref.before && !predefinedRefs.has(ref)) {\n      forEach(ref.before, cmd => {\n        switch (cmd.type) {\n          case MAP: {\n            const from = cmd.from\n            ref.current = cmd.fn(from.current)\n            break\n          }\n          case 'field': {\n            const from = cmd.from\n            if (!isFresh) {\n              isFresh = true\n              if (Array.isArray(ref.current)) {\n                ref.current = [...ref.current]\n              } else {\n                ref.current = {...ref.current}\n              }\n            }\n            ref.current[cmd.field] = from.current\n            break\n          }\n          case 'closure':\n            break\n        }\n      })\n    }\n    if (!ref.after) return\n    const value = ref.current\n    forEach(ref.after, cmd => {\n      const to = cmd.to\n      // if (predefinedRefs.has(to)) continue\n      switch (cmd.type) {\n        case 'copy':\n          to.current = value\n          break\n        case MAP:\n          to.current = cmd.fn(value)\n          break\n      }\n    })\n  }\n}\n\nfunction createRefGraph(refsMap: Record<string, StateRef>) {\n  const items = Object.values(refsMap)\n  const refGraph = {} as Record<string, string[]>\n  forEach(items, ({id}) => {\n    refGraph[id] = []\n  })\n  //prettier-ignore\n  forEach(items, ({id, before, after}) => {\n    before && forEach(before, cmd => {\n      refGraph[cmd.from.id].push(id)\n    })\n    after && forEach(after, cmd => {\n      refGraph[id].push(cmd.to.id)\n    })\n  })\n  return refGraph\n}\n\n/**\n serialize state on server\n */\nexport function serialize(\n  {clones, changedStores}: any,\n  {\n    ignore = [],\n    onlyChanges,\n  }: {ignore?: Array<Store<any>>; onlyChanges?: boolean} = {},\n) {\n  const result = {} as Record<string, any>\n  forEach(clones, ({meta, scope, reg}) => {\n    if (meta.unit !== STORE) return\n    const {sid} = meta\n    if (!sid) return\n    if (onlyChanges || meta.isCombine) {\n      if (!changedStores.has(meta.forkOf.id)) return\n    }\n    result[sid] = reg[scope.state.id].current\n  })\n  forEach(ignore, ({sid}) => {\n    if (sid) delete result[sid]\n  })\n  return result\n}\n\n/** bind event to scope */\nexport function scopeBind(unit: any) {\n  if (!forkPage) {\n    throwError('scopeBind cannot be called outside of forked .watch')\n  }\n  const savedForkPage = forkPage\n  const localUnit = forkPage.find(unit)\n  return is.effect(unit)\n    ? (params: any) => {\n        const req = createDefer()\n        launch({\n          target: localUnit,\n          params: {\n            params,\n            req,\n          },\n          forkPage: savedForkPage,\n        })\n      }\n    : (params: any) => {\n        launch({target: localUnit, params, forkPage: savedForkPage})\n        return params\n      }\n}\n\nfunction normalizeValues(\n  values: Map<Store<any>, any> | Record<string, any>,\n  assertEach = (key: any, value: any) => {},\n) {\n  if (values instanceof Map) {\n    const result = {} as Record<string, any>\n    for (const [key, value] of values) {\n      if (!is.unit(key)) throwError('Map key should be a unit')\n      assertEach(key, value)\n      result[key.sid!] = value\n    }\n    return result\n  }\n  return values\n}\n\nexport function fork(\n  domain: Domain,\n  {values, handlers}: {values?: any; handlers?: any} = {},\n) {\n  if (!is.domain(domain)) throwError('first argument of fork should be domain')\n  const needToFill = !!values\n  values = normalizeValues(\n    values || {},\n    unit =>\n      !is.store(unit) &&\n      throwError('Values map can contain only stores as keys'),\n  )\n  const forked = cloneGraph(domain)\n  if (needToFill) {\n    fillValues()\n  }\n  if (handlers) {\n    handlers = normalizeValues(\n      handlers,\n      unit =>\n        !is.effect(unit) &&\n        throwError(`Handlers map can contain only effects as keys`),\n    )\n    const handlerKeys = Object.keys(handlers)\n    forEach(forked.clones, ({scope, meta}) => {\n      if (meta.sid && includes(handlerKeys, meta.sid)) {\n        scope.runner.scope.getHandler = () => handlers[meta.sid]\n      }\n    })\n  }\n  return forked\n\n  function fillValues() {\n    const sourceList = flatGraph(domain)\n    const sourceRefsMap = {} as Record<string, StateRef>\n    const refsMap = {} as Record<string, StateRef>\n    const predefinedRefs = new Set()\n    const templateOwnedRefs = new Set<string>()\n    const valuesSidList = Object.getOwnPropertyNames(values)\n    forEach(sourceList, ({reg, meta}) => {\n      const {nativeTemplate} = meta\n      forIn(reg, (ref, id) => {\n        sourceRefsMap[id] = ref\n        if (nativeTemplate) {\n          templateOwnedRefs.add(id)\n        }\n      })\n    })\n    forEach(forked.clones, node => {\n      const {reg} = node\n      const {unit, sid} = node.meta\n      if (unit === STORE) {\n        if (sid && includes(valuesSidList, sid)) {\n          const {state} = node.scope\n          reg[state.id].current = values[sid]\n          predefinedRefs.add(state)\n          forked.changedStores.add(node.meta.forkOf.id)\n        }\n      }\n      forIn(reg, (ref, id) => {\n        refsMap[id] = ref\n      })\n    })\n    const refGraph = createRefGraph(sourceRefsMap)\n    const result = toposort(refGraph, templateOwnedRefs)\n    forEach(result, id => {\n      execRef(refsMap[id], sourceRefsMap[id])\n    })\n\n    function execRef(ref: StateRef, sourceRef?: StateRef) {\n      let isFresh = false\n      if (sourceRef && sourceRef.before && !predefinedRefs.has(ref)) {\n        forEach(sourceRef.before, cmd => {\n          switch (cmd.type) {\n            case MAP: {\n              const from = refsMap[cmd.from.id]\n              ref.current = cmd.fn(from.current)\n              break\n            }\n            case 'field': {\n              const from = refsMap[cmd.from.id]\n              if (!isFresh) {\n                isFresh = true\n                if (Array.isArray(ref.current)) {\n                  ref.current = [...ref.current]\n                } else {\n                  ref.current = {...ref.current}\n                }\n              }\n              ref.current[cmd.field] = from.current\n              break\n            }\n            case 'closure':\n              break\n          }\n        })\n      }\n      if (!sourceRef || !sourceRef.after) return\n      const value = ref.current\n      forEach(sourceRef.after, cmd => {\n        const to = refsMap[cmd.to.id]\n        // if (predefinedRefs.has(to)) continue\n        switch (cmd.type) {\n          case 'copy':\n            to.current = value\n            break\n          case MAP:\n            to.current = cmd.fn(value)\n            break\n        }\n      })\n    }\n  }\n}\n\nfunction toposort(rawGraph: Record<string, string[]>, ignore?: Set<string>) {\n  const graph = {} as Record<string, string[]>\n  for (const id in rawGraph) {\n    graph[id] = [...new Set(rawGraph[id])]\n  }\n  const result = [] as string[]\n  const visited = {} as Record<string, boolean>\n  const temp = {} as Record<string, boolean>\n  for (const node in graph) {\n    if (!visited[node] && !temp[node]) {\n      topologicalSortHelper(node)\n    }\n  }\n  result.reverse()\n  if (ignore && ignore.size > 0) {\n    const processed = [] as string[]\n    const ignored = [...ignore]\n    let item: string | void\n    while ((item = ignored.shift())) {\n      processed.push(item)\n      forEach(graph[item], child => {\n        if (includes(processed, child) || includes(ignored, child)) return\n        ignored.push(child)\n      })\n    }\n    forEach(processed, item => {\n      removeItem(result, item)\n    })\n  }\n  return result\n\n  function topologicalSortHelper(node: string) {\n    temp[node] = true\n    const neighbors = graph[node]\n    for (let i = 0; i < neighbors.length; i++) {\n      const n = neighbors[i]\n      if (temp[n]) {\n        continue\n        // throw Error('found cycle in DAG')\n      }\n      if (!visited[n]) {\n        topologicalSortHelper(n)\n      }\n    }\n    temp[node] = false\n    visited[node] = true\n    result.push(node)\n  }\n}\n\nexport function allSettled(\n  start: any,\n  {scope, params: ctx}: {scope: any; params?: any},\n) {\n  if (!is.unit(start))\n    return Promise.reject(Error('first argument should be unit'))\n  const defer = createDefer()\n  //@ts-ignore\n  defer.parentFork = forkPage\n  const {forkInFlightCounter} = scope.graphite.scope\n  forkInFlightCounter.scope.defers.push(defer)\n  const contextStart = scope.find(start)\n\n  const launchUnits = [contextStart]\n  const launchParams = []\n  if (is.effect(start)) {\n    launchParams.push({\n      params: ctx,\n      req: {\n        rs(value: any) {\n          //@ts-ignore\n          defer.value = {status: 'done', value}\n        },\n        rj(value: any) {\n          //@ts-ignore\n          defer.value = {status: 'fail', value}\n        },\n      },\n    })\n  } else {\n    launchParams.push(ctx)\n  }\n  launchUnits.push(forkInFlightCounter)\n  launchParams.push(null)\n  launch({\n    target: launchUnits,\n    params: launchParams,\n    forkPage: scope,\n  })\n  return defer.req\n}\n\nfunction flatGraph(unit: any) {\n  const list = [] as Node[]\n  ;(function traverse(node) {\n    if (includes(list, node)) return\n    list.push(node)\n    forEachRelatedNode(node, traverse)\n  })(getGraph(unit))\n  return list\n}\n\n/**\n everything we need to clone graph section\n reachable from given unit\n */\nfunction cloneGraph(unit: any) {\n  const list = flatGraph(unit)\n  const refs = new Map()\n  const scope = {\n    defers: [],\n    inFlight: 0,\n    fxID: 0,\n  }\n  const changedStores = new Set<string>()\n  const putStoreToChanged = step.compute({\n    fn(upd, _, stack) {\n      if (\n        !stack.node.meta.isCombine ||\n        (getParent(stack) && getParent(stack).node.meta.op !== 'combine')\n      )\n        changedStores.add(stack.node.meta.forkOf.id)\n      return upd\n    },\n  })\n  const forkInFlightCounter = createNode({\n    scope,\n    node: [\n      step.compute({\n        fn(_, scope, stack) {\n          if (!stack.parent) {\n            scope.fxID += 1\n            return\n          }\n          if (stack.parent.node.meta.named === 'finally') {\n            scope.inFlight -= 1\n          } else {\n            scope.inFlight += 1\n            scope.fxID += 1\n          }\n        },\n      }),\n      step.barrier({priority: SAMPLER}),\n      step.run({\n        fn(_, scope) {\n          const {inFlight, defers, fxID} = scope\n          if (inFlight > 0 || defers.length === 0) return\n          Promise.resolve().then(() => {\n            if (scope.fxID !== fxID) return\n            forEach(defers.splice(0, defers.length), (defer: any) => {\n              setForkPage(defer.parentFork)\n              defer.rs(defer.value)\n            })\n          })\n        },\n      }),\n    ],\n    meta: {unit: FORK_COUNTER},\n  })\n  const nodeMap = {} as Record<string, Node>\n  const sidMap = {} as Record<string, Node>\n  const clones = list.map(node => {\n    const {seq, next, meta, scope} = node\n    const result = createNode({\n      node: seq.map(step => ({\n        id: step.id,\n        type: step.type,\n        data: {...step.data},\n        hasRef: step.hasRef,\n      })) as any,\n      child: [...next],\n      meta: {forkOf: node, ...meta},\n      scope: {...scope},\n    })\n    result.family = {\n      type: node.family.type,\n      links: [...getLinks(node)],\n      owners: [...getOwners(node)],\n    }\n    nodeMap[node.id] = result\n    if (meta.sid) sidMap[meta.sid] = result\n    return result\n  })\n  const page = {} as Record<string, StateRef>\n  forEach(clones, node => {\n    const {\n      reg,\n      scope,\n      meta: {onCopy, op, unit},\n    } = node\n    forIn(reg, (ref, id) => {\n      let newRef = refs.get(ref)\n      if (!newRef) {\n        newRef = {\n          id: ref.id,\n          current: ref.current, //ref.id in values ? values[ref.id] : ref.current,\n        }\n        refs.set(ref, newRef)\n      }\n      page[id] = reg[id] = newRef\n    })\n    if (onCopy) {\n      forEach(onCopy, (copyField: string) => {\n        const origValue = scope[copyField]\n        scope[copyField] = Array.isArray(origValue)\n          ? origValue.map(findClone)\n          : findClone(origValue)\n      })\n    }\n    forEachRelatedNode(node, (node, i, siblings) => {\n      siblings[i] = findClone(node)\n    })\n    const itemTag = op || unit\n    switch (itemTag) {\n      case STORE:\n        node.meta.wrapped = wrapStore(node)\n        if (node.meta.sid) node.seq.push(putStoreToChanged)\n        break\n      // case EVENT:\n      //   break\n      case EFFECT:\n        node.next.push(forkInFlightCounter)\n        break\n      case 'fx': {\n        scope.finally.next.push(forkInFlightCounter)\n        break\n      }\n      // case 'watch':\n      //   break\n    }\n  })\n\n  return {\n    cloneOf: unit,\n    changedStores,\n    nodeMap,\n    sidMap,\n    clones,\n    find: findClone,\n    reg: page,\n    getState: (store: any) => findClone(store).meta.wrapped.getState(),\n    graphite: createNode({\n      family: {\n        type: DOMAIN,\n        links: [forkInFlightCounter, ...clones],\n      },\n      meta: {unit: 'fork'},\n      scope: {forkInFlightCounter},\n    }),\n  }\n\n  function findClone(unit: any) {\n    const node = getGraph(unit)\n    const index = list.indexOf(node)\n    if (index === -1) {\n      let unitName = 'unit'\n      if (unit !== node && unit.id !== unit.shortName) unitName = unit.shortName\n      throwError(`${unitName} not found in forked scope`)\n    }\n    return clones[index]\n  }\n}\n\nfunction wrapStore(node: Node) {\n  return {\n    kind: STORE,\n    getState: () => node.reg[node.scope.state.id].current,\n    updates: {\n      watch: bind(watchUnit, node),\n    },\n    graphite: node,\n    family: node.family,\n  }\n}\n\nfunction forEachRelatedNode(\n  node: Node,\n  cb: (node: Node, index: number, siblings: Node[]) => void,\n) {\n  const unit = node.meta.unit\n  if (unit === 'fork' || unit === FORK_COUNTER) return\n  forEach(node.next, cb)\n  forEach(getOwners(node), cb)\n  forEach(getLinks(node), cb)\n}\n","export const observableSymbol: any =\n  (typeof Symbol !== 'undefined' && Symbol.observable) || '@@observable'\n","export const STORE = 'store'\nexport const EVENT = 'event'\nexport const EFFECT = 'effect'\nexport const DOMAIN = 'domain'\nexport const SAMPLER = 'sampler'\nexport const CROSSLINK = 'crosslink'\nexport const MAP = 'map'\nexport const STACK = 'stack'\nexport const BARRIER = 'barrier'\nexport const VALUE = 'value'\nexport const FORK_COUNTER = 'forkInFlightCounter'\nexport const SAMPLE = 'sample'\nexport const FILTER = 'filter'\nexport const REG_A = 'a'\n","import {kind} from './index.h'\nimport {DOMAIN, STORE, EVENT, EFFECT} from './tag'\nimport {isObject, isFunction} from './is'\n\nexport const unit = (obj: any) =>\n  (isFunction(obj) || isObject(obj)) && 'kind' in obj\n\nconst is = (type: kind) => (obj: any) => unit(obj) && obj.kind === type\n\nexport const store = is(STORE)\nexport const event = is(EVENT)\nexport const effect = is(EFFECT)\nexport const domain = is(DOMAIN)\n","export const throwError = (message: string) => {\n  throw Error(message)\n}\n","const idCount = () => {\n  let id = 0\n  return () => (++id).toString(36)\n}\n\nexport const nextUnitID = idCount()\nexport const nextStepID = idCount()\nexport const nextNodeID = idCount()\n","export const bind = (fn: Function, target: any) => fn.bind(null, target)\nexport const bind2 = (fn: Function, target: any, arg: any) =>\n  fn.bind(null, target, arg)\n","import {StateRef, Run, Filter, Compute, Barrier, Check, Mov} from './index.h'\nimport {nextStepID} from './id'\nimport {bind2} from './bind'\nimport {BARRIER, FILTER, STACK, STORE} from './tag'\n\nconst cmd = (type: any, hasRef: boolean, data: any): any => ({\n  id: nextStepID(),\n  type,\n  data,\n  hasRef,\n})\n\nlet nextBarrierID = 0\n\nexport const barrier: (data: {priority?: 'barrier' | 'sampler'}) => Barrier = ({\n  priority = BARRIER,\n}) =>\n  cmd(BARRIER, false, {\n    barrierID: ++nextBarrierID,\n    priority,\n  })\nexport const mov: (data: {\n  from?: 'value' | 'store' | 'stack' | 'a' | 'b'\n  to?: 'stack' | 'a' | 'b' | 'store'\n  store?: any\n  target?: any\n}) => Mov = ({from = STORE, store, target, to = target ? STORE : STACK}) =>\n  cmd('mov', from === STORE, {from, store, to, target})\nexport const check: {\n  defined(): Check\n  changed(config: {store: StateRef}): Check\n} = {\n  defined: () => cmd('check', false, {type: 'defined'}),\n  changed: ({store}) => cmd('check', true, {type: 'changed', store}),\n}\nexport const compute: (data: {\n  fn: (data: any, scope: {[key: string]: any}, stack: any) => any\n}) => Compute = bind2(cmd, 'compute', false)\nexport const filter: (data: {\n  fn: (data: any, scope: {[key: string]: any}, stack: any) => any\n}) => Filter = bind2(cmd, FILTER, false)\nexport const run: (data: {\n  fn: (data: any, scope: {[key: string]: any}, stack: any) => any\n}) => Run = bind2(cmd, 'run', false)\nexport const update: (data: {store: StateRef}) => Mov = ({store}) =>\n  mov({from: STACK, target: store})\n","import {StateRef} from './index.h'\nimport {nextStepID} from './id'\n\nexport const createStateRef = (current?: any): StateRef => ({\n  id: nextStepID(),\n  current,\n})\nexport const readRef = ({current}: StateRef | {current: any}) => current\n","export const callStackAReg = (stack: any, {fn}: any, {a}: any) => fn(stack, a)\nexport const callARegStack = (stack: any, {fn}: any, {a}: any) => fn(a, stack)\nexport const callStack = (stack: any, {fn}: any, _: any) => fn(stack)\n","import {Node, StateRef} from './index.h'\n\nexport const getGraph = (graph: any): Node => graph.graphite || graph\nexport const getOwners = (node: Node) => node.family.owners\nexport const getLinks = (node: Node) => node.family.links\nexport const getStoreState = (store: any): StateRef => store.stateRef\nexport const getConfig = (opts: any) => opts.config\nexport const getNestedConfig = (opts: any) => opts.ɔ\nexport const getValue = (stack: any) => stack.value\nexport const getSubscribers = (store: any) => store.subscribers\nexport const getParent = (unit: any) => unit.parent\nexport const getForkPage = (val: any) => val.forkPage\n","import {NodeUnit} from './index.h'\nimport {getGraph, getOwners, getLinks} from './getter'\nimport {DOMAIN, CROSSLINK} from './tag'\n\nexport const own = (ownerUnit: NodeUnit, links: NodeUnit[]) => {\n  const owner = getGraph(ownerUnit)\n  for (let i = 0; i < links.length; i++) {\n    const link = getGraph(links[i])\n    if (owner.family.type !== DOMAIN) link.family.type = CROSSLINK\n    getOwners(link).push(owner)\n    getLinks(owner).push(link)\n  }\n}\n","import {getConfig, getNestedConfig} from './getter'\nimport {assertObject} from './is'\n\nexport const onConfigNesting = (\n  rawConfig: any,\n  fn: (babelData: any, userConfig: any) => void,\n) => {\n  assertObject(rawConfig)\n  if (getNestedConfig(rawConfig)) {\n    fn(getConfig(rawConfig), getNestedConfig(rawConfig))\n  }\n}\n\nexport const processArgsToConfig = (args: any[]): [any[], any | void] => {\n  let metadata\n  onConfigNesting(args[0], (injected, config) => {\n    metadata = injected\n    args = config\n  })\n  return [args, metadata]\n}\n","import {Node, NodeUnit} from './index.h'\nimport {getGraph, getOwners, getLinks, getSubscribers} from './getter'\nimport {is} from './is'\nimport {removeItem} from './collection'\nimport {CROSSLINK} from './tag'\n\nconst removeFromNode = (currentNode: Node, targetNode: Node) => {\n  removeItem(currentNode.next, targetNode)\n  removeItem(getOwners(currentNode), targetNode)\n  removeItem(getLinks(currentNode), targetNode)\n}\nconst clearNodeNormalized = (\n  targetNode: Node,\n  deep: boolean,\n  isDomainUnit: boolean,\n) => {\n  targetNode.next.length = 0\n  targetNode.seq.length = 0\n  //@ts-ignore\n  targetNode.scope = null\n  let currentNode\n  let list = getLinks(targetNode)\n  while ((currentNode = list.pop())) {\n    removeFromNode(currentNode, targetNode)\n    if (\n      deep ||\n      (isDomainUnit && !targetNode.meta.sample) ||\n      currentNode.family.type === CROSSLINK\n    ) {\n      clearNodeNormalized(\n        currentNode,\n        deep,\n        currentNode.meta.op !== 'on' && isDomainUnit,\n      )\n    }\n  }\n  list = getOwners(targetNode)\n  while ((currentNode = list.pop())) {\n    removeFromNode(currentNode, targetNode)\n    if (isDomainUnit && currentNode.family.type === CROSSLINK) {\n      clearNodeNormalized(\n        currentNode,\n        deep,\n        currentNode.meta.op !== 'on' && isDomainUnit,\n      )\n    }\n  }\n}\nconst clearMap = (map: any) => map.clear()\nexport const clearNode = (\n  graphite: NodeUnit,\n  {\n    deep,\n  }: {\n    deep?: boolean\n  } = {},\n) => {\n  let isDomainUnit = false\n  //@ts-ignore\n  if (graphite.ownerSet) graphite.ownerSet.delete(graphite)\n  if (is.store(graphite)) {\n    clearMap(getSubscribers(graphite))\n  } else if (is.domain(graphite)) {\n    isDomainUnit = true\n    //@ts-ignore\n    const history = graphite.history\n    clearMap(history.events)\n    clearMap(history.effects)\n    clearMap(history.stores)\n    clearMap(history.domains)\n  }\n  clearNodeNormalized(getGraph(graphite), !!deep, isDomainUnit)\n}\n","import {Subscription, NodeUnit} from './index.h'\nimport {bind2} from './bind'\nimport {clearNode} from './clearNode'\n\nexport const createSubscription = (node: NodeUnit): Subscription => {\n  const result = bind2(clearNode, node, undefined)\n  result.unsubscribe = result\n  return result\n}\n","import {onConfigNesting} from './config'\nimport {createNode} from './createNode'\nimport {Subscription, NodeUnit, Cmd} from './index.h'\nimport {createSubscription} from './subscription'\nimport {assertNodeSet} from './is'\n\nexport const createLinkNode = (\n  parent: NodeUnit,\n  child: NodeUnit | NodeUnit[],\n  {\n    node,\n    scope,\n    meta,\n  }: {\n    node?: Array<Cmd | false | void | null>\n    scope?: {[name: string]: any}\n    meta?: {[name: string]: any}\n  },\n) =>\n  createNode({\n    node,\n    parent,\n    child,\n    scope,\n    meta,\n    family: {\n      owners: [parent, child],\n      links: child,\n    },\n    regional: true,\n  })\nexport const forward = (opts: {\n  from: NodeUnit | NodeUnit[]\n  to: NodeUnit | NodeUnit[]\n  meta?: Record<string, any>\n}): Subscription => {\n  let config\n  onConfigNesting(opts, (injectedData, userConfig) => {\n    config = injectedData\n    opts = userConfig\n  })\n  const {from, to, meta = {op: 'forward'}} = opts\n  assertNodeSet(from, 'forward', '\"from\"')\n  assertNodeSet(to, 'forward', '\"to\"')\n  if (config) meta.config = config\n  return createSubscription(\n    createNode({\n      parent: from,\n      child: to,\n      meta,\n      family: {},\n      regional: true,\n    }),\n  )\n}\n","import {step} from './typedef'\nimport {callStack} from './caller'\nimport {createNode} from './createNode'\nimport {Subscription, NodeUnit} from './index.h'\nimport {createSubscription} from './subscription'\nimport {throwError} from './throw'\nimport {isFunction} from './is'\nimport {forkPage} from './kernel'\nimport {getGraph} from './getter'\n\nexport const watchUnit = (\n  unit: NodeUnit,\n  handler: (payload: any) => any,\n): Subscription => {\n  if (!isFunction(handler)) throwError('.watch argument should be a function')\n  if (forkPage) {\n    const forkedNode = forkPage.nodeMap[getGraph(unit).id]\n    if (forkedNode) unit = forkedNode\n  }\n  return createSubscription(\n    createNode({\n      scope: {fn: handler},\n      node: [step.run({fn: callStack})],\n      parent: unit,\n      meta: {op: 'watch'},\n      family: {\n        owners: unit,\n      },\n      regional: true,\n    }),\n  )\n}\n","import {Store, Event, Effect, Domain} from './unit.h'\nimport {own} from './own'\nimport {createNode} from './createNode'\nimport {Config, NodeUnit} from './index.h'\nimport {\n  createEvent,\n  createStore,\n  createNamedEvent,\n  initUnit,\n} from './createUnit'\nimport {createEffect} from './createEffect'\nimport {forward} from './forward'\nimport {forIn} from './collection'\nimport {getGraph, getParent} from './getter'\nimport {DOMAIN} from './tag'\nimport {launch} from './kernel'\nimport {step} from './typedef'\n\nconst createHook = (trigger: Event<any>, acc: Set<any>, node: any) => {\n  trigger.create = res => {\n    launch(trigger, res)\n    return res\n  }\n  getGraph(trigger).seq.push(\n    step.compute({\n      fn(upd, _, stack) {\n        stack.forkPage = null\n        return upd\n      },\n    }),\n  )\n  trigger.watch(data => {\n    own(node, [data])\n    acc.add(data)\n    if (!data.ownerSet) data.ownerSet = acc\n    if (!getParent(data)) data.parent = node\n  })\n  own(node, [trigger])\n  return (hook: (data: any) => any) => {\n    acc.forEach(hook)\n    return trigger.watch(hook)\n  }\n}\n\nexport function createDomain(nameOrConfig: any, maybeConfig?: any): Domain {\n  const domains: Set<Domain> = new Set()\n  const stores: Set<Store<any>> = new Set()\n  const effects: Set<Effect<any, any, any>> = new Set()\n  const events: Set<Event<any>> = new Set()\n\n  const node = createNode({\n    family: {type: DOMAIN},\n    regional: true,\n  })\n\n  const result: any = {\n    history: {\n      domains,\n      stores,\n      effects,\n      events,\n    },\n    graphite: node,\n  }\n\n  node.meta = initUnit(DOMAIN, result, maybeConfig, nameOrConfig)\n  const [event, effect, store, domain] = [\n    'onEvent',\n    'onEffect',\n    'onStore',\n    'onDomain',\n  ].map(createNamedEvent)\n\n  result.hooks = {\n    event,\n    effect,\n    store,\n    domain,\n  }\n  result.onCreateEvent = createHook(event, events, result)\n  result.onCreateEffect = createHook(effect, effects, result)\n  result.onCreateStore = createHook(store, stores, result)\n  result.onCreateDomain = createHook(domain, domains, result)\n\n  result.createEvent = result.event = (nameOrConfig: any, config?: Config) =>\n    event(\n      createEvent(nameOrConfig, {\n        parent: result,\n        config,\n      }),\n    )\n  result.createEffect = result.effect = (nameOrConfig: any, config?: Config) =>\n    effect(\n      createEffect(nameOrConfig, {\n        parent: result,\n        config,\n      }),\n    )\n  result.createDomain = result.domain = (nameOrConfig: any, config?: Config) =>\n    createDomain({\n      name: nameOrConfig,\n      parent: result,\n      config,\n    })\n  result.createStore = result.store = (state: any, config?: Config) =>\n    store(\n      createStore(state, {\n        parent: result,\n        config,\n      }),\n    )\n  const parent = getParent(result)\n  if (parent) {\n    forIn(result.hooks, (from: NodeUnit, key) => {\n      forward({from, to: parent.hooks[key]})\n    })\n    parent.hooks.domain(result)\n  }\n  return result\n}\n","import {Event} from './unit.h'\nimport {NodeUnit, Cmd} from './index.h'\nimport {is, isFunction, isObject} from './is'\nimport {forIn, includes} from './collection'\nimport {createStateRef} from './stateRef'\nimport {readTemplate} from './region'\nimport {createLinkNode} from './forward'\nimport {processArgsToConfig} from './config'\nimport {step} from './typedef'\nimport {createNode} from './createNode'\nimport {launch} from './kernel'\nimport {getStoreState} from './getter'\nimport {REG_A} from './tag'\nimport {throwError} from './throw'\nimport {createEvent} from './createUnit'\n\nconst launchCase = (\n  scopeTargets: Record<string, NodeUnit>,\n  field: string,\n  data: any,\n  stack: any,\n) => {\n  const target = scopeTargets[field]\n  if (target) {\n    launch({\n      target,\n      params: Array.isArray(target) ? target.map(() => data) : data,\n      defer: true,\n      stack,\n    })\n  }\n}\n\nexport function split(...args: any[]): any {\n  let targets: Record<string, Event<any> | NodeUnit>\n  let [[source, match], metadata] = processArgsToConfig(args)\n  const knownCases = !match\n  if (knownCases) {\n    targets = source.cases\n    match = source.match\n    source = source.source\n  }\n  const matchIsUnit = is.store(match)\n  const matchIsFunction = !is.unit(match) && isFunction(match)\n  const matchIsShape = !matchIsUnit && !matchIsFunction && isObject(match)\n  if (!targets!) targets = {}\n  if (!knownCases) {\n    if (!matchIsShape) throwError('match should be an object')\n    forIn(match, (_, key) => {\n      //@ts-ignore\n      targets[key] = createEvent(metadata)\n    })\n    targets.__ = createEvent(metadata)\n  }\n  //@ts-ignore\n  const template = readTemplate()\n  const owners = new Set(\n    ([] as NodeUnit[]).concat(source, Object.values(targets)),\n  )\n  const caseNames = Object.keys(\n    matchIsUnit || matchIsFunction ? targets : match,\n  )\n  let splitterSeq: Array<Cmd | false>\n  if (matchIsUnit || matchIsFunction) {\n    if (matchIsUnit) owners.add(match)\n    splitterSeq = [\n      matchIsUnit && step.barrier({priority: 'sampler'}),\n      matchIsUnit &&\n        step.mov({\n          store: getStoreState(match),\n          to: 'a',\n        }),\n      step.filter({\n        fn(data, scopeTargets, stack) {\n          const value = String(matchIsUnit ? stack.a : match(data))\n          launchCase(\n            scopeTargets,\n            includes(caseNames, value) ? value : '__',\n            data,\n            stack,\n          )\n        },\n      }),\n    ]\n  } else if (matchIsShape) {\n    const lastValues = createStateRef({})\n    lastValues.type = 'shape'\n    const before: any[] = (lastValues.before = [])\n    const updaterSteps = [\n      step.mov({\n        store: lastValues,\n        to: REG_A,\n      }),\n      step.compute({\n        fn(upd, {key}, {a}) {\n          a[key] = upd\n        },\n      }),\n    ]\n    const units = [] as string[]\n    let needBarrier: boolean\n    forIn(match, (storeOrFn: any, key) => {\n      if (is.unit(storeOrFn)) {\n        needBarrier = true\n        units.push(key)\n        owners.add(storeOrFn)\n        const updater = createLinkNode(storeOrFn, [], {\n          node: updaterSteps,\n          scope: {key},\n        })\n        if (is.store(storeOrFn)) {\n          lastValues.current[key] = storeOrFn.getState()\n          const storeRef = getStoreState(storeOrFn)\n          before.push({\n            type: 'field',\n            field: key,\n            from: storeRef,\n          })\n          if (template) {\n            if (!includes(template.plain, storeRef)) {\n              updater.seq.unshift(template.loader)\n            }\n          }\n        }\n      }\n    })\n    if (needBarrier! && template) {\n      template.plain.push(lastValues)\n    }\n    splitterSeq = [\n      needBarrier! && step.barrier({priority: 'sampler'}),\n      needBarrier! &&\n        step.mov({\n          store: lastValues,\n          to: 'a',\n        }),\n      step.filter({\n        fn(data, scopeTargets, stack) {\n          for (let i = 0; i < caseNames.length; i++) {\n            const caseName = caseNames[i]\n            const caseValue = includes(units, caseName)\n              ? stack.a[caseName]\n              : match[caseName](data)\n            if (caseValue) {\n              launchCase(scopeTargets, caseName, data, stack)\n              return\n            }\n          }\n          launchCase(scopeTargets, '__', data, stack)\n        },\n      }),\n    ]\n  } else {\n    throwError('expect match to be unit, function or object')\n  }\n  createNode({\n    meta: {\n      onCopy: Object.keys(targets),\n      op: 'split',\n    },\n    parent: source,\n    scope: targets,\n    node: splitterSeq!,\n    family: {\n      type: 'crosslink',\n      owners: Array.from(owners),\n    },\n    regional: true,\n  })\n  if (!knownCases) return targets\n}\n","import {combine} from './combine'\nimport {createEffect, onSettled} from './createEffect'\nimport {applyParentHook} from './createUnit'\nimport {onConfigNesting} from './config'\nimport {getGraph, getStoreState} from './getter'\nimport {own} from './own'\nimport {is} from './is'\nimport {step} from './typedef'\nimport {launch} from './kernel'\nimport {addToReg} from './createNode'\nimport {STORE, EFFECT, REG_A} from './tag'\n\nexport function attach(config: any) {\n  let injected\n  onConfigNesting(config, (injectedData, userConfig) => {\n    injected = injectedData\n    config = userConfig\n  })\n  let {source, effect, mapParams} = config\n  if (!mapParams)\n    mapParams = source\n      ? (_: any, source: any) => source\n      : (params: any) => params\n  const attached = createEffect(config, injected)\n  const {runner} = getGraph(attached).scope\n\n  let runnerSteps\n  const runnerFn = (\n    {params, req}: any,\n    {finally: anyway, effect}: any,\n    stack: any,\n  ) => {\n    const rj = onSettled({\n      params,\n      req,\n      ok: false,\n      anyway,\n      stack,\n    })\n    let computedParams\n    try {\n      computedParams = mapParams(params, stack.a)\n    } catch (err) {\n      return rj(err)\n    }\n    launch({\n      target: effect,\n      params: {\n        params: computedParams,\n        req: {\n          rs: onSettled({\n            params,\n            req,\n            ok: true,\n            anyway,\n            stack,\n          }),\n          rj,\n        },\n      },\n      page: stack.page,\n      defer: true,\n    })\n  }\n  if (source) {\n    let state\n    if (is.store(source)) {\n      state = source\n      own(source, [attached])\n    } else {\n      state = combine(source)\n      own(attached, [state])\n    }\n    const readStateRef = step.mov({\n      from: STORE,\n      store: getStoreState(state),\n      to: REG_A,\n    })\n    runnerSteps = [\n      /* let another side-effects run first */\n      step.run({fn: _ => _}),\n      /* read state. assumed it already stable here because of previous step */\n      readStateRef,\n      /* no need for step.run because of first step */\n      step.compute({fn: runnerFn}),\n    ]\n    addToReg(readStateRef, runner.reg)\n  } else {\n    runnerSteps = [step.run({fn: runnerFn})]\n  }\n  own(effect, [attached])\n  runner.scope.effect = effect\n  runner.meta.onCopy.push(EFFECT)\n  runner.seq.splice(0, 1, ...runnerSteps)\n  applyParentHook(effect, attached, EFFECT)\n  return attached\n}\n","import {Store, Event} from './unit.h'\nimport {createEvent, applyParentHook} from './createUnit'\nimport {forIn} from './collection'\nimport {getParent} from './getter'\nimport {processArgsToConfig} from './config'\n\nexport function createApi(...args: [Store<any>, {[key: string]: Function}]) {\n  let [[store, setters], metadata] = processArgsToConfig(args)\n  const result: Record<string, Event<any>> = {}\n  forIn(setters, (fn, key) => {\n    const event = (result[key] = createEvent(key, {\n      parent: getParent(store),\n      config: metadata,\n    }))\n    store.on(event, fn)\n    applyParentHook(store, event)\n  })\n  return result\n}\n","import {observableSymbol} from './observable'\nimport {Event} from './unit.h'\nimport {clearNode} from './clearNode'\nimport {createEvent} from './createUnit'\nimport {bind2} from './bind'\nimport {assertObject} from './is'\nimport {throwError} from './throw'\n\nexport function fromObservable<T>(observable: any): Event<T> {\n  assertObject(observable)\n  const observableItem =\n    observableSymbol in observable ? observable[observableSymbol]() : observable\n  if (!observableItem.subscribe)\n    throwError('expect observable to have .subscribe')\n  const event = createEvent<T>()\n  const disposer = bind2(clearNode, event, undefined)\n  observableItem.subscribe({\n    next: event,\n    error: disposer,\n    complete: disposer,\n  })\n  return event\n}\n","import {processArgsToConfig} from './config'\nimport {createLinkNode} from './forward'\nimport {sample} from './sample'\nimport {createEvent} from './createUnit'\nimport {combine} from './combine'\nimport {step} from './typedef'\nimport {callStack} from './caller'\nimport {assertNodeSet, is, isFunction} from './is'\nimport {createNode} from './createNode'\nimport {throwError} from './throw'\nimport {merge} from './merge'\n\nexport function guard(...args: any[]) {\n  const meta: Record<string, any> = {op: 'guard'}\n  let rawName = 'guard'\n  let [[source, config], metadata] = processArgsToConfig(args)\n  if (metadata) {\n    meta.config = metadata\n    if (metadata.name) rawName = metadata.name\n  }\n  if (!config) {\n    config = source\n    source = config.source\n  }\n  let {filter, greedy, clock, name = rawName} = config\n  const target = config.target || createEvent(name, meta.config)\n  const filterIsUnit = is.unit(filter)\n  let needToCombine = true\n  if (source === undefined) {\n    assertNodeSet(clock, 'guard', 'clock')\n    if (Array.isArray(clock)) {\n      clock = merge(clock)\n    }\n    source = clock\n    needToCombine = false\n  }\n  if (needToCombine && !is.unit(source)) source = combine(source)\n  if (clock) {\n    assertNodeSet(clock, 'guard', 'clock')\n    source = sample({\n      source,\n      clock,\n      greedy,\n      fn: filterIsUnit ? null : (source: any, clock: any) => ({source, clock}),\n    })\n  }\n  assertNodeSet(target, 'guard', 'target')\n  if (filterIsUnit) {\n    sample({\n      source: filter,\n      clock: source,\n      target: createNode({\n        node: [\n          step.filter({\n            fn: ({guard}) => guard,\n          }),\n          step.compute({\n            fn: ({data}) => data,\n          }),\n        ],\n        child: target,\n        meta,\n        family: {\n          owners: [source, filter, target, ...[].concat(clock ? clock : [])],\n          links: target,\n        },\n        regional: true,\n      }),\n      fn: (guard: any, data: any) => ({guard, data}),\n      greedy,\n      name,\n    })\n  } else {\n    if (!isFunction(filter)) throwError('`filter` should be function or unit')\n    createLinkNode(source, target, {\n      scope: {fn: filter},\n      node: clock\n        ? [\n            step.filter({\n              fn: ({source, clock}, {fn}) => fn(source, clock),\n            }),\n            step.compute({\n              fn: ({source}) => source,\n            }),\n          ]\n        : [step.filter({fn: callStack})],\n      meta,\n    })\n  }\n  return target\n}\n","import {createStore} from './createUnit'\nimport {is} from './is'\nimport {forIn} from './collection'\nimport {getParent} from './getter'\n\nexport function restore(obj: any, defaultState: any, config?: any): any {\n  if (is.store(obj)) {\n    return obj\n  }\n  if (is.unit(obj)) {\n    const domain = getParent(obj)\n    let result\n    if (is.event(obj)) {\n      result = createStore(defaultState, {\n        parent: domain,\n        name: obj.shortName,\n        ɔ: config,\n      }).on(obj, (_, v) => v)\n    }\n    if (is.effect(obj)) {\n      result = createStore(defaultState, {\n        parent: domain,\n        name: obj.shortName,\n        ɔ: config,\n      }).on(obj.done, (_: any, {result}: any) => result)\n    }\n    if (domain) domain.hooks.store(result)\n    return result\n  }\n  const result: Record<string, any> = Array.isArray(obj) ? [] : {}\n  forIn(obj, (value, key) => {\n    result[key] = is.store(value) ? value : createStore(value, {name: key})\n  })\n  return result\n}\n"],"names":["assertNodeSetItem","value","method","valueName","reason","isObject","isFunction","throwError","assertNodeSet","Array","isArray","i","length","withRegion","unit","cb","unitMeta","getGraph","meta","regionStack","parent","template","readTemplate","sidRoot","getParent","createNode","node","from","source","to","target","child","scope","family","familyRaw","type","regional","sources","arrifyNodes","links","owners","seq","reg","item","push","addToReg","result","id","nextNodeID","next","CROSSLINK","getOwners","getLinks","own","getValue","launch","payload","upsert","pageForLaunch","currentPage","stackForLaunch","forkPageForLaunch","forkPage","params","defer","page","getForkPage","pushFirstHeapItem","isRoot","stop","skip","lastStartedState","isWatch","kernelLoop","deleteMin","idx","stack","local","fail","stepn","step","data","BARRIER","barrierID","fullID","priority","barriers","has","add","pushHeap","delete","STACK","REG_A","VALUE","store","STORE","getPageForRef","readRef","getPageRef","current","undefined","FILTER","tryRun","EFFECT","op","unitObjectName","objOrArr","name","comma","key","is","compositeName","fullName","toString","createName","path","composite","shortName","concat","forIn","obj","forEach","list","fn","createEvent","nameOrConfig","maybeConfig","event","args","oldPage","setCurrentPage","create","callCreate","graphite","initUnit","EVENT","find","watch","bind","watchUnit","map","config","mapped","mapName","createComputation","MAP","filter","createEventFiltration","callStack","filterMap","defined","prepend","contramapped","upward","applyParentHook","createStore","defaultState","props","onEvent","off","getSubscribers","set","createSubscription","updateStore","updateFilter","plainState","createStateRef","oldState","updates","createNamedEvent","after","plain","plainStateId","subscribers","Map","stateRef","getState","reachedPage","targetRef","setState","state","nodeMap","reset","units","on","nodeSet","currentSubscription","get","firstState","lastResult","storeState","innerStore","strict","linkNode","getStoreState","before","includes","loader","unshift","eventOrFn","subscription","of","defaultConfig","changed","update","_","a","isStrict","combine","handler","stores","onConfigNesting","injectedData","userConfig","structStoreShape","shapeReady","rawHandler","slice","spreadArgs","storeCombination","createDefer","req","Promise","rs","rj","catch","err","createEffect","instance","getType","onCopy","kind","use","anyway","finally","done","named","status","error","doneData","failData","effectRunner","getHandler","getCurrent","onResolve","onSettled","ok","onReject","then","fx","runner","upd","savedFork","setForkPage","inFlight","x","pending","amount","merge","events","forward","sample","sid","greedy","clock","metadata","processArgsToConfig","atLeastOneFieldExists","sampleConfigFields","field","validateSampleConfig","needToCombine","isUpward","targetTemplate","nativeTemplate","sourceRef","createLinkNode","SAMPLER","callARegStack","SAMPLE","closure","hasSource","sourceState","clockState","callStackAReg","createRefGraph","refsMap","items","Object","values","refGraph","cmd","normalizeValues","assertEach","toposort","rawGraph","ignore","topologicalSortHelper","temp","neighbors","graph","n","visited","Set","reverse","size","processed","ignored","shift","removeItem","flatGraph","traverse","forEachRelatedNode","FORK_COUNTER","observableSymbol","Symbol","observable","DOMAIN","effect","domain","message","Error","assertObject","idCount","nextUnitID","nextStepID","bind2","arg","hasRef","nextBarrierID","barrier","mov","check","compute","run","getConfig","opts","getNestedConfig","ɔ","val","ownerUnit","owner","link","readSidRoot","heap","b","ret","isSameType","v","r","l","queue","ix","first","last","getPriority","bucket","t","newForkPage","newPage","console","joinName","tag","rawConfig","injected","pos","indexOf","splice","removeFromNode","currentNode","targetNode","clearNodeNormalized","deep","isDomainUnit","pop","clearMap","clear","clearNode","ownerSet","history","effects","domains","unsubscribe","forkedNode","normalizeConfig","part","loc","hookType","hooks","rawConfigA","rawConfigB","isDomain","unitId","thru","subscribe","observer","stateFirst","storeRef","ref","clone","stateNew","rawShape","isFresh","isCombine","childRef","defaultShape","sidechain","createHook","trigger","acc","res","hook","launchCase","scopeTargets","start","ctx","reject","parentFork","forkInFlightCounter","defers","launchUnits","launchParams","mapParams","runnerSteps","attached","runnerFn","computedParams","readStateRef","setters","createDomain","onCreateEvent","onCreateEffect","onCreateStore","onCreateDomain","handlers","needToFill","forked","findClone","index","unitName","clones","refs","changedStores","putStoreToChanged","forkOf","fxID","resolve","sidMap","newRef","copyField","origValue","siblings","wrapped","wrapStore","cloneOf","cloneGraph","sourceList","sourceRefsMap","predefinedRefs","templateOwnedRefs","valuesSidList","getOwnPropertyNames","execRef","fillValues","handlerKeys","keys","observableItem","disposer","complete","rawName","filterIsUnit","guard","isScope","storeWatches","storeWatchesRefs","normalizedValues","fillResult","flatGraphUnits","collectWatches","savedForkPage","localUnit","onlyChanges","currentComposite","targets","match","knownCases","cases","matchIsUnit","matchIsFunction","matchIsShape","__","splitterSeq","caseNames","String","lastValues","needBarrier","updaterSteps","storeOrFn","updater","caseName"],"mappings":"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"}