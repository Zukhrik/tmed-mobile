{"ast":null,"code":"import _objectSpread from \"/Users/zuhriddinkamilzanov/Desktop/tMed-mobile/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nimport _slicedToArray from \"/Users/zuhriddinkamilzanov/Desktop/tMed-mobile/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _toConsumableArray from \"/Users/zuhriddinkamilzanov/Desktop/tMed-mobile/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _createForOfIteratorHelper from \"/Users/zuhriddinkamilzanov/Desktop/tMed-mobile/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\n\nfunction e(e, t, r, a) {\n  (V(e) || J(e)) && ('family' in e || 'graphite' in e) || B(\"\".concat(t, \": expect \").concat(r, \" to be a unit (store, event or effect)\").concat(a));\n}\n\nfunction t(t, r, a) {\n  if (Array.isArray(t)) for (var _n = 0; _n < t.length; _n++) {\n    e(t[_n], r, \"\".concat(_n, \" item of \").concat(a), '');\n  } else e(t, r, a, ' or array of units');\n}\n\nfunction r(e, t) {\n  var r = ge(e).meta;\n  Ce = {\n    parent: Ce,\n    value: e,\n    template: r.template || je(),\n    sidRoot: r.sidRoot || Ce && Ce.sidRoot\n  };\n\n  try {\n    return t();\n  } finally {\n    Ce = xe(Ce);\n  }\n}\n\nfunction a() {\n  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      _ref$node = _ref.node,\n      e = _ref$node === void 0 ? [] : _ref$node,\n      t = _ref.from,\n      r = _ref.source,\n      _ref$parent = _ref.parent,\n      a = _ref$parent === void 0 ? t || r : _ref$parent,\n      n = _ref.to,\n      o = _ref.target,\n      _ref$child = _ref.child,\n      s = _ref$child === void 0 ? n || o : _ref$child,\n      _ref$scope = _ref.scope,\n      l = _ref$scope === void 0 ? {} : _ref$scope,\n      _ref$meta = _ref.meta,\n      i = _ref$meta === void 0 ? {} : _ref$meta,\n      _ref$family = _ref.family,\n      f = _ref$family === void 0 ? {\n    type: 'regular'\n  } : _ref$family,\n      c = _ref.regional;\n\n  var u = Fe(a),\n      p = Fe(f.links),\n      d = Fe(f.owners),\n      m = [],\n      h = {};\n\n  for (var _t = 0; _t < e.length; _t++) {\n    var _r = e[_t];\n    _r && (m.push(_r), Re(_r, h));\n  }\n\n  var g = {\n    id: Y(),\n    seq: m,\n    next: Fe(s),\n    meta: i,\n    scope: l,\n    family: {\n      type: f.type || \"crosslink\",\n      links: p,\n      owners: d\n    },\n    reg: h\n  };\n\n  for (var _e2 = 0; _e2 < p.length; _e2++) {\n    ye(p[_e2]).push(g);\n  }\n\n  for (var _e3 = 0; _e3 < d.length; _e3++) {\n    ke(d[_e3]).push(g);\n  }\n\n  for (var _e4 = 0; _e4 < u.length; _e4++) {\n    u[_e4].next.push(g);\n  }\n\n  return c && Ce && Ae(Se(Ce), [g]), g;\n}\n\nfunction n(e, t, r) {\n  var a = Be,\n      n = null,\n      o = He;\n  if (e.target && (t = e.params, r = e.defer, a = 'page' in e ? e.page : a, e.stack && (n = e.stack), o = Ne(e) || o, e = e.target), o && He && o !== He && (He = null), Array.isArray(e)) for (var _r2 = 0; _r2 < e.length; _r2++) {\n    Ee('pure', a, ge(e[_r2]), n, t[_r2], o);\n  } else Ee('pure', a, ge(e), n, t, o);\n  if (r && !Ge) return;\n  var s,\n      l,\n      i,\n      f,\n      c,\n      u,\n      p = {\n    isRoot: Ge,\n    currentPage: Be,\n    forkPage: He,\n    isWatch: Ue\n  };\n  Ge = 0;\n\n  e: for (; f = $e();) {\n    var _f = f,\n        _e5 = _f.idx,\n        _t2 = _f.stack,\n        _r3 = _f.type;\n    i = _t2.node, Be = c = _t2.page, He = Ne(_t2), u = (c || i).reg;\n    var _a = {\n      fail: 0,\n      scope: i.scope\n    };\n    s = l = 0;\n\n    for (var _n2 = _e5; _n2 < i.seq.length && !s; _n2++) {\n      var _o = i.seq[_n2],\n          _f2 = _o.data;\n\n      switch (_o.type) {\n        case \"barrier\":\n          {\n            var _a2 = _f2.barrierID;\n            c && (_a2 = \"\".concat(c.fullID, \"_\").concat(_a2));\n            var _o2 = _f2.priority;\n\n            if (_n2 !== _e5 || _r3 !== _o2) {\n              Te.has(_a2) || (Te.add(_a2), ze(_n2, _t2, _o2, _a2));\n              continue e;\n            }\n\n            Te.delete(_a2);\n            break;\n          }\n\n        case 'mov':\n          {\n            var _e6 = void 0;\n\n            switch (_f2.from) {\n              case \"stack\":\n                _e6 = Se(_t2);\n                break;\n\n              case \"a\":\n              case 'b':\n                _e6 = _t2[_f2.from];\n                break;\n\n              case \"value\":\n                _e6 = _f2.store;\n                break;\n\n              case I:\n                u[_f2.store.id] || (_t2.page = c = Ke(c, _f2.store.id), u = c ? c.reg : i.reg), _e6 = pe(u[_f2.store.id]);\n            }\n\n            switch (_f2.to) {\n              case \"stack\":\n                _t2.value = _e6;\n                break;\n\n              case \"a\":\n              case 'b':\n                _t2[_f2.to] = _e6;\n                break;\n\n              case I:\n                Le(c, i, _f2.target.id).current = _e6;\n            }\n\n            break;\n          }\n\n        case 'check':\n          switch (_f2.type) {\n            case 'defined':\n              l = void 0 === Se(_t2);\n              break;\n\n            case 'changed':\n              l = Se(_t2) === pe(Le(c, i, _f2.store.id));\n          }\n\n          break;\n\n        case \"filter\":\n          l = !Qe(_a, _f2, _t2);\n          break;\n\n        case 'run':\n          if (_n2 !== _e5 || \"effect\" !== _r3) {\n            ze(_n2, _t2, \"effect\");\n            continue e;\n          }\n\n        case 'compute':\n          Ue = 'watch' === i.meta.op, _t2.value = Qe(_a, _f2, _t2), Ue = p.isWatch;\n      }\n\n      s = _a.fail || l;\n    }\n\n    if (!s) for (var _e7 = 0; _e7 < i.next.length; _e7++) {\n      Ee('child', c, i.next[_e7], _t2, Se(_t2), Ne(_t2));\n    }\n  }\n\n  Ge = p.isRoot, Be = p.currentPage, He = Ne(p);\n}\n\nfunction o(e) {\n  var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"combine\";\n  var r = t + '(',\n      a = '',\n      n = 0;\n\n  for (var _t3 in e) {\n    var _o3 = e[_t3];\n    if (null != _o3 && (r += a, r += E(_o3) ? _o3.compositeName.fullName : _o3.toString()), n += 1, 25 === n) break;\n    a = ', ';\n  }\n\n  return r += ')', r;\n}\n\nfunction s(e, t) {\n  var r = l(t, xe(e));\n  if (e.shortName = t, !e.compositeName) return void (e.compositeName = r);\n  var a = e.compositeName;\n  a.path = r.path, a.shortName = r.shortName, a.fullName = r.fullName;\n}\n\nfunction l(e, t) {\n  var r,\n      a,\n      n,\n      o = e;\n  return t ? (n = t.compositeName, 0 === e.length ? (r = n.path, a = n.fullName) : (r = n.path.concat([e]), a = 0 === n.fullName.length ? e : n.fullName + '/' + e)) : (r = 0 === e.length ? [] : [e], a = e), {\n    shortName: o,\n    fullName: a,\n    path: r\n  };\n}\n\nfunction i(e, t) {\n  for (var _r4 in e) {\n    t(e[_r4], _r4);\n  }\n}\n\nfunction f(e, t) {\n  e.forEach(t);\n}\n\nfunction c(e, t) {\n  var r = function r(e) {\n    for (var _len = arguments.length, t = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      t[_key - 1] = arguments[_key];\n    }\n\n    return Be ? function (e, t, r, a) {\n      var n = Be,\n          o = null;\n      if (t) for (o = Be; o && o.template !== t;) {\n        o = xe(o);\n      }\n      Je(o);\n      var s = e.create(r, a);\n      return Je(n), s;\n    }(r, o, e, t) : r.create(e, t);\n  };\n\n  r.graphite = a({\n    meta: ht(\"event\", r, t, e),\n    regional: 1\n  }), r.create = function (e) {\n    return n(He ? He.find(r) : r, e), e;\n  }, r.watch = Z(ut, r), r.map = function (e) {\n    var t, a;\n    V(e) && (t = e, a = e.name, e = e.fn);\n    var n = c(Ye(r, a), t);\n    return yt(r, n, $, e), n;\n  }, r.filter = function (e) {\n    return kt(r, \"filter\", e.fn ? e : e.fn, [le({\n      fn: he\n    })]);\n  }, r.filterMap = function (e) {\n    return kt(r, 'filterMap', e, [se({\n      fn: he\n    }), oe.defined()]);\n  }, r.prepend = function (e) {\n    var t = c('* → ' + r.shortName, {\n      parent: xe(r)\n    }),\n        a = je();\n    return a && ge(t).seq.push(a.upward), yt(t, r, 'prepend', e), mt(r, t), t;\n  };\n  var o = je();\n  return r;\n}\n\nfunction u(e, r) {\n  function o(e, t) {\n    p.off(e), qe(p).set(e, lt(bt(e, p, 'on', 1, t, m)));\n  }\n\n  var s = ue(e),\n      l = ue(e),\n      i = gt('updates'),\n      f = je();\n  s.after = [{\n    type: 'copy',\n    to: l\n  }], f && f.plain.push(s, l);\n  var c = s.id,\n      p = {\n    subscribers: new Map(),\n    updates: i,\n    defaultState: e,\n    stateRef: s,\n    getState: function getState() {\n      var e,\n          t = s;\n\n      if (Be) {\n        var _t4 = Be;\n\n        for (; _t4 && !_t4.reg[c];) {\n          _t4 = xe(_t4);\n        }\n\n        _t4 && (e = _t4);\n      }\n\n      return !e && He && He.reg[c] && (e = He), e && (t = e.reg[c]), pe(t);\n    },\n    setState: function setState(e) {\n      var t;\n      He && (t = He.nodeMap[ge(p).id]), t || (t = p), n({\n        target: t,\n        params: e,\n        defer: 1\n      });\n    },\n    reset: function reset() {\n      for (var _len2 = arguments.length, e = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        e[_key2] = arguments[_key2];\n      }\n\n      for (var _i = 0, _e8 = e; _i < _e8.length; _i++) {\n        var _t5 = _e8[_i];\n        p.on(_t5, function () {\n          return p.defaultState;\n        });\n      }\n\n      return p;\n    },\n    on: function on(e, r) {\n      if (t(e, '.on', 'first argument'), Array.isArray(e)) {\n        var _iterator = _createForOfIteratorHelper(e),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var _t6 = _step.value;\n            o(_t6, r);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      } else o(e, r);\n\n      return p;\n    },\n    off: function off(e) {\n      var t = qe(p).get(e);\n      return t && (t(), qe(p).delete(e)), p;\n    },\n    map: function map(e, t) {\n      var r, a, n;\n      V(e) && (r = e, a = e.name, t = e.firstState, e = e.fn);\n      var o = p.getState(),\n          l = je();\n      l ? n = null : void 0 !== o && (n = e(o, t));\n      var i = u(n, {\n        name: Ye(p, a),\n        config: r,\n        strict: 0\n      }),\n          f = bt(p, i, $, 0, e);\n      return be(i).before = [{\n        type: $,\n        fn: e,\n        from: s\n      }], l && (tt(l.plain, s) || tt(f.seq, l.loader) || f.seq.unshift(l.loader)), i;\n    },\n    watch: function watch(e, t) {\n      if (!t || !E(e)) {\n        var _t7 = ut(p, e),\n            _r5 = je();\n\n        return _r5 ? _r5.watch.push({\n          of: s,\n          fn: e\n        }) : e(p.getState()), _t7;\n      }\n\n      return J(t) || B('second argument should be a function'), e.watch(function (e) {\n        return t(p.getState(), e);\n      });\n    }\n  },\n      d = ht(I, p, r),\n      m = p.defaultConfig.updateFilter;\n  return p.graphite = a({\n    scope: {\n      state: s\n    },\n    node: [oe.defined(), oe.changed({\n      store: l\n    }), m && ne({\n      store: l,\n      to: \"a\"\n    }), m && le({\n      fn: function fn(e, t, _ref2) {\n        var r = _ref2.a;\n        return m(e, r);\n      }\n    }), fe({\n      store: s\n    }), fe({\n      store: l\n    })],\n    child: i,\n    meta: d,\n    regional: 1\n  }), dt && void 0 === e && B(\"current state can't be undefined, use null instead\"), Ae(p, [i]), p;\n}\n\nfunction p() {\n  for (var _len3 = arguments.length, e = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n    e[_key3] = arguments[_key3];\n  }\n\n  var t, r, a;\n  Ze(e[0], function (t, r) {\n    a = t, e = r;\n  });\n  var n,\n      o,\n      s = e[e.length - 1];\n\n  if (J(s) ? (r = e.slice(0, -1), t = s) : r = e, 1 === r.length) {\n    var _e9 = r[0];\n    W(_e9) || (n = _e9, o = 1);\n  }\n\n  return o || (n = r, t && (t = vt(t))), V(n) || B('shape should be an object'), wt(Array.isArray(n), n, a, t);\n}\n\nfunction d() {\n  var e = {};\n  return e.req = new Promise(function (t, r) {\n    e.rs = t, e.rj = r;\n  }), e.req.catch(function () {}), e;\n}\n\nfunction m(e, t) {\n  var r = c(e, t),\n      o = r.defaultConfig.handler || function () {\n    return B(\"no handler used in \".concat(r.getType()));\n  },\n      s = ge(r);\n\n  s.meta.onCopy = ['runner'], s.meta.unit = r.kind = \"effect\", r.use = function (e) {\n    return J(e) || B('.use argument should be a function'), o = e, r;\n  };\n  var l = r.finally = gt('finally'),\n      i = r.done = l.filterMap({\n    named: 'done',\n    fn: function fn(_ref3) {\n      var e = _ref3.status,\n          t = _ref3.params,\n          r = _ref3.result;\n      if ('done' === e) return {\n        params: t,\n        result: r\n      };\n    }\n  }),\n      f = r.fail = l.filterMap({\n    named: 'fail',\n    fn: function fn(_ref4) {\n      var e = _ref4.status,\n          t = _ref4.params,\n          r = _ref4.error;\n      if ('fail' === e) return {\n        params: t,\n        error: r\n      };\n    }\n  }),\n      p = r.doneData = i.map({\n    named: 'doneData',\n    fn: function fn(_ref5) {\n      var e = _ref5.result;\n      return e;\n    }\n  }),\n      m = r.failData = f.map({\n    named: 'failData',\n    fn: function fn(_ref6) {\n      var e = _ref6.error;\n      return e;\n    }\n  }),\n      h = a({\n    scope: {\n      getHandler: r.use.getCurrent = function () {\n        return o;\n      },\n      finally: l\n    },\n    node: [ie({\n      fn: function fn(_ref7, _ref8, n) {\n        var e = _ref7.params,\n            t = _ref7.req;\n        var r = _ref8.finally,\n            a = _ref8.getHandler;\n        var o,\n            s = St({\n          params: e,\n          req: t,\n          ok: 1,\n          anyway: r,\n          stack: n\n        }),\n            l = St({\n          params: e,\n          req: t,\n          ok: 0,\n          anyway: r,\n          stack: n\n        });\n\n        try {\n          o = a()(e);\n        } catch (e) {\n          return void l(e);\n        }\n\n        V(o) && J(o.then) ? o.then(s, l) : s(o);\n      }\n    })],\n    meta: {\n      op: 'fx',\n      fx: 'runner',\n      onCopy: ['finally']\n    }\n  });\n  s.scope.runner = h, s.seq.push(se({\n    fn: function fn(e, t, r) {\n      return xe(r) ? {\n        params: e,\n        req: {\n          rs: function rs(e) {},\n          rj: function rj(e) {}\n        }\n      } : e;\n    }\n  }), ie({\n    fn: function fn(e, _ref9, r) {\n      var t = _ref9.runner;\n      return n({\n        target: t,\n        params: e,\n        defer: 1,\n        forkPage: Ne(r)\n      }), e.params;\n    }\n  })), r.create = function (e) {\n    var t = d(),\n        a = {\n      params: e,\n      req: t\n    };\n\n    if (He) {\n      if (!Ue) {\n        var _e10 = He;\n        t.req.finally(function () {\n          Ve(_e10);\n        }).catch(function () {});\n      }\n\n      n(He.find(r), a);\n    } else n(r, a);\n\n    return t.req;\n  };\n  var g = r.inFlight = u(0, {\n    named: 'inFlight'\n  }).on(r, function (e) {\n    return e + 1;\n  }).on(l, function (e) {\n    return e - 1;\n  }),\n      y = r.pending = g.map({\n    fn: function fn(e) {\n      return e > 0;\n    },\n    named: 'pending'\n  });\n  return Ae(r, [l, i, f, p, m, y, g, h]), r;\n}\n\nfunction h(e) {\n  var _i$seq;\n\n  var t;\n  Ze(e, function (r, a) {\n    t = r, e = a;\n  });\n  var _e11 = e,\n      r = _e11.source,\n      a = _e11.effect,\n      o = _e11.mapParams;\n  o || (o = r ? function (e, t) {\n    return t;\n  } : function (e) {\n    return e;\n  });\n\n  var s,\n      l = m(e, t),\n      i = ge(l).scope.runner,\n      f = function f(_ref10, _ref11, s) {\n    var e = _ref10.params,\n        t = _ref10.req;\n    var r = _ref11.finally,\n        a = _ref11.effect;\n    var l,\n        i = St({\n      params: e,\n      req: t,\n      ok: 0,\n      anyway: r,\n      stack: s\n    });\n\n    try {\n      l = o(e, s.a);\n    } catch (e) {\n      return i(e);\n    }\n\n    n({\n      target: a,\n      params: {\n        params: l,\n        req: {\n          rs: St({\n            params: e,\n            req: t,\n            ok: 1,\n            anyway: r,\n            stack: s\n          }),\n          rj: i\n        }\n      },\n      page: s.page,\n      defer: 1\n    });\n  };\n\n  if (r) {\n    var _e12;\n\n    W(r) ? (_e12 = r, Ae(r, [l])) : (_e12 = p(r), Ae(l, [_e12]));\n\n    var _t8 = ne({\n      from: I,\n      store: be(_e12),\n      to: \"a\"\n    });\n\n    s = [ie({\n      fn: function fn(e) {\n        return e;\n      }\n    }), _t8, se({\n      fn: f\n    })], Re(_t8, i.reg);\n  } else s = [ie({\n    fn: f\n  })];\n\n  return Ae(a, [l]), i.scope.effect = a, i.meta.onCopy.push(\"effect\"), (_i$seq = i.seq).splice.apply(_i$seq, [0, 1].concat(_toConsumableArray(s))), mt(a, l, \"effect\"), l;\n}\n\nfunction g() {\n  for (var _len4 = arguments.length, e = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n    e[_key4] = arguments[_key4];\n  }\n\n  var _et = et(e),\n      _et2 = _slicedToArray(_et, 2),\n      _et2$ = _slicedToArray(_et2[0], 2),\n      t = _et2$[0],\n      r = _et2$[1],\n      a = _et2[1],\n      n = {};\n\n  return i(r, function (e, r) {\n    var o = n[r] = c(r, {\n      parent: xe(t),\n      config: a\n    });\n    t.on(o, e), mt(t, o);\n  }), n;\n}\n\nfunction y(e, t) {\n  var r = new Set(),\n      n = new Set(),\n      o = new Set(),\n      s = new Set(),\n      l = a({\n    family: {\n      type: \"domain\"\n    },\n    regional: 1\n  }),\n      f = {\n    history: {\n      domains: r,\n      stores: n,\n      effects: o,\n      events: s\n    },\n    graphite: l\n  };\n  l.meta = ht(\"domain\", f, t, e);\n\n  var _map = ['onEvent', 'onEffect', 'onStore', 'onDomain'].map(gt),\n      _map2 = _slicedToArray(_map, 4),\n      p = _map2[0],\n      d = _map2[1],\n      h = _map2[2],\n      g = _map2[3];\n\n  f.hooks = {\n    event: p,\n    effect: d,\n    store: h,\n    domain: g\n  }, f.onCreateEvent = xt(p, s, f), f.onCreateEffect = xt(d, o, f), f.onCreateStore = xt(h, n, f), f.onCreateDomain = xt(g, r, f), f.createEvent = f.event = function (e, t) {\n    return p(c(e, {\n      parent: f,\n      config: t\n    }));\n  }, f.createEffect = f.effect = function (e, t) {\n    return d(m(e, {\n      parent: f,\n      config: t\n    }));\n  }, f.createDomain = f.domain = function (e, t) {\n    return y({\n      name: e,\n      parent: f,\n      config: t\n    });\n  }, f.createStore = f.store = function (e, t) {\n    return h(u(e, {\n      parent: f,\n      config: t\n    }));\n  };\n  var k = xe(f);\n  return k && (i(f.hooks, function (e, t) {\n    ct({\n      from: e,\n      to: k.hooks[t]\n    });\n  }), k.hooks.domain(f)), f;\n}\n\nfunction k(e) {\n  K(e);\n  var t = _ in e ? e[_]() : e;\n  t.subscribe || B('expect observable to have .subscribe');\n  var r = c(),\n      a = ee(st, r, void 0);\n  return t.subscribe({\n    next: r,\n    error: a,\n    complete: a\n  }), r;\n}\n\nfunction b(e, r) {\n  var a = c(r || o(e, 'merge'));\n  return t(e, 'merge', 'first argument'), ct({\n    from: e,\n    to: a,\n    meta: {\n      op: 'merge'\n    }\n  }), a;\n}\n\nfunction v() {\n  for (var _len5 = arguments.length, e = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n    e[_key5] = arguments[_key5];\n  }\n\n  var r,\n      n,\n      o,\n      s,\n      _et3 = et(e),\n      _et4 = _slicedToArray(_et3, 2),\n      _et4$ = _slicedToArray(_et4[0], 3),\n      l = _et4$[0],\n      i = _et4$[1],\n      d = _et4$[2],\n      m = _et4[1];\n\n  void 0 === i && V(l) && function (e) {\n    var t = 0;\n    return f(Nt, function (r) {\n      r in e && (null == e[r] && B(\"sample: \".concat(r, \" should be defined\")), t = 1);\n    }), t;\n  }(l) && (i = l.clock, d = l.fn, s = l.greedy, r = l.target, n = l.name, o = l.sid, l = l.source);\n  var h = 1;\n  void 0 === l && (t(i, 'sample', 'clock'), Array.isArray(i) && (i = b(i)), l = i, h = 0), h && !E(l) && (l = p(l)), void 0 === i && (i = l), t(i, 'sample', 'clock'), n = m || n || l.shortName;\n  var g = je(),\n      y = !!r;\n  r || (W(l) && W(i) ? r = u(d ? d(pe(be(l)), pe(be(i))) : pe(be(l)), {\n    name: n,\n    sid: o\n  }) : (r = c(n), g && ge(r).seq.push(g.loader)));\n  var k = y && E(r) && ge(r).meta.nativeTemplate;\n\n  if (W(l)) {\n    var _e13 = be(l);\n\n    Ae(l, [ft(i, r, {\n      scope: {\n        fn: d,\n        targetTemplate: k\n      },\n      node: [g && g.loader, !s && ae({\n        priority: \"sampler\"\n      }), ne({\n        store: _e13,\n        to: d ? \"a\" : \"stack\"\n      }), d && se({\n        fn: me\n      }), g && y && g.upward],\n      meta: {\n        op: \"sample\",\n        sample: I\n      }\n    })]), g && (tt(g.plain, _e13) || tt(g.closure, _e13) || g.closure.push(_e13));\n  } else {\n    var _e14 = ue(0),\n        _t9 = ue(),\n        _n3 = ue();\n\n    g && g.plain.push(_e14, _t9, _n3), a({\n      parent: l,\n      node: [fe({\n        store: _t9\n      }), ne({\n        from: \"value\",\n        store: 1,\n        target: _e14\n      })],\n      family: {\n        owners: [l, r, i],\n        links: r\n      },\n      meta: {\n        op: \"sample\",\n        sample: 'source'\n      },\n      regional: 1\n    }), Ae(l, [ft(i, r, {\n      scope: {\n        fn: d,\n        targetTemplate: k\n      },\n      node: [g && g.loader, fe({\n        store: _n3\n      }), ne({\n        store: _e14\n      }), le({\n        fn: function fn(e) {\n          return e;\n        }\n      }), !s && ae({\n        priority: \"sampler\"\n      }), ne({\n        store: _t9\n      }), ne({\n        store: _n3,\n        to: \"a\"\n      }), d && se({\n        fn: de\n      }), g && y && g.upward],\n      meta: {\n        op: \"sample\",\n        sample: 'clock'\n      }\n    })]);\n  }\n\n  return r;\n}\n\nfunction w() {\n  for (var _len6 = arguments.length, e = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n    e[_key6] = arguments[_key6];\n  }\n\n  var r = {\n    op: 'guard'\n  },\n      n = 'guard',\n      _et5 = et(e),\n      _et6 = _slicedToArray(_et5, 2),\n      _et6$ = _slicedToArray(_et6[0], 2),\n      o = _et6$[0],\n      s = _et6$[1],\n      l = _et6[1];\n\n  l && (r.config = l, l.name && (n = l.name)), s || (s = o, o = s.source);\n  var _s = s,\n      i = _s.filter,\n      f = _s.greedy,\n      u = _s.clock,\n      _s$name = _s.name,\n      d = _s$name === void 0 ? n : _s$name,\n      m = s.target || c(d, r.config),\n      h = E(i),\n      g = 1;\n  return void 0 === o && (t(u, 'guard', 'clock'), Array.isArray(u) && (u = b(u)), o = u, g = 0), g && !E(o) && (o = p(o)), u && (t(u, 'guard', 'clock'), o = v({\n    source: o,\n    clock: u,\n    greedy: f,\n    fn: h ? null : function (e, t) {\n      return {\n        source: e,\n        clock: t\n      };\n    }\n  })), t(m, 'guard', 'target'), h ? v({\n    source: i,\n    clock: o,\n    target: a({\n      node: [le({\n        fn: function fn(_ref12) {\n          var e = _ref12.guard;\n          return e;\n        }\n      }), se({\n        fn: function fn(_ref13) {\n          var e = _ref13.data;\n          return e;\n        }\n      })],\n      child: m,\n      meta: r,\n      family: {\n        owners: [o, i, m].concat(_toConsumableArray([].concat(u || []))),\n        links: m\n      },\n      regional: 1\n    }),\n    fn: function fn(e, t) {\n      return {\n        guard: e,\n        data: t\n      };\n    },\n    greedy: f,\n    name: d\n  }) : (J(i) || B('`filter` should be function or unit'), ft(o, m, {\n    scope: {\n      fn: i\n    },\n    node: u ? [le({\n      fn: function fn(_ref14, _ref15) {\n        var e = _ref14.source,\n            t = _ref14.clock;\n        var r = _ref15.fn;\n        return r(e, t);\n      }\n    }), se({\n      fn: function fn(_ref16) {\n        var e = _ref16.source;\n        return e;\n      }\n    })] : [le({\n      fn: he\n    })],\n    meta: r\n  })), m;\n}\n\nfunction S(e, t, r) {\n  if (W(e)) return e;\n\n  if (E(e)) {\n    var _a3,\n        _n4 = xe(e);\n\n    return T(e) && (_a3 = u(t, {\n      parent: _n4,\n      name: e.shortName,\n      ɔ: r\n    }).on(e, function (e, t) {\n      return t;\n    })), H(e) && (_a3 = u(t, {\n      parent: _n4,\n      name: e.shortName,\n      ɔ: r\n    }).on(e.done, function (e, _ref17) {\n      var t = _ref17.result;\n      return t;\n    })), _n4 && _n4.hooks.store(_a3), _a3;\n  }\n\n  var a = Array.isArray(e) ? [] : {};\n  return i(e, function (e, t) {\n    a[t] = W(e) ? e : u(e, {\n      name: t\n    });\n  }), a;\n}\n\nfunction q() {\n  for (var _len7 = arguments.length, e = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n    e[_key7] = arguments[_key7];\n  }\n\n  var t,\n      _et7 = et(e),\n      _et8 = _slicedToArray(_et7, 2),\n      _et8$ = _slicedToArray(_et8[0], 2),\n      r = _et8$[0],\n      n = _et8$[1],\n      o = _et8[1],\n      s = !n;\n\n  s && (t = r.cases, n = r.match, r = r.source);\n  var l = W(n),\n      f = !E(n) && J(n),\n      u = !l && !f && V(n);\n  t || (t = {}), s || (u || B('match should be an object'), i(n, function (e, r) {\n    t[r] = c(o);\n  }), t.__ = c(o));\n  var p,\n      d = je(),\n      m = new Set([].concat(r, Object.values(t))),\n      h = Object.keys(l || f ? t : n);\n  if (l || f) l && m.add(n), p = [l && ae({\n    priority: 'sampler'\n  }), l && ne({\n    store: be(n),\n    to: 'a'\n  }), le({\n    fn: function fn(e, t, r) {\n      var a = String(l ? r.a : n(e));\n      At(t, tt(h, a) ? a : '__', e, r);\n    }\n  })];else if (u) {\n    var _e15 = ue({});\n\n    _e15.type = 'shape';\n\n    var _t10,\n        _r6 = _e15.before = [],\n        _a4 = [ne({\n      store: _e15,\n      to: \"a\"\n    }), se({\n      fn: function fn(e, _ref18, _ref19) {\n        var t = _ref18.key;\n        var r = _ref19.a;\n        r[t] = e;\n      }\n    })],\n        _o4 = [];\n\n    i(n, function (n, s) {\n      if (E(n)) {\n        _t10 = 1, _o4.push(s), m.add(n);\n\n        var _l = ft(n, [], {\n          node: _a4,\n          scope: {\n            key: s\n          }\n        });\n\n        if (W(n)) {\n          _e15.current[s] = n.getState();\n\n          var _t11 = be(n);\n\n          _r6.push({\n            type: 'field',\n            field: s,\n            from: _t11\n          }), d && (tt(d.plain, _t11) || _l.seq.unshift(d.loader));\n        }\n      }\n    }), _t10 && d && d.plain.push(_e15), p = [_t10 && ae({\n      priority: 'sampler'\n    }), _t10 && ne({\n      store: _e15,\n      to: 'a'\n    }), le({\n      fn: function fn(e, t, r) {\n        for (var _a5 = 0; _a5 < h.length; _a5++) {\n          var _s2 = h[_a5];\n          if (tt(_o4, _s2) ? r.a[_s2] : n[_s2](e)) return void At(t, _s2, e, r);\n        }\n\n        At(t, '__', e, r);\n      }\n    })];\n  } else B('expect match to be unit, function or object');\n  if (a({\n    meta: {\n      onCopy: Object.keys(t),\n      op: 'split'\n    },\n    parent: r,\n    scope: t,\n    node: p,\n    family: {\n      type: 'crosslink',\n      owners: Array.from(m)\n    },\n    regional: 1\n  }), !s) return t;\n}\n\nfunction x(e, _ref20) {\n  var t = _ref20.values;\n  var r = V(e) && e.cloneOf;\n  G(e) || r || B('first argument of hydrate should be domain or scope'), V(t) || B('values property should be an object');\n  var a,\n      o,\n      s = j(t);\n  if (r) a = [], o = [], i(s, function (t, r) {\n    var n = e.sidMap[r];\n    n && (a.push(n), o.push(t), e.changedStores.add(n.meta.forkOf.id));\n  });else {\n    var _t12 = function (_ref21) {\n      var e = _ref21.flatGraphUnits,\n          t = _ref21.values,\n          r = _ref21.collectWatches;\n      var a = [],\n          n = [],\n          o = {},\n          s = new Set(),\n          l = Object.getOwnPropertyNames(t);\n      return f(e, function (e) {\n        var f = e.reg,\n            _e$meta = e.meta,\n            c = _e$meta.op,\n            u = _e$meta.unit,\n            p = _e$meta.sid;\n\n        if (u === I && p && tt(l, p)) {\n          var _r7 = e.scope.state;\n          _r7.current = t[p], s.add(_r7);\n        }\n\n        if (r && 'watch' === c) {\n          var _t13 = e.family.owners[0];\n          _t13.meta.unit === I && (a.push(e), n.push(_t13.scope.state));\n        }\n\n        i(f, function (e, t) {\n          o[t] = e;\n        });\n      }), f(P(N(o)), function (e) {\n        (function (e) {\n          var t = 0;\n          if (e.before && !s.has(e) && f(e.before, function (r) {\n            switch (r.type) {\n              case $:\n                e.current = r.fn(r.from.current);\n                break;\n\n              case 'field':\n                {\n                  var _a6 = r.from;\n                  t || (t = 1, e.current = Array.isArray(e.current) ? _toConsumableArray(e.current) : _objectSpread({}, e.current)), e.current[r.field] = _a6.current;\n                  break;\n                }\n            }\n          }), !e.after) return;\n          var r = e.current;\n          f(e.after, function (e) {\n            var t = e.to;\n\n            switch (e.type) {\n              case 'copy':\n                t.current = r;\n                break;\n\n              case $:\n                t.current = e.fn(r);\n            }\n          });\n        })(o[e]);\n      }), {\n        storeWatches: a,\n        storeWatchesRefs: n\n      };\n    }({\n      flatGraphUnits: R(e),\n      values: s,\n      collectWatches: 1\n    });\n\n    a = _t12.storeWatches, o = _t12.storeWatchesRefs.map(function (_ref22) {\n      var e = _ref22.current;\n      return e;\n    });\n  }\n  n({\n    target: a,\n    params: o,\n    forkPage: r ? e : 0\n  });\n}\n\nfunction N(e) {\n  var t = Object.values(e),\n      r = {};\n  return f(t, function (_ref23) {\n    var e = _ref23.id;\n    r[e] = [];\n  }), f(t, function (_ref24) {\n    var e = _ref24.id,\n        t = _ref24.before,\n        a = _ref24.after;\n    t && f(t, function (t) {\n      r[t.from.id].push(e);\n    }), a && f(a, function (t) {\n      r[e].push(t.to.id);\n    });\n  }), r;\n}\n\nfunction A(_ref25) {\n  var e = _ref25.clones,\n      t = _ref25.changedStores;\n\n  var _ref26 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref26$ignore = _ref26.ignore,\n      r = _ref26$ignore === void 0 ? [] : _ref26$ignore,\n      a = _ref26.onlyChanges;\n\n  var n = {};\n  return f(e, function (_ref27) {\n    var e = _ref27.meta,\n        r = _ref27.scope,\n        o = _ref27.reg;\n    if (e.unit !== I) return;\n    var s = e.sid;\n    s && (!a && !e.isCombine || t.has(e.forkOf.id)) && (n[s] = o[r.state.id].current);\n  }), f(r, function (_ref28) {\n    var e = _ref28.sid;\n    e && delete n[e];\n  }), n;\n}\n\nfunction C(e) {\n  He || B('scopeBind cannot be called outside of forked .watch');\n  var t = He,\n      r = He.find(e);\n  return H(e) ? function (e) {\n    var a = d();\n    n({\n      target: r,\n      params: {\n        params: e,\n        req: a\n      },\n      forkPage: t\n    });\n  } : function (e) {\n    return n({\n      target: r,\n      params: e,\n      forkPage: t\n    }), e;\n  };\n}\n\nfunction j(e) {\n  var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};\n\n  if (e instanceof Map) {\n    var _r8 = {};\n\n    var _iterator2 = _createForOfIteratorHelper(e),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var _step2$value = _slicedToArray(_step2.value, 2),\n            _a7 = _step2$value[0],\n            _n5 = _step2$value[1];\n\n        E(_a7) || B('Map key should be a unit'), t(_a7, _n5), _r8[_a7.sid] = _n5;\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n\n    return _r8;\n  }\n\n  return e;\n}\n\nfunction O(e) {\n  var _ref29 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      t = _ref29.values,\n      r = _ref29.handlers;\n\n  G(e) || B('first argument of fork should be domain');\n  var n = !!t;\n  t = j(t || {}, function (e) {\n    return !W(e) && B('Values map can contain only stores as keys');\n  });\n\n  var o = function (e) {\n    function t(e) {\n      var t = ge(e),\n          a = r.indexOf(t);\n\n      if (-1 === a) {\n        var _r9 = 'unit';\n        e !== t && e.id !== e.shortName && (_r9 = e.shortName), B(\"\".concat(_r9, \" not found in forked scope\"));\n      }\n\n      return p[a];\n    }\n\n    var r = R(e),\n        n = new Map(),\n        o = new Set(),\n        s = se({\n      fn: function fn(e, t, r) {\n        return (!r.node.meta.isCombine || xe(r) && 'combine' !== xe(r).node.meta.op) && o.add(r.node.meta.forkOf.id), e;\n      }\n    }),\n        l = a({\n      scope: {\n        defers: [],\n        inFlight: 0,\n        fxID: 0\n      },\n      node: [se({\n        fn: function fn(e, t, r) {\n          r.parent ? 'finally' === r.parent.node.meta.named ? t.inFlight -= 1 : (t.inFlight += 1, t.fxID += 1) : t.fxID += 1;\n        }\n      }), ae({\n        priority: \"sampler\"\n      }), ie({\n        fn: function fn(e, t) {\n          var r = t.inFlight,\n              a = t.defers,\n              n = t.fxID;\n          r > 0 || 0 === a.length || Promise.resolve().then(function () {\n            t.fxID === n && f(a.splice(0, a.length), function (e) {\n              Ve(e.parentFork), e.rs(e.value);\n            });\n          });\n        }\n      })],\n      meta: {\n        unit: \"forkInFlightCounter\"\n      }\n    }),\n        c = {},\n        u = {},\n        p = r.map(function (e) {\n      var t = e.seq,\n          r = e.next,\n          n = e.meta,\n          o = e.scope,\n          s = a({\n        node: t.map(function (e) {\n          return {\n            id: e.id,\n            type: e.type,\n            data: _objectSpread({}, e.data),\n            hasRef: e.hasRef\n          };\n        }),\n        child: _toConsumableArray(r),\n        meta: _objectSpread({\n          forkOf: e\n        }, n),\n        scope: _objectSpread({}, o)\n      });\n      return s.family = {\n        type: e.family.type,\n        links: _toConsumableArray(ke(e)),\n        owners: _toConsumableArray(ye(e))\n      }, c[e.id] = s, n.sid && (u[n.sid] = s), s;\n    }),\n        d = {};\n    return f(p, function (e) {\n      var r = e.reg,\n          a = e.scope,\n          _e$meta2 = e.meta,\n          o = _e$meta2.onCopy,\n          c = _e$meta2.op,\n          u = _e$meta2.unit;\n\n      switch (i(r, function (e, t) {\n        var a = n.get(e);\n        a || (a = {\n          id: e.id,\n          current: e.current\n        }, n.set(e, a)), d[t] = r[t] = a;\n      }), o && f(o, function (e) {\n        var r = a[e];\n        a[e] = Array.isArray(r) ? r.map(t) : t(r);\n      }), D(e, function (e, r, a) {\n        a[r] = t(e);\n      }), c || u) {\n        case I:\n          e.meta.wrapped = function (e) {\n            return {\n              kind: I,\n              getState: function getState() {\n                return e.reg[e.scope.state.id].current;\n              },\n              updates: {\n                watch: Z(ut, e)\n              },\n              graphite: e,\n              family: e.family\n            };\n          }(e), e.meta.sid && e.seq.push(s);\n          break;\n\n        case M:\n          e.next.push(l);\n          break;\n\n        case 'fx':\n          a.finally.next.push(l);\n      }\n    }), {\n      cloneOf: e,\n      changedStores: o,\n      nodeMap: c,\n      sidMap: u,\n      clones: p,\n      find: t,\n      reg: d,\n      getState: function getState(e) {\n        return t(e).meta.wrapped.getState();\n      },\n      graphite: a({\n        family: {\n          type: \"domain\",\n          links: [l].concat(_toConsumableArray(p))\n        },\n        meta: {\n          unit: 'fork'\n        },\n        scope: {\n          forkInFlightCounter: l\n        }\n      })\n    };\n  }(e);\n\n  if (n && function () {\n    var r = R(e),\n        a = {},\n        n = {},\n        s = new Set(),\n        l = new Set(),\n        c = Object.getOwnPropertyNames(t);\n    f(r, function (_ref30) {\n      var e = _ref30.reg,\n          t = _ref30.meta;\n      var r = t.nativeTemplate;\n      i(e, function (e, t) {\n        a[t] = e, r && l.add(t);\n      });\n    }), f(o.clones, function (e) {\n      var r = e.reg,\n          _e$meta3 = e.meta,\n          a = _e$meta3.unit,\n          l = _e$meta3.sid;\n\n      if (a === I && l && tt(c, l)) {\n        var _a8 = e.scope.state;\n        r[_a8.id].current = t[l], s.add(_a8), o.changedStores.add(e.meta.forkOf.id);\n      }\n\n      i(r, function (e, t) {\n        n[t] = e;\n      });\n    }), f(P(N(a), l), function (e) {\n      (function (e, t) {\n        var r = 0;\n        if (t && t.before && !s.has(e) && f(t.before, function (t) {\n          switch (t.type) {\n            case $:\n              e.current = t.fn(n[t.from.id].current);\n              break;\n\n            case 'field':\n              {\n                var _a9 = n[t.from.id];\n                r || (r = 1, e.current = Array.isArray(e.current) ? _toConsumableArray(e.current) : _objectSpread({}, e.current)), e.current[t.field] = _a9.current;\n                break;\n              }\n          }\n        }), !t || !t.after) return;\n        var a = e.current;\n        f(t.after, function (e) {\n          var t = n[e.to.id];\n\n          switch (e.type) {\n            case 'copy':\n              t.current = a;\n              break;\n\n            case $:\n              t.current = e.fn(a);\n          }\n        });\n      })(n[e], a[e]);\n    });\n  }(), r) {\n    r = j(r, function (e) {\n      return !H(e) && B(\"Handlers map can contain only effects as keys\");\n    });\n\n    var _e16 = Object.keys(r);\n\n    f(o.clones, function (_ref31) {\n      var t = _ref31.scope,\n          a = _ref31.meta;\n      a.sid && tt(_e16, a.sid) && (t.runner.scope.getHandler = function () {\n        return r[a.sid];\n      });\n    });\n  }\n\n  return o;\n}\n\nfunction P(e, t) {\n  function r(e) {\n    s[e] = 1;\n    var t = a[e];\n\n    for (var _e17 = 0; _e17 < t.length; _e17++) {\n      var _a10 = t[_e17];\n      s[_a10] || o[_a10] || r(_a10);\n    }\n\n    s[e] = 0, o[e] = 1, n.push(e);\n  }\n\n  var a = {};\n\n  for (var _t14 in e) {\n    a[_t14] = _toConsumableArray(new Set(e[_t14]));\n  }\n\n  var n = [],\n      o = {},\n      s = {};\n\n  for (var _e18 in a) {\n    o[_e18] || s[_e18] || r(_e18);\n  }\n\n  if (n.reverse(), t && t.size > 0) {\n    (function () {\n      var e,\n          r = [],\n          o = _toConsumableArray(t);\n\n      for (; e = o.shift();) {\n        r.push(e), f(a[e], function (e) {\n          tt(r, e) || tt(o, e) || o.push(e);\n        });\n      }\n\n      f(r, function (e) {\n        rt(n, e);\n      });\n    })();\n  }\n\n  return n;\n}\n\nfunction F(e, _ref32) {\n  var t = _ref32.scope,\n      r = _ref32.params;\n  if (!E(e)) return Promise.reject(Error('first argument should be unit'));\n  var a = d();\n  a.parentFork = He;\n  var o = t.graphite.scope.forkInFlightCounter;\n  o.scope.defers.push(a);\n  var s = [t.find(e)],\n      l = [];\n  return H(e) ? l.push({\n    params: r,\n    req: {\n      rs: function rs(e) {\n        a.value = {\n          status: 'done',\n          value: e\n        };\n      },\n      rj: function rj(e) {\n        a.value = {\n          status: 'fail',\n          value: e\n        };\n      }\n    }\n  }) : l.push(r), s.push(o), l.push(null), n({\n    target: s,\n    params: l,\n    forkPage: t\n  }), a.req;\n}\n\nfunction R(e) {\n  var t = [];\n  return function e(r) {\n    tt(t, r) || (t.push(r), D(r, e));\n  }(ge(e)), t;\n}\n\nfunction D(e, t) {\n  var r = e.meta.unit;\n  'fork' !== r && \"forkInFlightCounter\" !== r && (f(e.next, t), f(ye(e), t), f(ke(e), t));\n}\n\nvar _ = 'undefined' != typeof Symbol && Symbol.observable || '@@observable',\n    I = 'store',\n    M = 'effect',\n    $ = 'map',\n    E = function E(e) {\n  return (J(e) || V(e)) && 'kind' in e;\n};\n\nvar z = function z(e) {\n  return function (t) {\n    return E(t) && t.kind === e;\n  };\n};\n\nvar W = z(I),\n    T = z(\"event\"),\n    H = z(M),\n    G = z(\"domain\");\nvar U = {\n  __proto__: null,\n  unit: E,\n  store: W,\n  event: T,\n  effect: H,\n  domain: G\n};\n\nvar B = function B(e) {\n  throw Error(e);\n},\n    V = function V(e) {\n  return 'object' == typeof e && null !== e;\n},\n    J = function J(e) {\n  return 'function' == typeof e;\n},\n    K = function K(e) {\n  V(e) || J(e) || B('expect first argument be an object');\n};\n\nvar L = function L() {\n  var e = 0;\n  return function () {\n    return (++e).toString(36);\n  };\n};\n\nvar Q = L(),\n    X = L(),\n    Y = L(),\n    Z = function Z(e, t) {\n  return e.bind(null, t);\n},\n    ee = function ee(e, t, r) {\n  return e.bind(null, t, r);\n};\n\nvar te = function te(e, t, r) {\n  return {\n    id: X(),\n    type: e,\n    data: r,\n    hasRef: t\n  };\n};\n\nvar re = 0,\n    ae = function ae(_ref33) {\n  var _ref33$priority = _ref33.priority,\n      e = _ref33$priority === void 0 ? \"barrier\" : _ref33$priority;\n  return te(\"barrier\", 0, {\n    barrierID: ++re,\n    priority: e\n  });\n},\n    ne = function ne(_ref34) {\n  var _ref34$from = _ref34.from,\n      e = _ref34$from === void 0 ? I : _ref34$from,\n      t = _ref34.store,\n      r = _ref34.target,\n      _ref34$to = _ref34.to,\n      a = _ref34$to === void 0 ? r ? I : \"stack\" : _ref34$to;\n  return te('mov', e === I, {\n    from: e,\n    store: t,\n    to: a,\n    target: r\n  });\n},\n    oe = {\n  defined: function defined() {\n    return te('check', 0, {\n      type: 'defined'\n    });\n  },\n  changed: function changed(_ref35) {\n    var e = _ref35.store;\n    return te('check', 1, {\n      type: 'changed',\n      store: e\n    });\n  }\n},\n    se = ee(te, 'compute', 0),\n    le = ee(te, \"filter\", 0),\n    ie = ee(te, 'run', 0),\n    fe = function fe(_ref36) {\n  var e = _ref36.store;\n  return ne({\n    from: \"stack\",\n    target: e\n  });\n};\n\nvar ce = {\n  __proto__: null,\n  barrier: ae,\n  mov: ne,\n  check: oe,\n  compute: se,\n  filter: le,\n  run: ie,\n  update: fe\n};\n\nvar ue = function ue(e) {\n  return {\n    id: X(),\n    current: e\n  };\n},\n    pe = function pe(_ref37) {\n  var e = _ref37.current;\n  return e;\n},\n    de = function de(e, _ref38, _ref39) {\n  var t = _ref38.fn;\n  var r = _ref39.a;\n  return t(e, r);\n},\n    me = function me(e, _ref40, _ref41) {\n  var t = _ref40.fn;\n  var r = _ref41.a;\n  return t(r, e);\n},\n    he = function he(e, _ref42) {\n  var t = _ref42.fn;\n  return t(e);\n},\n    ge = function ge(e) {\n  return e.graphite || e;\n},\n    ye = function ye(e) {\n  return e.family.owners;\n},\n    ke = function ke(e) {\n  return e.family.links;\n},\n    be = function be(e) {\n  return e.stateRef;\n},\n    ve = function ve(e) {\n  return e.config;\n},\n    we = function we(e) {\n  return e.ɔ;\n},\n    Se = function Se(e) {\n  return e.value;\n},\n    qe = function qe(e) {\n  return e.subscribers;\n},\n    xe = function xe(e) {\n  return e.parent;\n},\n    Ne = function Ne(e) {\n  return e.forkPage;\n},\n    Ae = function Ae(e, t) {\n  var r = ge(e);\n\n  for (var _e19 = 0; _e19 < t.length; _e19++) {\n    var _a11 = ge(t[_e19]);\n\n    \"domain\" !== r.family.type && (_a11.family.type = \"crosslink\"), ye(_a11).push(r), ke(r).push(_a11);\n  }\n},\n    Ce = null,\n    je = function je() {\n  return Ce && Ce.template;\n},\n    Oe = function Oe(e) {\n  return e && Ce && Ce.sidRoot && (e = \"\".concat(Ce.sidRoot, \"\\u0254\").concat(e)), e;\n},\n    Pe = function Pe(_ref43) {\n  var e = _ref43.sid,\n      t = _ref43.name,\n      n = _ref43.loc,\n      o = _ref43.method,\n      s = _ref43.fn;\n  return r(a({\n    meta: {\n      sidRoot: Oe(e),\n      name: t,\n      loc: n,\n      method: o\n    }\n  }), s);\n};\n\nvar Fe = function Fe() {\n  var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  var t = [];\n  if (Array.isArray(e)) for (var _r10 = 0; _r10 < e.length; _r10++) {\n    Array.isArray(e[_r10]) ? t.push.apply(t, _toConsumableArray(e[_r10])) : t.push(e[_r10]);\n  } else t.push(e);\n  return t.map(ge);\n};\n\nvar Re = function Re(_ref44, a) {\n  var e = _ref44.hasRef,\n      t = _ref44.type,\n      r = _ref44.data;\n  var n;\n  e && (n = r.store, a[n.id] = n), 'mov' === t && r.to === I && (n = r.target, a[n.id] = n);\n},\n    De = null;\n\nvar _e = function _e(e, t) {\n  if (!e) return t;\n  if (!t) return e;\n  var r,\n      a = e.v.type === t.v.type;\n  return (a && e.v.id > t.v.id || !a && \"sampler\" === e.v.type) && (r = e, e = t, t = r), r = _e(e.r, t), e.r = e.l, e.l = r, e;\n},\n    Ie = [];\n\nvar Me = 0;\n\nfor (; Me < 5;) {\n  Ie.push({\n    first: null,\n    last: null,\n    size: 0\n  }), Me += 1;\n}\n\nvar $e = function $e() {\n  for (var _e20 = 0; _e20 < 5; _e20++) {\n    var _t15 = Ie[_e20];\n\n    if (_t15.size > 0) {\n      if (2 === _e20 || 3 === _e20) {\n        _t15.size -= 1;\n        var _e21 = De.v;\n        return De = _e(De.l, De.r), _e21;\n      }\n\n      1 === _t15.size && (_t15.last = null);\n      var _r11 = _t15.first;\n      return _t15.first = _r11.r, _t15.size -= 1, _r11.v;\n    }\n  }\n},\n    Ee = function Ee(e, t, r, a, n, o) {\n  return ze(0, {\n    a: null,\n    b: null,\n    node: r,\n    parent: a,\n    value: n,\n    page: t,\n    forkPage: o\n  }, e);\n},\n    ze = function ze(e, t, r) {\n  var a = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  var n = We(r),\n      o = Ie[n],\n      s = {\n    v: {\n      idx: e,\n      stack: t,\n      type: r,\n      id: a\n    },\n    l: 0,\n    r: 0\n  };\n  2 === n || 3 === n ? De = _e(De, s) : (0 === o.size ? o.first = s : o.last.r = s, o.last = s), o.size += 1;\n},\n    We = function We(e) {\n  switch (e) {\n    case 'child':\n      return 0;\n\n    case 'pure':\n      return 1;\n\n    case \"barrier\":\n      return 2;\n\n    case \"sampler\":\n      return 3;\n\n    case M:\n      return 4;\n\n    default:\n      return -1;\n  }\n},\n    Te = new Set();\n\nvar He,\n    Ge = 1,\n    Ue = 0,\n    Be = null,\n    Ve = function Ve(e) {\n  He = e;\n},\n    Je = function Je(e) {\n  Be = e;\n};\n\nvar Ke = function Ke(e, t) {\n  if (e) {\n    for (; e && !e.reg[t];) {\n      e = xe(e);\n    }\n\n    if (e) return e;\n  }\n\n  return null;\n},\n    Le = function Le(e, t, r) {\n  return (Ke(e, r) || t).reg[r];\n},\n    Qe = function Qe(e, _ref45, r) {\n  var t = _ref45.fn;\n\n  try {\n    return t(Se(r), e.scope, r);\n  } catch (t) {\n    console.error(t), e.fail = 1;\n  }\n};\n\nvar Xe = function Xe(e, t) {\n  return '' + e.shortName + t;\n},\n    Ye = function Ye(e, t) {\n  return null == t ? Xe(e, ' → *') : t;\n},\n    Ze = function Ze(e, t) {\n  K(e), we(e) && t(ve(e), we(e));\n},\n    et = function et(e) {\n  var t;\n  return Ze(e[0], function (r, a) {\n    t = r, e = a;\n  }), [e, t];\n},\n    tt = function tt(e, t) {\n  return e.includes(t);\n},\n    rt = function rt(e, t) {\n  var r = e.indexOf(t);\n  -1 !== r && e.splice(r, 1);\n};\n\nvar at = function at(e, t) {\n  rt(e.next, t), rt(ye(e), t), rt(ke(e), t);\n},\n    nt = function nt(e, t, r) {\n  var a;\n  e.next.length = 0, e.seq.length = 0, e.scope = null;\n  var n = ke(e);\n\n  for (; a = n.pop();) {\n    at(a, e), (t || r && !e.meta.sample || \"crosslink\" === a.family.type) && nt(a, t, 'on' !== a.meta.op && r);\n  }\n\n  for (n = ye(e); a = n.pop();) {\n    at(a, e), r && \"crosslink\" === a.family.type && nt(a, t, 'on' !== a.meta.op && r);\n  }\n},\n    ot = function ot(e) {\n  return e.clear();\n};\n\nvar st = function st(e) {\n  var _ref46 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      t = _ref46.deep;\n\n  var r = 0;\n  if (e.ownerSet && e.ownerSet.delete(e), W(e)) ot(qe(e));else if (G(e)) {\n    r = 1;\n    var _t16 = e.history;\n    ot(_t16.events), ot(_t16.effects), ot(_t16.stores), ot(_t16.domains);\n  }\n  nt(ge(e), !!t, r);\n},\n    lt = function lt(e) {\n  var t = ee(st, e, void 0);\n  return t.unsubscribe = t, t;\n},\n    ft = function ft(e, t, _ref47) {\n  var r = _ref47.node,\n      n = _ref47.scope,\n      o = _ref47.meta;\n  return a({\n    node: r,\n    parent: e,\n    child: t,\n    scope: n,\n    meta: o,\n    family: {\n      owners: [e, t],\n      links: t\n    },\n    regional: 1\n  });\n},\n    ct = function ct(e) {\n  var r;\n  Ze(e, function (t, a) {\n    r = t, e = a;\n  });\n  var _e22 = e,\n      n = _e22.from,\n      o = _e22.to,\n      _e22$meta = _e22.meta,\n      s = _e22$meta === void 0 ? {\n    op: 'forward'\n  } : _e22$meta;\n  return t(n, 'forward', '\"from\"'), t(o, 'forward', '\"to\"'), r && (s.config = r), lt(a({\n    parent: n,\n    child: o,\n    meta: s,\n    family: {},\n    regional: 1\n  }));\n},\n    ut = function ut(e, t) {\n  if (J(t) || B('.watch argument should be a function'), He) {\n    var _t17 = He.nodeMap[ge(e).id];\n    _t17 && (e = _t17);\n  }\n\n  return lt(a({\n    scope: {\n      fn: t\n    },\n    node: [ie({\n      fn: he\n    })],\n    parent: e,\n    meta: {\n      op: 'watch'\n    },\n    family: {\n      owners: e\n    },\n    regional: 1\n  }));\n};\n\nvar pt = function pt(e, t) {\n  return V(e) && (pt(ve(e), t), null != e.name && (V(e.name) ? pt(e.name, t) : J(e.name) ? t.handler = e.name : t.name = e.name), e.loc && (t.loc = e.loc), (e.sid || null === e.sid) && (t.sid = e.sid), e.handler && (t.handler = e.handler), e.updateFilter && (t.updateFilter = e.updateFilter), xe(e) && (t.parent = xe(e)), 'strict' in e && (t.strict = e.strict), e.named && (t.named = e.named), pt(we(e), t)), t;\n};\n\nvar dt,\n    mt = function mt(e, t) {\n  var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"event\";\n  xe(e) && xe(e).hooks[r](t);\n},\n    ht = function ht(e, t, r, a) {\n  var n = pt({\n    name: a,\n    config: r\n  }, {}),\n      o = \"domain\" === e,\n      s = Q(),\n      _n$parent = n.parent,\n      i = _n$parent === void 0 ? null : _n$parent,\n      _n$sid = n.sid,\n      f = _n$sid === void 0 ? null : _n$sid,\n      _n$strict = n.strict,\n      c = _n$strict === void 0 ? 1 : _n$strict,\n      _n$named = n.named,\n      u = _n$named === void 0 ? null : _n$named,\n      p = u || n.name || (o ? '' : s),\n      d = l(p, i),\n      m = {\n    unit: t.kind = e,\n    name: t.shortName = p,\n    sid: t.sid = Oe(f),\n    named: u,\n    unitId: t.id = s\n  };\n\n  if (t.parent = i, t.compositeName = d, t.defaultConfig = n, t.thru = function (e) {\n    return e(t);\n  }, t.getType = function () {\n    return d.fullName;\n  }, !o) {\n    t.subscribe = function (e) {\n      return K(e), t.watch(J(e) ? e : function (t) {\n        e.next && e.next(t);\n      });\n    }, t[_] = function () {\n      return t;\n    };\n\n    var _e23 = je();\n\n    _e23 && (m.nativeTemplate = _e23);\n  }\n\n  return dt = c, m;\n},\n    gt = function gt(e) {\n  return c({\n    named: e\n  });\n};\n\nvar yt = function yt(e, t, r, a) {\n  return ft(e, t, {\n    scope: {\n      fn: a\n    },\n    node: [se({\n      fn: he\n    })],\n    meta: {\n      op: r\n    }\n  });\n},\n    kt = function kt(e, t, r, a) {\n  var n;\n  V(r) && (n = r, r = r.fn);\n  var o = c(Xe(e, ' →? *'), n);\n  return ft(e, o, {\n    scope: {\n      fn: r\n    },\n    node: a,\n    meta: {\n      op: t\n    }\n  }), o;\n},\n    bt = function bt(e, t, r, a, n, o) {\n  var s = be(t),\n      l = [ne({\n    store: s,\n    to: \"a\"\n  }), se({\n    fn: a ? me : de\n  }), oe.defined(), oe.changed({\n    store: s\n  }), o && le({\n    fn: function fn(e, t, _ref48) {\n      var r = _ref48.a;\n      return o(e, r);\n    }\n  }), fe({\n    store: s\n  })],\n      i = je();\n\n  if (i && (l.unshift(i.loader), l.push(i.upward), W(e))) {\n    var _t18 = be(e);\n\n    tt(i.plain, _t18) || (tt(i.closure, _t18) || i.closure.push(_t18), s.before || (s.before = []), s.before.push({\n      type: 'closure',\n      of: _t18\n    }));\n  }\n\n  return ft(e, t, {\n    scope: {\n      fn: n\n    },\n    node: l,\n    meta: {\n      op: r\n    }\n  });\n},\n    vt = function vt(e) {\n  return function (t) {\n    return e.apply(void 0, _toConsumableArray(t));\n  };\n},\n    wt = function wt(e, t, r, a) {\n  var n = e ? function (e) {\n    return e.slice();\n  } : function (e) {\n    return _objectSpread({}, e);\n  },\n      s = e ? [] : {},\n      l = je(),\n      f = n(s),\n      c = ue(f),\n      p = ue(1);\n  c.type = e ? 'list' : 'shape', l && l.plain.push(c, p);\n  var d = u(f, {\n    name: r || o(t)\n  });\n  ge(d).meta.isCombine = 1;\n  var m = [oe.defined(), ne({\n    store: c,\n    to: \"a\"\n  }), le({\n    fn: function fn(e, _ref49, _ref50) {\n      var t = _ref49.key;\n      var r = _ref50.a;\n      return e !== r[t];\n    }\n  }), ne({\n    store: p,\n    to: 'b'\n  }), se({\n    fn: function fn(e, _ref51, a) {\n      var t = _ref51.clone,\n          r = _ref51.key;\n      a.b && (a.a = t(a.a)), a.a[r] = e;\n    }\n  }), ne({\n    from: \"a\",\n    target: c\n  }), ne({\n    from: \"value\",\n    store: 0,\n    target: p\n  }), ae({\n    priority: \"barrier\"\n  }), ne({\n    from: \"value\",\n    store: 1,\n    target: p\n  }), ne({\n    store: c\n  }), a && se({\n    fn: a\n  }), oe.changed({\n    store: be(d)\n  })],\n      h = c.before = [];\n  return i(t, function (e, t) {\n    if (!W(e)) return void (f[t] = s[t] = e);\n    s[t] = e.defaultState, f[t] = e.getState();\n    var r = ft(e, d, {\n      scope: {\n        key: t,\n        clone: n\n      },\n      node: m,\n      meta: {\n        op: 'combine'\n      }\n    }),\n        a = be(e);\n    h.push({\n      type: 'field',\n      field: t,\n      from: a\n    }), l && (tt(l.plain, a) || r.seq.unshift(l.loader));\n  }), d.defaultShape = t, c.after = [a ? {\n    type: $,\n    to: be(d),\n    fn: a\n  } : {\n    type: 'copy',\n    to: be(d)\n  }], l || (d.defaultState = a ? be(d).current = a(f) : s), d;\n};\n\nvar St = function St(_ref52) {\n  var e = _ref52.params,\n      t = _ref52.req,\n      r = _ref52.ok,\n      a = _ref52.anyway,\n      o = _ref52.stack;\n  return function (s) {\n    return n({\n      target: [a, qt],\n      params: [r ? {\n        status: 'done',\n        params: e,\n        result: s\n      } : {\n        status: 'fail',\n        params: e,\n        error: s\n      }, {\n        fn: r ? t.rs : t.rj,\n        value: s\n      }],\n      defer: 1,\n      page: o.page,\n      forkPage: Ne(o)\n    });\n  };\n},\n    qt = a({\n  node: [ie({\n    fn: function fn(_ref53) {\n      var e = _ref53.fn,\n          t = _ref53.value;\n      e(t);\n    }\n  })],\n  meta: {\n    op: 'fx',\n    fx: 'sidechain'\n  }\n});\n\nvar xt = function xt(e, t, r) {\n  return e.create = function (t) {\n    return n(e, t), t;\n  }, ge(e).seq.push(se({\n    fn: function fn(e, t, r) {\n      return r.forkPage = null, e;\n    }\n  })), e.watch(function (e) {\n    Ae(r, [e]), t.add(e), e.ownerSet || (e.ownerSet = t), xe(e) || (e.parent = r);\n  }), Ae(r, [e]), function (r) {\n    return t.forEach(r), e.watch(r);\n  };\n},\n    Nt = ['source', 'clock', 'target'],\n    At = function At(e, t, r, a) {\n  var o = e[t];\n  o && n({\n    target: o,\n    params: Array.isArray(o) ? o.map(function () {\n      return r;\n    }) : r,\n    defer: 1,\n    stack: a\n  });\n},\n    Ct = \"21.8.12\";\n\nexport { F as allSettled, h as attach, st as clearNode, p as combine, g as createApi, y as createDomain, m as createEffect, c as createEvent, a as createNode, u as createStore, p as createStoreObject, O as fork, ct as forward, k as fromObservable, w as guard, x as hydrate, U as is, n as launch, b as merge, S as restore, v as sample, C as scopeBind, A as serialize, s as setStoreName, q as split, ce as step, Ct as version, Pe as withFactory, r as withRegion };","map":{"version":3,"sources":["effector/is.ts","effector/region.ts","effector/createNode.ts","effector/tag.ts","effector/kernel.ts","effector/naming.ts","effector/collection.ts","effector/createUnit.ts","effector/combine.ts","effector/defer.ts","effector/createEffect.ts","effector/attach.ts","effector/createApi.ts","effector/createDomain.ts","effector/fromObservable.ts","effector/merge.ts","effector/sample.ts","effector/guard.ts","effector/restore.ts","effector/split.ts","effector/fork.ts","effector/observable.ts","effector/validate.ts","effector/throw.ts","effector/id.ts","effector/bind.ts","effector/step.ts","effector/stateRef.ts","effector/caller.ts","effector/getter.ts","effector/own.ts","effector/config.ts","effector/clearNode.ts","effector/subscription.ts","effector/forward.ts","effector/watch.ts"],"names":["isObject","value","isFunction","assertObject","throwError","assertNodeSetItem","method","valueName","reason","assertNodeSet","Array","isArray","i","length","regionStack","readTemplate","template","readSidRoot","sid","sidRoot","withRegion","unit","cb","unitMeta","getGraph","meta","parent","getParent","withFactory","name","loc","fn","createNode","arrifyNodes","list","result","push","map","addToReg","hasRef","type","data","reg","store","id","to","STORE","target","node","from","source","child","scope","family","familyRaw","regional","sources","links","owners","seq","item","nextNodeID","next","getOwners","getLinks","own","getValue","EFFECT","MAP","heap","merge","a","b","ret","isSameType","v","r","l","queue","ix","first","last","size","deleteMin","pushFirstHeapItem","page","forkPage","pushHeap","idx","stack","priority","getPriority","bucket","t","barriers","Set","isRoot","isWatch","currentPage","setForkPage","newForkPage","setCurrentPage","newPage","getPageForRef","getPageRef","launch","payload","upsert","pageForLaunch","stackForLaunch","forkPageForLaunch","params","defer","getForkPage","lastStartedState","stop","skip","kernelLoop","local","fail","stepn","step","barrierID","fullID","has","add","delete","readRef","current","undefined","tryRun","op","err","console","error","joinName","tag","shortName","mapName","unitObjectName","objOrArr","comma","key","is","compositeName","fullName","toString","setStoreName","rawName","createName","currentComposite","path","composite","concat","forIn","obj","includes","removeItem","pos","indexOf","splice","forEach","normalizeConfig","part","config","getConfig","handler","updateFilter","strict","named","getNestedConfig","applyParentHook","hookType","hooks","isStrict","initUnit","kind","rawConfigA","rawConfigB","isDomain","nextUnitID","unitId","defaultConfig","thru","getType","subscribe","observer","watch","upd","observableSymbol","nativeTemplate","createNamedEvent","createEvent","createComputation","createLinkNode","callStack","createEventFiltration","event","mapped","args","oldPage","create","nameOrConfig","maybeConfig","graphite","find","bind","watchUnit","filter","filterMap","defined","prepend","contramapped","upward","createStore","defaultState","props","plainState","createStateRef","oldState","updates","after","plain","plainStateId","subscribers","Map","stateRef","getState","targetRef","reachedPage","setState","state","nodeMap","reset","units","on","nodeSet","onEvent","off","currentSubscription","getSubscribers","get","firstState","lastResult","storeState","innerStore","linkNode","updateStore","getStoreState","before","loader","unshift","eventOrFn","subscription","of","set","createSubscription","changed","update","_","stateFirst","storeRef","callARegStack","callStackAReg","ref","closure","combine","stores","onConfigNesting","injectedData","userConfig","rawHandler","slice","structStoreShape","shapeReady","spreadArgs","storeCombination","clone","stateNew","rawShape","isFresh","isCombine","childRef","field","defaultShape","createDefer","req","Promise","rs","rj","catch","createEffect","instance","onCopy","use","anyway","finally","done","status","doneData","failData","effectRunner","getHandler","getCurrent","onResolve","onSettled","ok","onReject","then","fx","runner","savedFork","inFlight","x","pending","amount","sidechain","attach","injected","effect","mapParams","attached","runnerSteps","runnerFn","computedParams","readStateRef","createApi","setters","metadata","processArgsToConfig","createHook","trigger","acc","res","ownerSet","hook","createDomain","domains","effects","events","history","domain","onCreateEvent","onCreateEffect","onCreateStore","onCreateDomain","forward","fromObservable","observable","observableItem","disposer","bind2","clearNode","complete","sampleConfigFields","atLeastOneFieldExists","sample","clock","greedy","needToCombine","isUpward","targetTemplate","sourceRef","hasSource","sourceState","clockState","guard","filterIsUnit","restore","ɔ","launchCase","scopeTargets","split","targets","match","knownCases","cases","matchIsUnit","matchIsFunction","matchIsShape","__","Object","values","caseNames","keys","splitterSeq","String","lastValues","updaterSteps","needBarrier","storeOrFn","updater","caseName","hydrate","isScope","cloneOf","normalizedValues","normalizeValues","storeWatches","storeWatchesRefs","val","sidMap","changedStores","forkOf","fillResult","fillValues","flatGraphUnits","flatGraph","collectWatches","refsMap","predefinedRefs","valuesSidList","getOwnPropertyNames","owner","createRefGraph","toposort","execRef","cmd","items","refGraph","serialize","clones","ignore","onlyChanges","scopeBind","savedForkPage","localUnit","assertEach","fork","handlers","needToFill","forked","cloneGraph","handlerKeys","sourceList","sourceRefsMap","templateOwnedRefs","rawGraph","graph","visited","temp","topologicalSortHelper","reverse","processed","ignored","shift","neighbors","n","allSettled","start","ctx","reject","Error","parentFork","forkInFlightCounter","defers","launchUnits","launchParams","traverse","forEachRelatedNode","refs","fxID","putStoreToChanged","resolve","newRef","copyField","origValue","findClone","siblings","wrapped","wrapStore","index","unitName","Symbol","message","idCount","nextStepID","arg","nextBarrierID","barrier","mov","check","compute","run","opts","ownerUnit","link","rawConfig","removeFromNode","currentNode","targetNode","clearNodeNormalized","deep","isDomainUnit","pop","clearMap","clear","unsubscribe","forkedNode"],"mappings":"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","sourcesContent":["//eslint-disable-next-line\nexport * as is from './validate'\nimport {throwError} from './throw'\n\nexport const isObject = (value: any) =>\n  typeof value === 'object' && value !== null\nexport const isFunction = (value: any) => typeof value === 'function'\n\nexport const assertObject = (value: any) => {\n  if (!isObject(value) && !isFunction(value))\n    throwError('expect first argument be an object') // or function\n}\n\nfunction assertNodeSetItem(value: any, method: string, valueName: string, reason: string) {\n  if ((!isObject(value) && !isFunction(value)) || (!('family' in value) && !('graphite' in value))) {\n    throwError(`${method}: expect ${valueName} to be a unit (store, event or effect)${reason}`)\n  }\n}\nexport function assertNodeSet(value: any, method: string, valueName: string) {\n  if (Array.isArray(value)) {\n    for (let i = 0; i < value.length; i++) {\n      const item = value[i]\n      assertNodeSetItem(item, method, `${i} item of ${valueName}`, '')\n    }\n  } else {\n    assertNodeSetItem(value, method, valueName, ' or array of units')\n  }\n}\n","import {getValue, getGraph, getParent} from './getter'\nimport {own} from './own'\nimport {createNode} from './createNode'\n\ntype RegionStack = {\n  parent: RegionStack | null\n  value: any\n  template: any\n  sidRoot?: string\n}\n\nexport let regionStack: RegionStack | null = null\n\nexport const readTemplate = () => regionStack && regionStack.template\nexport const readSidRoot = (sid?: string | null) => {\n  if (sid && regionStack && regionStack.sidRoot)\n    sid = `${regionStack.sidRoot}ɔ${sid}`\n  return sid\n}\n\nexport function withRegion(unit: any, cb: () => void) {\n  const unitMeta = getGraph(unit).meta\n  regionStack = {\n    parent: regionStack,\n    value: unit,\n    template: unitMeta.template || readTemplate(),\n    sidRoot: unitMeta.sidRoot || (regionStack && regionStack.sidRoot),\n  }\n  try {\n    return cb()\n  } finally {\n    regionStack = getParent(regionStack)\n  }\n}\n\nexport const withFactory = ({\n  sid,\n  name,\n  loc,\n  method,\n  fn,\n}: {\n  sid: string\n  name?: string\n  loc?: any\n  method?: string\n  fn: () => any\n}) => {\n  const sidNode = createNode({\n    meta: {\n      sidRoot: readSidRoot(sid),\n      name,\n      loc,\n      method,\n    },\n  })\n  return withRegion(sidNode, fn)\n}\n","import {Node, NodeUnit, Cmd, StateRef} from './index.h'\nimport {getGraph, getOwners, getLinks, getValue} from './getter'\nimport {nextNodeID} from './id'\nimport {CROSSLINK, STORE} from './tag'\nimport {regionStack} from './region'\nimport {own} from './own'\n\nconst arrifyNodes = (\n  list: NodeUnit | Array<NodeUnit | NodeUnit[]> = [],\n): Node[] => {\n  const result = []\n  if (Array.isArray(list)) {\n    for (let i = 0; i < list.length; i++) {\n      if (Array.isArray(list[i])) result.push(...(list[i] as any))\n      else result.push(list[i])\n    }\n  } else {\n    result.push(list)\n  }\n  return result.map(getGraph)\n}\nexport const addToReg = (\n  {hasRef, type, data}: any,\n  reg: Record<string, StateRef>,\n) => {\n  let store\n  if (hasRef) {\n    store = data.store\n    reg[store.id] = store\n  }\n  if (type === 'mov' && data.to === STORE) {\n    store = data.target\n    reg[store.id] = store\n  }\n}\nexport function createNode({\n  node = [],\n  from,\n  source,\n  parent = from || source,\n  to,\n  target,\n  child = to || target,\n  scope = {},\n  meta = {},\n  family: familyRaw = {type: 'regular'},\n  regional,\n}: {\n  node?: Array<Cmd | false | void | null>\n  from?: NodeUnit | NodeUnit[]\n  source?: NodeUnit | NodeUnit[]\n  parent?: NodeUnit | NodeUnit[]\n  to?: NodeUnit | NodeUnit[]\n  target?: NodeUnit | NodeUnit[]\n  child?: NodeUnit | NodeUnit[]\n  scope?: {[name: string]: any}\n  meta?: {[name: string]: any}\n  family?: {\n    type?: 'regular' | 'crosslink' | 'domain'\n    links?: NodeUnit | NodeUnit[]\n    owners?: NodeUnit | Array<NodeUnit | NodeUnit[]>\n  }\n  regional?: boolean\n} = {}): Node {\n  const sources = arrifyNodes(parent)\n  const links = arrifyNodes(familyRaw.links)\n  const owners = arrifyNodes(familyRaw.owners)\n  const seq: Cmd[] = []\n  const reg: {[id: string]: StateRef} = {}\n  for (let i = 0; i < node.length; i++) {\n    const item = node[i]\n    if (!item) continue\n    seq.push(item)\n    addToReg(item, reg)\n  }\n  const result: Node = {\n    id: nextNodeID(),\n    seq,\n    next: arrifyNodes(child),\n    meta,\n    scope,\n    family: {\n      type: familyRaw.type || CROSSLINK,\n      links,\n      owners,\n    },\n    reg,\n  }\n  for (let i = 0; i < links.length; i++) {\n    getOwners(links[i]).push(result)\n  }\n  for (let i = 0; i < owners.length; i++) {\n    getLinks(owners[i]).push(result)\n  }\n  for (let i = 0; i < sources.length; i++) {\n    sources[i].next.push(result)\n  }\n  if (regional && regionStack) {\n    own(getValue(regionStack), [result])\n  }\n  return result\n}\n","export const STORE = 'store'\nexport const EVENT = 'event'\nexport const EFFECT = 'effect'\nexport const DOMAIN = 'domain'\nexport const SAMPLER = 'sampler'\nexport const CROSSLINK = 'crosslink'\nexport const MAP = 'map'\nexport const STACK = 'stack'\nexport const BARRIER = 'barrier'\nexport const VALUE = 'value'\nexport const FORK_COUNTER = 'forkInFlightCounter'\nexport const SAMPLE = 'sample'\nexport const FILTER = 'filter'\nexport const REG_A = 'a'\n","import {Node, NodeUnit} from './index.h'\nimport {readRef} from './stateRef'\nimport {getForkPage, getGraph, getParent, getValue} from './getter'\nimport {\n  STORE,\n  EFFECT,\n  SAMPLER,\n  STACK,\n  BARRIER,\n  VALUE,\n  FILTER,\n  REG_A,\n} from './tag'\n\n/** Names of priority groups */\ntype PriorityTag = 'child' | 'pure' | 'barrier' | 'sampler' | 'effect'\n\n/**\n * Position in the current branch,\n * including call stack, priority type\n * and index of next step in the executed Node\n */\ntype Layer = {\n  idx: number\n  stack: Stack\n  type: PriorityTag\n  id: number\n}\n\n/** Call stack */\ntype Stack = {\n  value: any\n  a: any\n  b: any\n  parent: Stack | null\n  node: Node\n  page: {[id: string]: any} | null\n  forkPage?: any\n}\n\n/** Queue as linked list or skew heap */\ntype QueueItem = {\n  /** node value */\n  v: Layer\n  /** left node. always null in queue but used in skew heap */\n  l: QueueItem | null\n  /** right node */\n  r: QueueItem | null\n}\ntype QueueBucket = {\n  first: QueueItem | null\n  last: QueueItem | null\n  size: number\n}\n\n/** Dedicated local metadata */\ntype Local = {\n  fail: boolean\n  scope: {[key: string]: any}\n}\n\nlet heap: QueueItem | null = null\n\nconst merge = (a: QueueItem | null, b: QueueItem | null): QueueItem | null => {\n  if (!a) return b\n  if (!b) return a\n\n  let ret\n  const isSameType = a.v.type === b.v.type\n  if (\n    /**\n     * if both nodes has the same PriorityType\n     * and first node is created after second one\n     */\n    (isSameType && a.v.id > b.v.id) ||\n    /** if first node is \"sampler\" and second node is \"barrier\" */\n    (!isSameType && a.v.type === SAMPLER)\n  ) {\n    ret = a\n    a = b\n    b = ret\n  }\n  ret = merge(a.r, b)\n  a.r = a.l\n  a.l = ret\n\n  return a\n}\n\n/** queue buckets for each PriorityType */\nconst queue: QueueBucket[] = []\nlet ix = 0\nwhile (ix < 5) {\n  /**\n   * although \"sampler\" and \"barrier\" are using heap instead of linked list,\n   * their buckets are still useful: they maintains size of heap queue\n   */\n  queue.push({first: null, last: null, size: 0})\n  ix += 1\n}\n\nconst deleteMin = () => {\n  for (let i = 0; i < 5; i++) {\n    const list = queue[i]\n    if (list.size > 0) {\n      /**\n       * second bucket is for \"barrier\" PriorityType (used in combine)\n       * and third bucket is for \"sampler\" PriorityType (used in sample and guard)\n       */\n      if (i === 2 || i === 3) {\n        list.size -= 1\n        const value = heap!.v\n        heap = merge(heap!.l, heap!.r)\n        return value\n      }\n      if (list.size === 1) {\n        list.last = null\n      }\n      const item = list.first\n      list.first = item!.r\n      list.size -= 1\n      return item!.v\n    }\n  }\n}\nconst pushFirstHeapItem = (\n  type: PriorityTag,\n  page: {[id: string]: any} | null,\n  node: Node,\n  parent: Stack | null,\n  value: any,\n  forkPage: any | void,\n) =>\n  pushHeap(\n    0,\n    {\n      a: null,\n      b: null,\n      node,\n      parent,\n      value,\n      page,\n      forkPage,\n    },\n    type,\n  )\nconst pushHeap = (idx: number, stack: Stack, type: PriorityTag, id = 0) => {\n  const priority = getPriority(type)\n  const bucket: QueueBucket = queue[priority]\n  const item: QueueItem = {\n    v: {\n      idx,\n      stack,\n      type,\n      id,\n    },\n    //@ts-ignore\n    l: 0,\n    //@ts-ignore\n    r: 0,\n  }\n  /**\n   * second bucket is for \"barrier\" PriorityType (used in combine)\n   * and third bucket is for \"sampler\" PriorityType (used in sample and guard)\n   */\n  if (priority === 2 || priority === 3) {\n    heap = merge(heap, item)\n  } else {\n    if (bucket.size === 0) {\n      bucket.first = item\n    } else {\n      bucket.last!.r = item\n    }\n    bucket.last = item\n  }\n  bucket.size += 1\n}\n\nconst getPriority = (t: PriorityTag) => {\n  switch (t) {\n    case 'child':\n      return 0\n    case 'pure':\n      return 1\n    case BARRIER:\n      return 2\n    case SAMPLER:\n      return 3\n    case EFFECT:\n      return 4\n    default:\n      return -1\n  }\n}\n\nconst barriers = new Set()\n\nlet isRoot = true\nexport let isWatch = false\nexport let currentPage: any = null\nexport let forkPage: any\nexport const setForkPage = (newForkPage: any) => {\n  forkPage = newForkPage\n}\nexport const setCurrentPage = (newPage: any) => {\n  currentPage = newPage\n}\n\nconst getPageForRef = (page: any, id: string) => {\n  if (page) {\n    while (page && !page.reg[id]) {\n      page = getParent(page)\n    }\n    if (page) return page\n  }\n  return null\n}\nconst getPageRef = (page: any, node: Node, id: string) => {\n  const pageForRef = getPageForRef(page, id)\n  return (pageForRef ? pageForRef : node).reg[id]\n}\n\nexport function launch(config: {\n  target: NodeUnit | NodeUnit[]\n  params?: any\n  defer?: boolean\n  page?: any\n  forkPage?: any\n  stack?: Stack\n}): void\nexport function launch(unit: NodeUnit, payload?: any, upsert?: boolean): void\nexport function launch(unit: any, payload?: any, upsert?: boolean) {\n  let pageForLaunch = currentPage\n  let stackForLaunch = null\n  let forkPageForLaunch = forkPage\n  if (unit.target) {\n    payload = unit.params\n    upsert = unit.defer\n    pageForLaunch = 'page' in unit ? unit.page : pageForLaunch\n    if (unit[STACK]) stackForLaunch = unit[STACK]\n    forkPageForLaunch = getForkPage(unit) || forkPageForLaunch\n    unit = unit.target\n  }\n  if (forkPageForLaunch && forkPage && forkPageForLaunch !== forkPage) {\n    forkPage = null\n  }\n  if (Array.isArray(unit)) {\n    for (let i = 0; i < unit.length; i++) {\n      pushFirstHeapItem(\n        'pure',\n        pageForLaunch,\n        getGraph(unit[i]),\n        stackForLaunch,\n        payload[i],\n        forkPageForLaunch,\n      )\n    }\n  } else {\n    pushFirstHeapItem(\n      'pure',\n      pageForLaunch,\n      getGraph(unit),\n      stackForLaunch,\n      payload,\n      forkPageForLaunch,\n    )\n  }\n  if (upsert && !isRoot) return\n  /** main execution code */\n  const lastStartedState = {isRoot, currentPage, forkPage, isWatch}\n  isRoot = false\n  let stop\n  let skip\n  let node\n  let value\n  let page\n  let reg\n  kernelLoop: while ((value = deleteMin())) {\n    const {idx, stack, type} = value\n    node = stack.node\n    currentPage = page = stack.page\n    forkPage = getForkPage(stack)\n    reg = (page ? page : node).reg\n    const local: Local = {\n      fail: false,\n      scope: node.scope,\n    }\n    stop = skip = false\n    for (let stepn = idx; stepn < node.seq.length && !stop; stepn++) {\n      const step = node.seq[stepn]\n      const data = step.data\n      switch (step.type) {\n        case BARRIER: {\n          let id = data.barrierID\n          if (page) {\n            id = `${page.fullID}_${id}`\n          }\n          const priority = data.priority\n          if (stepn !== idx || type !== priority) {\n            if (!barriers.has(id)) {\n              barriers.add(id)\n              pushHeap(stepn, stack, priority, id)\n            }\n            continue kernelLoop\n          }\n          barriers.delete(id)\n          break\n        }\n        case 'mov': {\n          let value\n          //prettier-ignore\n          switch (data.from) {\n            case STACK: value = getValue(stack); break\n            case REG_A: /** fall-through case */\n            case 'b':\n              value = stack[data.from]\n              break\n            case VALUE: value = data.store; break\n            case STORE:\n              if (!reg[data.store.id]) {\n                // if (!page.parent) {\n                stack.page = page = getPageForRef(page, data.store.id)\n                reg = page ? page.reg : node.reg\n                // }\n              }\n              // value = getPageRef(page, node, data.store.id).current\n              value = readRef(reg[data.store.id])\n              break\n          }\n          //prettier-ignore\n          switch (data.to) {\n            case STACK: stack.value = value; break\n            case REG_A: /** fall-through case */\n            case 'b':\n              stack[data.to] = value\n              break\n            case STORE:\n              getPageRef(page, node, data.target.id).current = value\n              break\n          }\n          break\n        }\n        case 'check':\n          switch (data.type) {\n            case 'defined':\n              skip = getValue(stack) === undefined\n              break\n            case 'changed':\n              skip =\n                getValue(stack) ===\n                readRef(getPageRef(page, node, data.store.id))\n              break\n          }\n          break\n        case FILTER:\n          /**\n           * handled edge case: if step.fn will throw,\n           * tryRun will return null\n           * thereby forcing that branch to stop\n           */\n          skip = !tryRun(local, data, stack)\n          break\n        case 'run':\n          /** exec 'compute' step when stepn === idx */\n          if (stepn !== idx || type !== EFFECT) {\n            pushHeap(stepn, stack, EFFECT)\n            continue kernelLoop\n          }\n        case 'compute':\n          isWatch = node.meta.op === 'watch'\n          stack.value = tryRun(local, data, stack)\n          isWatch = lastStartedState.isWatch\n          break\n      }\n      stop = local.fail || skip\n    }\n    if (!stop) {\n      for (let stepn = 0; stepn < node.next.length; stepn++) {\n        pushFirstHeapItem(\n          'child',\n          page,\n          node.next[stepn],\n          stack,\n          getValue(stack),\n          getForkPage(stack),\n        )\n      }\n    }\n  }\n  isRoot = lastStartedState.isRoot\n  currentPage = lastStartedState.currentPage\n  forkPage = getForkPage(lastStartedState)\n}\n\n/** try catch for external functions */\nconst tryRun = (local: Local, {fn}: any, stack: Stack) => {\n  try {\n    return fn(getValue(stack), local.scope, stack)\n  } catch (err) {\n    console.error(err)\n    local.fail = true\n  }\n}\n","import {Store, Domain} from './unit.h'\nimport {is} from './is'\nimport {getParent} from './getter'\n\nexport const joinName = (unit: any, tag: string) => '' + unit.shortName + tag\n\nexport const mapName = (unit: any, name?: string) =>\n  name == null ? joinName(unit, ' → *') : name\n\nexport function unitObjectName(objOrArr: any, method: string = 'combine') {\n  let name = method + '('\n  let comma = ''\n  let i = 0\n  //@ts-ignore\n  for (const key in objOrArr) {\n    //@ts-ignore\n    const unit = objOrArr[key]\n    if (unit != null) {\n      name += comma\n      //@ts-ignore\n      name += is.unit(unit) ? unit.compositeName.fullName : unit.toString()\n    }\n    i += 1\n    /* inlined max object names constant */\n    if (i === 25) break\n    comma = ', '\n  }\n  name += ')'\n  return name\n}\n\nexport function setStoreName<State>(store: Store<State>, rawName: string) {\n  const compositeName = createName(rawName, getParent(store))\n  store.shortName = rawName\n  if (!store.compositeName) {\n    store.compositeName = compositeName\n    return\n  }\n  const currentComposite = store.compositeName\n  currentComposite.path = compositeName.path\n  currentComposite.shortName = compositeName.shortName\n  currentComposite.fullName = compositeName.fullName\n}\n\nexport type CompositeName = {\n  shortName: string\n  fullName: string\n  path: string[]\n}\n\nexport function createName(name: string, parent?: Domain): CompositeName {\n  let path: string[]\n  let fullName\n  let composite\n  const shortName = name\n  if (!parent) {\n    if (name.length === 0) {\n      path = []\n    } else {\n      path = [name]\n    }\n    fullName = name\n  } else {\n    composite = parent.compositeName\n    if (name.length === 0) {\n      path = composite.path\n      fullName = composite.fullName\n    } else {\n      path = composite.path.concat([name])\n      if (composite.fullName.length === 0) {\n        fullName = name\n      } else {\n        fullName = '' + composite.fullName + '/' + name\n      }\n    }\n  }\n  return {shortName, fullName, path}\n}\n","export function forIn<T>(\n  obj: Record<string, T>,\n  cb: (value: T, key: string) => void,\n) {\n  for (const key in obj) {\n    cb(obj[key], key)\n  }\n}\n\nexport const includes = (list: any[], item: any) => list.includes(item)\n\nexport const removeItem = (list: any[], item: any) => {\n  const pos = list.indexOf(item)\n  if (pos !== -1) {\n    list.splice(pos, 1)\n  }\n}\n\nexport function forEach<T>(\n  list: T[],\n  fn: (item: T, index: number, list: T[]) => void,\n): void\nexport function forEach<T>(list: Set<T>, fn: (item: T) => void): void\nexport function forEach(list: any, fn: Function) {\n  list.forEach(fn)\n}\n","import {observableSymbol} from './observable'\n\nimport {is, isObject, isFunction, assertObject, assertNodeSet} from './is'\nimport {Store, Event} from './unit.h'\n\nimport {step} from './typedef'\nimport {createStateRef, readRef} from './stateRef'\nimport {nextUnitID} from './id'\nimport {callStackAReg, callARegStack, callStack} from './caller'\nimport {bind} from './bind'\nimport {own} from './own'\nimport {createNode} from './createNode'\nimport {launch, currentPage, forkPage, setCurrentPage} from './kernel'\n\nimport {Subscriber, Config} from './index.h'\nimport {createName, mapName, joinName} from './naming'\nimport {createLinkNode} from './forward'\nimport {watchUnit} from './watch'\nimport {createSubscription} from './subscription'\nimport {readTemplate, readSidRoot} from './region'\nimport {\n  getSubscribers,\n  getConfig,\n  getNestedConfig,\n  getStoreState,\n  getGraph,\n  getParent,\n} from './getter'\nimport {includes} from './collection'\nimport {throwError} from './throw'\nimport {DOMAIN, STORE, EVENT, MAP, FILTER, REG_A} from './tag'\n\nconst normalizeConfig = (part: any, config: any) => {\n  if (isObject(part)) {\n    normalizeConfig(getConfig(part), config)\n    if (part.name != null) {\n      if (isObject(part.name)) normalizeConfig(part.name, config)\n      else if (isFunction(part.name)) config.handler = part.name\n      else config.name = part.name\n    }\n    if (part.loc) config.loc = part.loc\n    if (part.sid || part.sid === null) config.sid = part.sid\n    if (part.handler) config.handler = part.handler\n    if (part.updateFilter) config.updateFilter = part.updateFilter\n    if (getParent(part)) config.parent = getParent(part)\n    if ('strict' in part) config.strict = part.strict\n    if (part.named) config.named = part.named\n    normalizeConfig(getNestedConfig(part), config)\n  }\n  return config\n}\n\nexport const applyParentHook = (\n  source: any,\n  target: any,\n  hookType: 'event' | 'effect' = EVENT,\n) => {\n  if (getParent(source)) getParent(source).hooks[hookType](target)\n}\n\nlet isStrict: boolean\nexport const initUnit = (\n  kind: any,\n  unit: any,\n  rawConfigA: any,\n  rawConfigB?: any,\n) => {\n  const config = normalizeConfig(\n    {\n      name: rawConfigB,\n      config: rawConfigA,\n    },\n    {},\n  )\n  const isDomain = kind === DOMAIN\n  const id = nextUnitID()\n  let {parent = null, sid = null, strict = true, named = null} = config\n  const name = named ? named : config.name || (isDomain ? '' : id)\n  const compositeName = createName(name, parent)\n\n  const meta: Record<string, any> = {\n    unit: unit.kind = kind,\n    name: unit.shortName = name,\n    sid: unit.sid = readSidRoot(sid),\n    named,\n    unitId: unit.id = id,\n  }\n  unit.parent = parent\n  unit.compositeName = compositeName\n  unit.defaultConfig = config\n  unit.thru = (fn: Function) => fn(unit)\n  unit.getType = () => compositeName.fullName\n  if (!isDomain) {\n    unit.subscribe = (observer: Subscriber<any>) => {\n      assertObject(observer)\n      return unit.watch(\n        isFunction(observer)\n          ? observer\n          : (upd: any) => {\n              if (observer.next) {\n                observer.next(upd)\n              }\n            },\n      )\n    }\n    unit[observableSymbol] = () => unit\n    const template = readTemplate()\n    if (template) meta.nativeTemplate = template\n  }\n  isStrict = strict\n  return meta\n}\nexport const createNamedEvent = (named: string) => createEvent({named})\n\nconst createComputation = (from: any, to: any, op: any, fn: Function) =>\n  createLinkNode(from, to, {\n    scope: {fn},\n    node: [step.compute({fn: callStack})],\n    meta: {op},\n  })\n\nconst createEventFiltration = (event: any, op: string, fn: any, node: any) => {\n  let config\n  if (isObject(fn)) {\n    config = fn\n    fn = fn.fn\n  }\n  const mapped = createEvent(joinName(event, ' →? *'), config)\n  createLinkNode(event, mapped, {\n    scope: {fn},\n    node,\n    meta: {op},\n  })\n  return mapped\n}\n\nfunction callCreate(unit: any, template: any, payload: any, args: any[]): any {\n  const oldPage = currentPage\n  let page = null\n  if (template) {\n    page = currentPage\n    while (page && page.template !== template) {\n      page = getParent(page)\n    }\n  }\n  setCurrentPage(page)\n  const result = unit.create(payload, args)\n  setCurrentPage(oldPage)\n  return result\n}\n\nexport function createEvent<Payload = any>(\n  nameOrConfig?: any,\n  maybeConfig?: any,\n): Event<Payload> {\n  const event: any = (payload: Payload, ...args: any[]) => {\n    if (currentPage) {\n      return callCreate(event, template, payload, args)\n    }\n    return event.create(payload, args)\n  }\n  event.graphite = createNode({\n    meta: initUnit(EVENT, event, maybeConfig, nameOrConfig),\n    regional: true,\n  })\n  //eslint-disable-next-line no-unused-vars\n  event.create = (params: any, _: any) => {\n    const target = forkPage ? forkPage.find(event) : event\n    launch(target, params)\n    return params\n  }\n  event.watch = bind(watchUnit, event)\n  event.map = (fn: any) => {\n    let config\n    let name\n    if (isObject(fn)) {\n      config = fn\n      name = fn.name\n      fn = fn.fn\n    }\n    const mapped = createEvent(mapName(event, name), config)\n    createComputation(event, mapped, MAP, fn)\n    return mapped\n  }\n  event.filter = (fn: any) =>\n    createEventFiltration(event, FILTER, fn.fn ? fn : fn.fn, [\n      step.filter({fn: callStack}),\n    ])\n  event.filterMap = (fn: any) =>\n    createEventFiltration(event, 'filterMap', fn, [\n      step.compute({fn: callStack}),\n      step.check.defined(),\n    ])\n  event.prepend = (fn: any) => {\n    const contramapped: Event<any> = createEvent('* → ' + event.shortName, {\n      parent: getParent(event),\n    })\n    const template = readTemplate()\n    if (template) {\n      getGraph(contramapped).seq.push(template.upward)\n    }\n    createComputation(contramapped, event, 'prepend', fn)\n    applyParentHook(event, contramapped)\n    return contramapped\n  }\n  const template = readTemplate()\n  return event\n}\n\nexport function createStore<State>(\n  defaultState: State,\n  props?: Config,\n): Store<State> {\n  const plainState = createStateRef(defaultState)\n  const oldState = createStateRef(defaultState)\n  const updates = createNamedEvent('updates')\n  const template = readTemplate()\n  plainState.after = [{type: 'copy', to: oldState}]\n  if (template) {\n    template.plain.push(plainState, oldState)\n  }\n  const plainStateId = plainState.id\n  const store: any = {\n    subscribers: new Map(),\n    updates,\n    defaultState,\n    stateRef: plainState,\n    getState() {\n      let targetRef = plainState\n      let reachedPage\n      if (currentPage) {\n        let page = currentPage\n        while (page && !page.reg[plainStateId]) {\n          page = getParent(page)\n        }\n        if (page) reachedPage = page\n      }\n      if (!reachedPage && forkPage && forkPage.reg[plainStateId]) {\n        reachedPage = forkPage\n      }\n      if (reachedPage) targetRef = reachedPage.reg[plainStateId]\n      return readRef(targetRef)\n    },\n    setState(state: any) {\n      let target\n      if (forkPage) {\n        target = forkPage.nodeMap[getGraph(store).id]\n      }\n      if (!target) target = store\n      launch({\n        target,\n        params: state,\n        defer: true,\n      })\n    },\n    reset(...units: any[]) {\n      for (const unit of units) store.on(unit, () => store.defaultState)\n      return store\n    },\n    on(nodeSet: any, fn: Function) {\n      assertNodeSet(nodeSet, '.on', 'first argument')\n      if (Array.isArray(nodeSet)) {\n        for (const event of nodeSet) {\n          onEvent(event, fn)\n        }\n      } else {\n        onEvent(nodeSet, fn)\n      }\n      return store\n    },\n    off(unit: any) {\n      const currentSubscription = getSubscribers(store).get(unit)\n      if (currentSubscription) {\n        currentSubscription()\n        getSubscribers(store).delete(unit)\n      }\n      return store\n    },\n    map(fn: any, firstState?: any) {\n      let config\n      let name\n      if (isObject(fn)) {\n        config = fn\n        name = fn.name\n        firstState = fn.firstState\n        fn = fn.fn\n      }\n      let lastResult\n      const storeState = store.getState()\n      const template = readTemplate()\n      if (template) {\n        lastResult = null\n      } else if (storeState !== undefined) {\n        lastResult = fn(storeState, firstState)\n      }\n\n      const innerStore: Store<any> = createStore(lastResult, {\n        name: mapName(store, name),\n        config,\n        strict: false,\n      })\n      const linkNode = updateStore(store, innerStore, MAP, false, fn)\n\n      getStoreState(innerStore).before = [\n        {\n          type: MAP,\n          fn,\n          from: plainState,\n        },\n      ]\n      if (template) {\n        if (!includes(template.plain, plainState)) {\n          if (!includes(linkNode.seq, template.loader)) {\n            linkNode.seq.unshift(template.loader)\n          }\n        }\n      }\n      return innerStore\n    },\n    watch(eventOrFn: any, fn?: Function) {\n      if (!fn || !is.unit(eventOrFn)) {\n        const subscription = watchUnit(store, eventOrFn)\n        const template = readTemplate()\n        if (template) {\n          template.watch.push({\n            of: plainState,\n            fn: eventOrFn,\n          })\n        } else {\n          eventOrFn(store.getState())\n        }\n        return subscription\n      }\n      if (!isFunction(fn)) throwError('second argument should be a function')\n      return eventOrFn.watch((payload: any) => fn(store.getState(), payload))\n    },\n  }\n  function onEvent(event: any, fn: Function) {\n    store.off(event)\n    getSubscribers(store).set(\n      event,\n      createSubscription(\n        updateStore(event, store, 'on', true, fn, updateFilter),\n      ),\n    )\n  }\n  const meta = initUnit(STORE, store, props)\n  const updateFilter = store.defaultConfig.updateFilter\n  store.graphite = createNode({\n    scope: {state: plainState},\n    node: [\n      step.check.defined(),\n      step.check.changed({\n        store: oldState,\n      }),\n      updateFilter && step.mov({store: oldState, to: REG_A}),\n      updateFilter &&\n        step.filter({\n          fn: (update, _, {a}) => updateFilter(update, a),\n        }),\n      step.update({\n        store: plainState,\n      }),\n      step.update({\n        store: oldState,\n      }),\n    ],\n    child: updates,\n    meta,\n    regional: true,\n  })\n  if (isStrict && defaultState === undefined)\n    throwError(\"current state can't be undefined, use null instead\")\n  own(store, [updates])\n  return store\n}\n\nconst updateStore = (\n  from: any,\n  store: Store<any>,\n  op: string,\n  stateFirst: boolean,\n  fn: Function,\n  updateFilter?: Function,\n) => {\n  const storeRef = getStoreState(store)\n  const node = [\n    step.mov({store: storeRef, to: REG_A}),\n    step.compute({\n      fn: stateFirst ? callARegStack : callStackAReg,\n    }),\n    step.check.defined(),\n    step.check.changed({store: storeRef}),\n    updateFilter &&\n      step.filter({\n        fn: (update, _, {a}) => updateFilter(update, a),\n      }),\n    step.update({store: storeRef}),\n  ]\n  const template = readTemplate()\n  if (template) {\n    node.unshift(template.loader)\n    node.push(template.upward)\n    if (is.store(from)) {\n      const ref = getStoreState(from)\n      if (!includes(template.plain, ref)) {\n        //if (!includes(node, template.loader)) {\n        //  node.unshift(template.loader)\n        //}\n        if (!includes(template.closure, ref)) {\n          template.closure.push(ref)\n        }\n        if (!storeRef.before) storeRef.before = []\n        storeRef.before.push({\n          type: 'closure',\n          of: ref,\n        })\n      }\n    } else {\n      //if (!includes(node, template.loader)) {\n      //  node.unshift(template.loader)\n      //}\n    }\n  }\n  return createLinkNode(from, store, {\n    scope: {fn},\n    node,\n    meta: {op},\n  })\n}\n","import {Store} from './unit.h'\nimport {createStore} from './createUnit'\nimport {createStateRef} from './stateRef'\nimport {step} from './typedef'\nimport {onConfigNesting} from './config'\nimport {getGraph, getStoreState} from './getter'\nimport {is, isFunction, isObject} from './is'\nimport {unitObjectName} from './naming'\nimport {createLinkNode} from './forward'\nimport {throwError} from './throw'\nimport {readTemplate} from './region'\nimport {forIn, includes} from './collection'\nimport {BARRIER, MAP, REG_A, VALUE} from './tag'\n\nexport function combine(...args: any[]): Store<any> {\n  let handler\n  let stores\n  let config\n  onConfigNesting(args[0], (injectedData, userConfig) => {\n    config = injectedData\n    args = userConfig\n  })\n  const rawHandler = args[args.length - 1]\n  if (isFunction(rawHandler)) {\n    stores = args.slice(0, -1)\n    handler = rawHandler\n  } else {\n    stores = args\n  }\n\n  let structStoreShape\n  let shapeReady\n  if (stores.length === 1) {\n    const obj = stores[0]\n    /*\n      without edge case combine(Color, (Color) => '~')\n      */\n    if (!is.store(obj)) {\n      /*\n      case combine([R,G,B], ([R,G,B]) => '~')\n      case combine({R,G,B}, ({R,G,B}) => '~')\n\n      edge case combine([Color], ([Color]) => '~')\n      edge case combine({Color}, ({Color}) => '~')\n\n      edge case combine([R,G,B])\n      edge case combine({R,G,B})\n\n      edge case combine([Color])\n      edge case combine({Color})\n      */\n      structStoreShape = obj\n      shapeReady = true\n    }\n  }\n  if (!shapeReady) {\n    /*\n    case combine(R,G,B, (R,G,B) => '~')\n    */\n    structStoreShape = stores\n    /*\n    without edge case combine(R,G,B)\n    without edge case combine(Color)\n    */\n    if (handler) {\n      handler = spreadArgs(handler)\n    }\n  }\n  if (!isObject(structStoreShape)) throwError('shape should be an object')\n  return storeCombination(\n    Array.isArray(structStoreShape),\n    structStoreShape,\n    config,\n    handler,\n  )\n}\n\nconst spreadArgs = (fn: Function) => (list: any[]) => fn(...list)\n\nconst storeCombination = (\n  isArray: boolean,\n  obj: any,\n  config?: string,\n  fn?: (upd: any) => any,\n) => {\n  const clone = isArray ? (list: any) => list.slice() : (obj: any) => ({...obj})\n  const defaultState: any = isArray ? [] : {}\n  const template = readTemplate()\n  const stateNew = clone(defaultState)\n  const rawShape = createStateRef(stateNew)\n  const isFresh = createStateRef(true)\n  rawShape.type = isArray ? 'list' : 'shape'\n  if (template) {\n    template.plain.push(rawShape, isFresh)\n  }\n  const store = createStore(stateNew, {\n    name: config ? config : unitObjectName(obj),\n  })\n  getGraph(store).meta.isCombine = true\n  const node = [\n    step.check.defined(),\n    step.mov({\n      store: rawShape,\n      to: REG_A,\n    }),\n    //prettier-ignore\n    step.filter({\n      fn: (upd, {key}, {a}) => upd !== a[key],\n    }),\n    step.mov({\n      store: isFresh,\n      to: 'b',\n    }),\n    step.compute({\n      fn(upd, {clone, key}, reg) {\n        if (reg.b) {\n          reg.a = clone(reg.a)\n        }\n        reg.a[key] = upd\n      },\n    }),\n    step.mov({\n      from: REG_A,\n      target: rawShape,\n    }),\n    step.mov({\n      from: VALUE,\n      store: false,\n      target: isFresh,\n    }),\n    step.barrier({priority: BARRIER}),\n    step.mov({\n      from: VALUE,\n      store: true,\n      target: isFresh,\n    }),\n    step.mov({store: rawShape}),\n    fn && step.compute({fn}),\n    step.check.changed({\n      store: getStoreState(store),\n    }),\n  ]\n  const before: any[] = (rawShape.before = [])\n  forIn(obj, (child: Store<any> | any, key) => {\n    if (!is.store(child)) {\n      stateNew[key] = defaultState[key] = child\n      return\n    }\n    defaultState[key] = child.defaultState\n    stateNew[key] = child.getState()\n    const linkNode = createLinkNode(child, store, {\n      scope: {key, clone},\n      node,\n      meta: {op: 'combine'},\n    })\n    const childRef = getStoreState(child)\n    before.push({\n      type: 'field',\n      field: key,\n      from: childRef,\n    })\n    if (template) {\n      if (!includes(template.plain, childRef)) {\n        linkNode.seq.unshift(template.loader)\n      }\n    }\n  })\n\n  store.defaultShape = obj\n  rawShape.after = [\n    fn\n      ? {\n          type: MAP,\n          to: getStoreState(store),\n          fn,\n        }\n      : {\n          type: 'copy',\n          to: getStoreState(store),\n        },\n  ]\n  if (!template) {\n    store.defaultState = fn\n      ? (getStoreState(store).current = fn(stateNew))\n      : defaultState\n  }\n  return store\n}\n","export function createDefer(): {\n  rs: (value: any) => any\n  rj: (value: any) => any\n  req: Promise<any>\n} {\n  const result = {} as {\n    rs: (value: any) => any\n    rj: (value: any) => any\n    req: Promise<any>\n  }\n  result.req = new Promise((rs, rj) => {\n    result.rs = rs\n    result.rj = rj\n  })\n  result.req.catch(err => {})\n  return result\n}\n","import {step} from './typedef'\nimport {getForkPage, getGraph, getParent} from './getter'\nimport {own} from './own'\nimport {createNode} from './createNode'\nimport {launch, setForkPage, forkPage, isWatch} from './kernel'\nimport {createNamedEvent, createStore, createEvent} from './createUnit'\nimport {createDefer} from './defer'\nimport {isObject, isFunction} from './is'\nimport {throwError} from './throw'\nimport {EFFECT} from './tag'\n\nexport function createEffect<Payload, Done>(\n  nameOrConfig: any,\n  maybeConfig: any,\n) {\n  const instance: any = createEvent(nameOrConfig, maybeConfig)\n  let handler =\n    instance.defaultConfig.handler ||\n    (() => throwError(`no handler used in ${instance.getType()}`))\n  const node = getGraph(instance)\n  node.meta.onCopy = ['runner']\n  node.meta.unit = instance.kind = EFFECT\n  instance.use = (fn: Function) => {\n    if (!isFunction(fn)) throwError('.use argument should be a function')\n    handler = fn\n    return instance\n  }\n  const anyway = (instance.finally = createNamedEvent('finally'))\n  const done = (instance.done = (anyway as any).filterMap({\n    named: 'done',\n    fn({status, params, result}: any) {\n      if (status === 'done') return {params, result}\n    },\n  }))\n  const fail = (instance.fail = (anyway as any).filterMap({\n    named: 'fail',\n    fn({status, params, error}: any) {\n      if (status === 'fail') return {params, error}\n    },\n  }))\n  const doneData = (instance.doneData = done.map({\n    named: 'doneData',\n    fn: ({result}: any) => result,\n  }))\n  const failData = (instance.failData = fail.map({\n    named: 'failData',\n    fn: ({error}: any) => error,\n  }))\n\n  const effectRunner = createNode({\n    scope: {\n      getHandler: instance.use.getCurrent = () => handler,\n      finally: anyway,\n    },\n    node: [\n      step.run({\n        fn({params, req}, {finally: anyway, getHandler}, stack) {\n          const onResolve = onSettled({\n            params,\n            req,\n            ok: true,\n            anyway,\n            stack,\n          })\n          const onReject = onSettled({\n            params,\n            req,\n            ok: false,\n            anyway,\n            stack,\n          })\n          let result\n          try {\n            result = getHandler()(params)\n          } catch (err) {\n            return void onReject(err)\n          }\n          if (isObject(result) && isFunction(result.then)) {\n            result.then(onResolve, onReject)\n          } else {\n            onResolve(result)\n          }\n        },\n      }),\n    ],\n    meta: {\n      op: 'fx',\n      fx: 'runner',\n      onCopy: ['finally'],\n    },\n  })\n  node.scope.runner = effectRunner\n  node.seq.push(\n    step.compute({\n      fn(params, scope, stack) {\n        // empty stack means that this node was launched directly\n        if (!getParent(stack)) return params\n        return {\n          params,\n          req: {\n            rs(data: any) {},\n            rj(data: any) {},\n          },\n        }\n      },\n    }),\n    step.run({\n      fn(upd, {runner}, stack) {\n        launch({\n          target: runner,\n          params: upd,\n          defer: true,\n          forkPage: getForkPage(stack),\n        })\n        return upd.params\n      },\n    }),\n  )\n  instance.create = (params: Payload) => {\n    const req = createDefer()\n    const payload = {params, req}\n    if (forkPage) {\n      if (!isWatch) {\n        const savedFork = forkPage\n        req.req\n          .finally(() => {\n            setForkPage(savedFork)\n          })\n          .catch(() => {})\n      }\n      launch(forkPage.find(instance), payload)\n    } else {\n      launch(instance, payload)\n    }\n    return req.req\n  }\n\n  const inFlight = (instance.inFlight = createStore(0, {named: 'inFlight'})\n    .on(instance, x => x + 1)\n    .on(anyway, x => x - 1))\n\n  const pending = (instance.pending = inFlight.map({\n    //@ts-ignore\n    fn: amount => amount > 0,\n    named: 'pending',\n  }))\n\n  own(instance, [\n    anyway,\n    done,\n    fail,\n    doneData,\n    failData,\n    pending,\n    inFlight,\n    effectRunner,\n  ])\n  return instance\n}\n\nexport const onSettled = ({\n  params,\n  req,\n  ok,\n  anyway,\n  stack,\n}: {\n  params: any\n  req: {\n    rs(_: any): any\n    rj(_: any): any\n  }\n  ok: boolean\n  anyway: any\n  stack: any\n}) => (data: any) =>\n  launch({\n    target: [anyway, sidechain],\n    params: [\n      ok\n        ? {\n            status: 'done',\n            params,\n            result: data,\n          }\n        : {\n            status: 'fail',\n            params,\n            error: data,\n          },\n      {\n        fn: ok ? req.rs : req.rj,\n        value: data,\n      },\n    ],\n    defer: true,\n    page: stack.page,\n    forkPage: getForkPage(stack),\n  })\n\nexport const sidechain = createNode({\n  node: [\n    step.run({\n      fn({fn, value}) {\n        fn(value)\n      },\n    }),\n  ],\n  meta: {op: 'fx', fx: 'sidechain'},\n})\n","import {combine} from './combine'\nimport {createEffect, onSettled} from './createEffect'\nimport {applyParentHook} from './createUnit'\nimport {onConfigNesting} from './config'\nimport {getGraph, getStoreState} from './getter'\nimport {own} from './own'\nimport {is} from './is'\nimport {step} from './typedef'\nimport {launch} from './kernel'\nimport {addToReg} from './createNode'\nimport {STORE, EFFECT, REG_A} from './tag'\n\nexport function attach(config: any) {\n  let injected\n  onConfigNesting(config, (injectedData, userConfig) => {\n    injected = injectedData\n    config = userConfig\n  })\n  let {source, effect, mapParams} = config\n  if (!mapParams)\n    mapParams = source\n      ? (_: any, source: any) => source\n      : (params: any) => params\n  const attached = createEffect(config, injected)\n  const {runner} = getGraph(attached).scope\n\n  let runnerSteps\n  const runnerFn = (\n    {params, req}: any,\n    {finally: anyway, effect}: any,\n    stack: any,\n  ) => {\n    const rj = onSettled({\n      params,\n      req,\n      ok: false,\n      anyway,\n      stack,\n    })\n    let computedParams\n    try {\n      computedParams = mapParams(params, stack.a)\n    } catch (err) {\n      return rj(err)\n    }\n    launch({\n      target: effect,\n      params: {\n        params: computedParams,\n        req: {\n          rs: onSettled({\n            params,\n            req,\n            ok: true,\n            anyway,\n            stack,\n          }),\n          rj,\n        },\n      },\n      page: stack.page,\n      defer: true,\n    })\n  }\n  if (source) {\n    let state\n    if (is.store(source)) {\n      state = source\n      own(source, [attached])\n    } else {\n      state = combine(source)\n      own(attached, [state])\n    }\n    const readStateRef = step.mov({\n      from: STORE,\n      store: getStoreState(state),\n      to: REG_A,\n    })\n    runnerSteps = [\n      /* let another side-effects run first */\n      step.run({fn: _ => _}),\n      /* read state. assumed it already stable here because of previous step */\n      readStateRef,\n      /* no need for step.run because of first step */\n      step.compute({fn: runnerFn}),\n    ]\n    addToReg(readStateRef, runner.reg)\n  } else {\n    runnerSteps = [step.run({fn: runnerFn})]\n  }\n  own(effect, [attached])\n  runner.scope.effect = effect\n  runner.meta.onCopy.push(EFFECT)\n  runner.seq.splice(0, 1, ...runnerSteps)\n  applyParentHook(effect, attached, EFFECT)\n  return attached\n}\n","import {Store, Event} from './unit.h'\nimport {createEvent, applyParentHook} from './createUnit'\nimport {forIn} from './collection'\nimport {getParent} from './getter'\nimport {processArgsToConfig} from './config'\n\nexport function createApi(...args: [Store<any>, {[key: string]: Function}]) {\n  let [[store, setters], metadata] = processArgsToConfig(args)\n  const result: Record<string, Event<any>> = {}\n  forIn(setters, (fn, key) => {\n    const event = (result[key] = createEvent(key, {\n      parent: getParent(store),\n      config: metadata,\n    }))\n    store.on(event, fn)\n    applyParentHook(store, event)\n  })\n  return result\n}\n","import {Store, Event, Effect, Domain} from './unit.h'\nimport {own} from './own'\nimport {createNode} from './createNode'\nimport {Config, NodeUnit} from './index.h'\nimport {\n  createEvent,\n  createStore,\n  createNamedEvent,\n  initUnit,\n} from './createUnit'\nimport {createEffect} from './createEffect'\nimport {forward} from './forward'\nimport {forIn} from './collection'\nimport {getGraph, getParent} from './getter'\nimport {DOMAIN} from './tag'\nimport {launch} from './kernel'\nimport {step} from './typedef'\n\nconst createHook = (trigger: Event<any>, acc: Set<any>, node: any) => {\n  trigger.create = res => {\n    launch(trigger, res)\n    return res\n  }\n  getGraph(trigger).seq.push(\n    step.compute({\n      fn(upd, _, stack) {\n        stack.forkPage = null\n        return upd\n      },\n    }),\n  )\n  trigger.watch(data => {\n    own(node, [data])\n    acc.add(data)\n    if (!data.ownerSet) data.ownerSet = acc\n    if (!getParent(data)) data.parent = node\n  })\n  own(node, [trigger])\n  return (hook: (data: any) => any) => {\n    acc.forEach(hook)\n    return trigger.watch(hook)\n  }\n}\n\nexport function createDomain(nameOrConfig: any, maybeConfig?: any): Domain {\n  const domains: Set<Domain> = new Set()\n  const stores: Set<Store<any>> = new Set()\n  const effects: Set<Effect<any, any, any>> = new Set()\n  const events: Set<Event<any>> = new Set()\n\n  const node = createNode({\n    family: {type: DOMAIN},\n    regional: true,\n  })\n\n  const result: any = {\n    history: {\n      domains,\n      stores,\n      effects,\n      events,\n    },\n    graphite: node,\n  }\n\n  node.meta = initUnit(DOMAIN, result, maybeConfig, nameOrConfig)\n  const [event, effect, store, domain] = [\n    'onEvent',\n    'onEffect',\n    'onStore',\n    'onDomain',\n  ].map(createNamedEvent)\n\n  result.hooks = {\n    event,\n    effect,\n    store,\n    domain,\n  }\n  result.onCreateEvent = createHook(event, events, result)\n  result.onCreateEffect = createHook(effect, effects, result)\n  result.onCreateStore = createHook(store, stores, result)\n  result.onCreateDomain = createHook(domain, domains, result)\n\n  result.createEvent = result.event = (nameOrConfig: any, config?: Config) =>\n    event(\n      createEvent(nameOrConfig, {\n        parent: result,\n        config,\n      }),\n    )\n  result.createEffect = result.effect = (nameOrConfig: any, config?: Config) =>\n    effect(\n      createEffect(nameOrConfig, {\n        parent: result,\n        config,\n      }),\n    )\n  result.createDomain = result.domain = (nameOrConfig: any, config?: Config) =>\n    createDomain({\n      name: nameOrConfig,\n      parent: result,\n      config,\n    })\n  result.createStore = result.store = (state: any, config?: Config) =>\n    store(\n      createStore(state, {\n        parent: result,\n        config,\n      }),\n    )\n  const parent = getParent(result)\n  if (parent) {\n    forIn(result.hooks, (from: NodeUnit, key) => {\n      forward({from, to: parent.hooks[key]})\n    })\n    parent.hooks.domain(result)\n  }\n  return result\n}\n","import {observableSymbol} from './observable'\nimport {Event} from './unit.h'\nimport {clearNode} from './clearNode'\nimport {createEvent} from './createUnit'\nimport {bind2} from './bind'\nimport {assertObject} from './is'\nimport {throwError} from './throw'\n\nexport function fromObservable<T>(observable: any): Event<T> {\n  assertObject(observable)\n  const observableItem =\n    observableSymbol in observable ? observable[observableSymbol]() : observable\n  if (!observableItem.subscribe)\n    throwError('expect observable to have .subscribe')\n  const event = createEvent<T>()\n  const disposer = bind2(clearNode, event, undefined)\n  observableItem.subscribe({\n    next: event,\n    error: disposer,\n    complete: disposer,\n  })\n  return event\n}\n","import {Store, Event, Effect} from './unit.h'\nimport {createEvent} from './createUnit'\nimport {forward} from './forward'\nimport {unitObjectName} from './naming'\nimport {assertNodeSet} from './is'\n\nexport function merge<T>(\n  events: Array<Event<T> | Store<T> | Effect<T, any, any>>,\n  config?: object,\n): Event<T> {\n  const result = createEvent(config || unitObjectName(events, 'merge'))\n  assertNodeSet(events, 'merge', 'first argument')\n  forward({\n    from: events,\n    to: result,\n    meta: {op: 'merge'},\n  })\n  return result\n}\n","import {combine} from './combine'\nimport {step} from './typedef'\nimport {createStateRef, readRef} from './stateRef'\nimport {callStackAReg, callARegStack} from './caller'\nimport {processArgsToConfig} from './config'\nimport {getStoreState, getGraph} from './getter'\nimport {own} from './own'\nimport {assertNodeSet, is, isObject} from './is'\nimport {createStore} from './createUnit'\nimport {createEvent} from './createUnit'\nimport {createLinkNode} from './forward'\nimport {createNode} from './createNode'\nimport {readTemplate} from './region'\nimport {throwError} from './throw'\nimport {includes, forEach} from './collection'\nimport {REG_A, SAMPLE, SAMPLER, STACK, STORE, VALUE} from './tag'\nimport {merge} from './merge'\n\nconst sampleConfigFields = ['source', 'clock', 'target']\n\nfunction validateSampleConfig(config: any) {\n  let atLeastOneFieldExists = false\n  forEach(sampleConfigFields, field => {\n    if (field in config) {\n      if (config[field] == null) {\n        throwError(`sample: ${field} should be defined`)\n      }\n      atLeastOneFieldExists = true\n    }\n  })\n  return atLeastOneFieldExists\n}\n\nexport function sample(...args: any): any {\n  let target\n  let name\n  let [[source, clock, fn], metadata] = processArgsToConfig(args)\n  let sid\n  let greedy\n  //config case\n  if (clock === undefined && isObject(source) && validateSampleConfig(source)) {\n    clock = source.clock\n    fn = source.fn\n    greedy = source.greedy\n    //optional target & name accepted only from config\n    target = source.target\n    name = source.name\n    sid = source.sid\n    source = source.source\n  }\n  let needToCombine = true\n  if (source === undefined) {\n    assertNodeSet(clock, 'sample', 'clock')\n    if (Array.isArray(clock)) {\n      clock = merge(clock)\n    }\n    source = clock\n    needToCombine = false\n  }\n  if (needToCombine && !is.unit(source)) {\n    source = combine(source)\n  }\n  if (clock === undefined) {\n    //still undefined!\n    clock = source\n  }\n  assertNodeSet(clock, 'sample', 'clock')\n  name = metadata || name || source.shortName\n  const template = readTemplate()\n  const isUpward = !!target\n  if (!target) {\n    if (is.store(source) && is.store(clock)) {\n      const initialState = fn\n        ? fn(readRef(getStoreState(source)), readRef(getStoreState(clock)))\n        : readRef(getStoreState(source))\n      target = createStore(initialState, {name, sid})\n    } else {\n      target = createEvent(name)\n      if (template) {\n        getGraph(target).seq.push(template.loader)\n      }\n    }\n  }\n  const targetTemplate =\n    isUpward && is.unit(target) && getGraph(target).meta.nativeTemplate\n  if (is.store(source)) {\n    const sourceRef = getStoreState(source)\n    own(source, [\n      createLinkNode(clock, target, {\n        scope: {fn, targetTemplate},\n        node: [\n          template && template.loader,\n          //@ts-ignore\n          !greedy && step.barrier({priority: SAMPLER}),\n          step.mov({\n            store: sourceRef,\n            to: fn ? REG_A : STACK,\n          }),\n          fn && step.compute({fn: callARegStack}),\n          template && isUpward && template.upward,\n        ],\n        meta: {op: SAMPLE, sample: STORE},\n      }),\n    ])\n    if (template) {\n      if (\n        !includes(template.plain, sourceRef) &&\n        !includes(template.closure, sourceRef)\n      ) {\n        template.closure.push(sourceRef)\n      }\n    }\n  } else {\n    const hasSource = createStateRef(false)\n    const sourceState = createStateRef()\n    const clockState = createStateRef()\n    if (template) {\n      template.plain.push(hasSource, sourceState, clockState)\n    }\n    createNode({\n      parent: source,\n      node: [\n        step.update({store: sourceState}),\n        step.mov({\n          from: VALUE,\n          store: true,\n          target: hasSource,\n        }),\n      ],\n      family: {\n        owners: [source, target, clock],\n        links: target,\n      },\n      meta: {op: SAMPLE, sample: 'source'},\n      regional: true,\n    })\n    own(source, [\n      createLinkNode(clock, target, {\n        scope: {\n          fn,\n          targetTemplate,\n        },\n        node: [\n          template && template.loader,\n          step.update({store: clockState}),\n          step.mov({store: hasSource}),\n          step.filter({fn: hasSource => hasSource}),\n          //@ts-ignore\n          !greedy && step.barrier({priority: SAMPLER}),\n          step.mov({store: sourceState}),\n          step.mov({\n            store: clockState,\n            to: REG_A,\n          }),\n          fn && step.compute({fn: callStackAReg}),\n          template && isUpward && template.upward,\n        ],\n        meta: {op: SAMPLE, sample: 'clock'},\n      }),\n    ])\n  }\n  return target\n}\n","import {processArgsToConfig} from './config'\nimport {createLinkNode} from './forward'\nimport {sample} from './sample'\nimport {createEvent} from './createUnit'\nimport {combine} from './combine'\nimport {step} from './typedef'\nimport {callStack} from './caller'\nimport {assertNodeSet, is, isFunction} from './is'\nimport {createNode} from './createNode'\nimport {throwError} from './throw'\nimport {merge} from './merge'\n\nexport function guard(...args: any[]) {\n  const meta: Record<string, any> = {op: 'guard'}\n  let rawName = 'guard'\n  let [[source, config], metadata] = processArgsToConfig(args)\n  if (metadata) {\n    meta.config = metadata\n    if (metadata.name) rawName = metadata.name\n  }\n  if (!config) {\n    config = source\n    source = config.source\n  }\n  let {filter, greedy, clock, name = rawName} = config\n  const target = config.target || createEvent(name, meta.config)\n  const filterIsUnit = is.unit(filter)\n  let needToCombine = true\n  if (source === undefined) {\n    assertNodeSet(clock, 'guard', 'clock')\n    if (Array.isArray(clock)) {\n      clock = merge(clock)\n    }\n    source = clock\n    needToCombine = false\n  }\n  if (needToCombine && !is.unit(source)) source = combine(source)\n  if (clock) {\n    assertNodeSet(clock, 'guard', 'clock')\n    source = sample({\n      source,\n      clock,\n      greedy,\n      fn: filterIsUnit ? null : (source: any, clock: any) => ({source, clock}),\n    })\n  }\n  assertNodeSet(target, 'guard', 'target')\n  if (filterIsUnit) {\n    sample({\n      source: filter,\n      clock: source,\n      target: createNode({\n        node: [\n          step.filter({\n            fn: ({guard}) => guard,\n          }),\n          step.compute({\n            fn: ({data}) => data,\n          }),\n        ],\n        child: target,\n        meta,\n        family: {\n          owners: [source, filter, target, ...[].concat(clock ? clock : [])],\n          links: target,\n        },\n        regional: true,\n      }),\n      fn: (guard: any, data: any) => ({guard, data}),\n      greedy,\n      name,\n    })\n  } else {\n    if (!isFunction(filter)) throwError('`filter` should be function or unit')\n    createLinkNode(source, target, {\n      scope: {fn: filter},\n      node: clock\n        ? [\n            step.filter({\n              fn: ({source, clock}, {fn}) => fn(source, clock),\n            }),\n            step.compute({\n              fn: ({source}) => source,\n            }),\n          ]\n        : [step.filter({fn: callStack})],\n      meta,\n    })\n  }\n  return target\n}\n","import {createStore} from './createUnit'\nimport {is} from './is'\nimport {forIn} from './collection'\nimport {getParent} from './getter'\n\nexport function restore(obj: any, defaultState: any, config?: any): any {\n  if (is.store(obj)) {\n    return obj\n  }\n  if (is.unit(obj)) {\n    const domain = getParent(obj)\n    let result\n    if (is.event(obj)) {\n      result = createStore(defaultState, {\n        parent: domain,\n        name: obj.shortName,\n        ɔ: config,\n      }).on(obj, (_, v) => v)\n    }\n    if (is.effect(obj)) {\n      result = createStore(defaultState, {\n        parent: domain,\n        name: obj.shortName,\n        ɔ: config,\n      }).on(obj.done, (_: any, {result}: any) => result)\n    }\n    if (domain) domain.hooks.store(result)\n    return result\n  }\n  const result: Record<string, any> = Array.isArray(obj) ? [] : {}\n  forIn(obj, (value, key) => {\n    result[key] = is.store(value) ? value : createStore(value, {name: key})\n  })\n  return result\n}\n","import {Event} from './unit.h'\nimport {NodeUnit, Cmd} from './index.h'\nimport {is, isFunction, isObject} from './is'\nimport {forIn, includes} from './collection'\nimport {createStateRef} from './stateRef'\nimport {readTemplate} from './region'\nimport {createLinkNode} from './forward'\nimport {processArgsToConfig} from './config'\nimport {step} from './typedef'\nimport {createNode} from './createNode'\nimport {launch} from './kernel'\nimport {getStoreState} from './getter'\nimport {REG_A} from './tag'\nimport {throwError} from './throw'\nimport {createEvent} from './createUnit'\n\nconst launchCase = (\n  scopeTargets: Record<string, NodeUnit>,\n  field: string,\n  data: any,\n  stack: any,\n) => {\n  const target = scopeTargets[field]\n  if (target) {\n    launch({\n      target,\n      params: Array.isArray(target) ? target.map(() => data) : data,\n      defer: true,\n      stack,\n    })\n  }\n}\n\nexport function split(...args: any[]): any {\n  let targets: Record<string, Event<any> | NodeUnit>\n  let [[source, match], metadata] = processArgsToConfig(args)\n  const knownCases = !match\n  if (knownCases) {\n    targets = source.cases\n    match = source.match\n    source = source.source\n  }\n  const matchIsUnit = is.store(match)\n  const matchIsFunction = !is.unit(match) && isFunction(match)\n  const matchIsShape = !matchIsUnit && !matchIsFunction && isObject(match)\n  if (!targets!) targets = {}\n  if (!knownCases) {\n    if (!matchIsShape) throwError('match should be an object')\n    forIn(match, (_, key) => {\n      //@ts-ignore\n      targets[key] = createEvent(metadata)\n    })\n    targets.__ = createEvent(metadata)\n  }\n  //@ts-ignore\n  const template = readTemplate()\n  const owners = new Set(\n    ([] as NodeUnit[]).concat(source, Object.values(targets)),\n  )\n  const caseNames = Object.keys(\n    matchIsUnit || matchIsFunction ? targets : match,\n  )\n  let splitterSeq: Array<Cmd | false>\n  if (matchIsUnit || matchIsFunction) {\n    if (matchIsUnit) owners.add(match)\n    splitterSeq = [\n      matchIsUnit && step.barrier({priority: 'sampler'}),\n      matchIsUnit &&\n        step.mov({\n          store: getStoreState(match),\n          to: 'a',\n        }),\n      step.filter({\n        fn(data, scopeTargets, stack) {\n          const value = String(matchIsUnit ? stack.a : match(data))\n          launchCase(\n            scopeTargets,\n            includes(caseNames, value) ? value : '__',\n            data,\n            stack,\n          )\n        },\n      }),\n    ]\n  } else if (matchIsShape) {\n    const lastValues = createStateRef({})\n    lastValues.type = 'shape'\n    const before: any[] = (lastValues.before = [])\n    const updaterSteps = [\n      step.mov({\n        store: lastValues,\n        to: REG_A,\n      }),\n      step.compute({\n        fn(upd, {key}, {a}) {\n          a[key] = upd\n        },\n      }),\n    ]\n    const units = [] as string[]\n    let needBarrier: boolean\n    forIn(match, (storeOrFn: any, key) => {\n      if (is.unit(storeOrFn)) {\n        needBarrier = true\n        units.push(key)\n        owners.add(storeOrFn)\n        const updater = createLinkNode(storeOrFn, [], {\n          node: updaterSteps,\n          scope: {key},\n        })\n        if (is.store(storeOrFn)) {\n          lastValues.current[key] = storeOrFn.getState()\n          const storeRef = getStoreState(storeOrFn)\n          before.push({\n            type: 'field',\n            field: key,\n            from: storeRef,\n          })\n          if (template) {\n            if (!includes(template.plain, storeRef)) {\n              updater.seq.unshift(template.loader)\n            }\n          }\n        }\n      }\n    })\n    if (needBarrier! && template) {\n      template.plain.push(lastValues)\n    }\n    splitterSeq = [\n      needBarrier! && step.barrier({priority: 'sampler'}),\n      needBarrier! &&\n        step.mov({\n          store: lastValues,\n          to: 'a',\n        }),\n      step.filter({\n        fn(data, scopeTargets, stack) {\n          for (let i = 0; i < caseNames.length; i++) {\n            const caseName = caseNames[i]\n            const caseValue = includes(units, caseName)\n              ? stack.a[caseName]\n              : match[caseName](data)\n            if (caseValue) {\n              launchCase(scopeTargets, caseName, data, stack)\n              return\n            }\n          }\n          launchCase(scopeTargets, '__', data, stack)\n        },\n      }),\n    ]\n  } else {\n    throwError('expect match to be unit, function or object')\n  }\n  createNode({\n    meta: {\n      onCopy: Object.keys(targets),\n      op: 'split',\n    },\n    parent: source,\n    scope: targets,\n    node: splitterSeq!,\n    family: {\n      type: 'crosslink',\n      owners: Array.from(owners),\n    },\n    regional: true,\n  })\n  if (!knownCases) return targets\n}\n","import {getForkPage, getGraph, getLinks, getOwners, getParent} from './getter'\nimport {bind} from './bind'\nimport {createDefer} from './defer'\nimport {watchUnit} from './watch'\nimport {is, isObject} from './is'\nimport {throwError} from './throw'\nimport {launch, forkPage, setForkPage, currentPage} from './kernel'\nimport {createNode} from './createNode'\nimport {step} from './typedef'\nimport {Domain, Store} from './unit.h'\nimport {Node, StateRef} from './index.h'\nimport {removeItem, forEach, includes, forIn} from './collection'\nimport {DOMAIN, STORE, EVENT, EFFECT, SAMPLER, MAP, FORK_COUNTER} from './tag'\n\n/**\n hydrate state on client\n\n const root = createDomain()\n hydrate(root, {\n  values: window.__initialState__\n})\n\n */\nexport function hydrate(domain: Domain, {values}: {values: any}) {\n  const isScope = isObject(domain) && (domain as any).cloneOf\n  if (!is.domain(domain) && !isScope) {\n    throwError('first argument of hydrate should be domain or scope')\n  }\n  if (!isObject(values)) {\n    throwError('values property should be an object')\n  }\n  const normalizedValues = normalizeValues(values)\n  let storeWatches: Node[]\n  let storeWatchesRefs: any[]\n  if (isScope) {\n    storeWatches = []\n    storeWatchesRefs = []\n    forIn(normalizedValues, (val, sid) => {\n      //@ts-ignore\n      const node = domain.sidMap[sid]\n      if (node) {\n        storeWatches.push(node)\n        storeWatchesRefs.push(val)\n        ;(domain as any).changedStores.add(node.meta.forkOf.id)\n      }\n    })\n  } else {\n    const fillResult = fillValues({\n      flatGraphUnits: flatGraph(domain),\n      values: normalizedValues,\n      collectWatches: true,\n    })\n    storeWatches = fillResult.storeWatches\n    storeWatchesRefs = fillResult.storeWatchesRefs.map(({current}) => current)\n  }\n\n  launch({\n    target: storeWatches,\n    params: storeWatchesRefs,\n    forkPage: isScope ? domain : false,\n  })\n}\n\nfunction fillValues({\n  flatGraphUnits,\n  values,\n  collectWatches,\n}: {\n  flatGraphUnits: Node[]\n  values: Record<string, any>\n  collectWatches: boolean\n}) {\n  const storeWatches: Node[] = []\n  const storeWatchesRefs: StateRef[] = []\n  const refsMap = {} as Record<string, StateRef>\n  const predefinedRefs = new Set()\n  const valuesSidList = Object.getOwnPropertyNames(values)\n  forEach(flatGraphUnits, node => {\n    const {reg} = node\n    const {op, unit, sid} = node.meta\n    if (unit === STORE) {\n      if (sid && includes(valuesSidList, sid)) {\n        const {state} = node.scope\n        state.current = values[sid]\n        predefinedRefs.add(state)\n      }\n    }\n    if (collectWatches && op === 'watch') {\n      const owner = node.family.owners[0]\n      if (owner.meta.unit === STORE) {\n        storeWatches.push(node)\n        storeWatchesRefs.push(owner.scope.state)\n      }\n    }\n    forIn(reg, (ref, id) => {\n      refsMap[id] = ref\n    })\n  })\n  const refGraph = createRefGraph(refsMap)\n  const result = toposort(refGraph)\n  forEach(result, id => {\n    execRef(refsMap[id])\n  })\n\n  return {\n    storeWatches,\n    storeWatchesRefs,\n  }\n\n  function execRef(ref: StateRef) {\n    let isFresh = false\n    if (ref.before && !predefinedRefs.has(ref)) {\n      forEach(ref.before, cmd => {\n        switch (cmd.type) {\n          case MAP: {\n            const from = cmd.from\n            ref.current = cmd.fn(from.current)\n            break\n          }\n          case 'field': {\n            const from = cmd.from\n            if (!isFresh) {\n              isFresh = true\n              if (Array.isArray(ref.current)) {\n                ref.current = [...ref.current]\n              } else {\n                ref.current = {...ref.current}\n              }\n            }\n            ref.current[cmd.field] = from.current\n            break\n          }\n          case 'closure':\n            break\n        }\n      })\n    }\n    if (!ref.after) return\n    const value = ref.current\n    forEach(ref.after, cmd => {\n      const to = cmd.to\n      // if (predefinedRefs.has(to)) continue\n      switch (cmd.type) {\n        case 'copy':\n          to.current = value\n          break\n        case MAP:\n          to.current = cmd.fn(value)\n          break\n      }\n    })\n  }\n}\n\nfunction createRefGraph(refsMap: Record<string, StateRef>) {\n  const items = Object.values(refsMap)\n  const refGraph = {} as Record<string, string[]>\n  forEach(items, ({id}) => {\n    refGraph[id] = []\n  })\n  //prettier-ignore\n  forEach(items, ({id, before, after}) => {\n    before && forEach(before, cmd => {\n      refGraph[cmd.from.id].push(id)\n    })\n    after && forEach(after, cmd => {\n      refGraph[id].push(cmd.to.id)\n    })\n  })\n  return refGraph\n}\n\n/**\n serialize state on server\n */\nexport function serialize(\n  {clones, changedStores}: any,\n  {\n    ignore = [],\n    onlyChanges,\n  }: {ignore?: Array<Store<any>>; onlyChanges?: boolean} = {},\n) {\n  const result = {} as Record<string, any>\n  forEach(clones, ({meta, scope, reg}) => {\n    if (meta.unit !== STORE) return\n    const {sid} = meta\n    if (!sid) return\n    if (onlyChanges || meta.isCombine) {\n      if (!changedStores.has(meta.forkOf.id)) return\n    }\n    result[sid] = reg[scope.state.id].current\n  })\n  forEach(ignore, ({sid}) => {\n    if (sid) delete result[sid]\n  })\n  return result\n}\n\n/** bind event to scope */\nexport function scopeBind(unit: any) {\n  if (!forkPage) {\n    throwError('scopeBind cannot be called outside of forked .watch')\n  }\n  const savedForkPage = forkPage\n  const localUnit = forkPage.find(unit)\n  return is.effect(unit)\n    ? (params: any) => {\n        const req = createDefer()\n        launch({\n          target: localUnit,\n          params: {\n            params,\n            req,\n          },\n          forkPage: savedForkPage,\n        })\n      }\n    : (params: any) => {\n        launch({target: localUnit, params, forkPage: savedForkPage})\n        return params\n      }\n}\n\nfunction normalizeValues(\n  values: Map<Store<any>, any> | Record<string, any>,\n  assertEach = (key: any, value: any) => {},\n) {\n  if (values instanceof Map) {\n    const result = {} as Record<string, any>\n    for (const [key, value] of values) {\n      if (!is.unit(key)) throwError('Map key should be a unit')\n      assertEach(key, value)\n      result[key.sid!] = value\n    }\n    return result\n  }\n  return values\n}\n\nexport function fork(\n  domain: Domain,\n  {values, handlers}: {values?: any; handlers?: any} = {},\n) {\n  if (!is.domain(domain)) throwError('first argument of fork should be domain')\n  const needToFill = !!values\n  values = normalizeValues(\n    values || {},\n    unit =>\n      !is.store(unit) &&\n      throwError('Values map can contain only stores as keys'),\n  )\n  const forked = cloneGraph(domain)\n  if (needToFill) {\n    fillValues()\n  }\n  if (handlers) {\n    handlers = normalizeValues(\n      handlers,\n      unit =>\n        !is.effect(unit) &&\n        throwError(`Handlers map can contain only effects as keys`),\n    )\n    const handlerKeys = Object.keys(handlers)\n    forEach(forked.clones, ({scope, meta}) => {\n      if (meta.sid && includes(handlerKeys, meta.sid)) {\n        scope.runner.scope.getHandler = () => handlers[meta.sid]\n      }\n    })\n  }\n  return forked\n\n  function fillValues() {\n    const sourceList = flatGraph(domain)\n    const sourceRefsMap = {} as Record<string, StateRef>\n    const refsMap = {} as Record<string, StateRef>\n    const predefinedRefs = new Set()\n    const templateOwnedRefs = new Set<string>()\n    const valuesSidList = Object.getOwnPropertyNames(values)\n    forEach(sourceList, ({reg, meta}) => {\n      const {nativeTemplate} = meta\n      forIn(reg, (ref, id) => {\n        sourceRefsMap[id] = ref\n        if (nativeTemplate) {\n          templateOwnedRefs.add(id)\n        }\n      })\n    })\n    forEach(forked.clones, node => {\n      const {reg} = node\n      const {unit, sid} = node.meta\n      if (unit === STORE) {\n        if (sid && includes(valuesSidList, sid)) {\n          const {state} = node.scope\n          reg[state.id].current = values[sid]\n          predefinedRefs.add(state)\n          forked.changedStores.add(node.meta.forkOf.id)\n        }\n      }\n      forIn(reg, (ref, id) => {\n        refsMap[id] = ref\n      })\n    })\n    const refGraph = createRefGraph(sourceRefsMap)\n    const result = toposort(refGraph, templateOwnedRefs)\n    forEach(result, id => {\n      execRef(refsMap[id], sourceRefsMap[id])\n    })\n\n    function execRef(ref: StateRef, sourceRef?: StateRef) {\n      let isFresh = false\n      if (sourceRef && sourceRef.before && !predefinedRefs.has(ref)) {\n        forEach(sourceRef.before, cmd => {\n          switch (cmd.type) {\n            case MAP: {\n              const from = refsMap[cmd.from.id]\n              ref.current = cmd.fn(from.current)\n              break\n            }\n            case 'field': {\n              const from = refsMap[cmd.from.id]\n              if (!isFresh) {\n                isFresh = true\n                if (Array.isArray(ref.current)) {\n                  ref.current = [...ref.current]\n                } else {\n                  ref.current = {...ref.current}\n                }\n              }\n              ref.current[cmd.field] = from.current\n              break\n            }\n            case 'closure':\n              break\n          }\n        })\n      }\n      if (!sourceRef || !sourceRef.after) return\n      const value = ref.current\n      forEach(sourceRef.after, cmd => {\n        const to = refsMap[cmd.to.id]\n        // if (predefinedRefs.has(to)) continue\n        switch (cmd.type) {\n          case 'copy':\n            to.current = value\n            break\n          case MAP:\n            to.current = cmd.fn(value)\n            break\n        }\n      })\n    }\n  }\n}\n\nfunction toposort(rawGraph: Record<string, string[]>, ignore?: Set<string>) {\n  const graph = {} as Record<string, string[]>\n  for (const id in rawGraph) {\n    graph[id] = [...new Set(rawGraph[id])]\n  }\n  const result = [] as string[]\n  const visited = {} as Record<string, boolean>\n  const temp = {} as Record<string, boolean>\n  for (const node in graph) {\n    if (!visited[node] && !temp[node]) {\n      topologicalSortHelper(node)\n    }\n  }\n  result.reverse()\n  if (ignore && ignore.size > 0) {\n    const processed = [] as string[]\n    const ignored = [...ignore]\n    let item: string | void\n    while ((item = ignored.shift())) {\n      processed.push(item)\n      forEach(graph[item], child => {\n        if (includes(processed, child) || includes(ignored, child)) return\n        ignored.push(child)\n      })\n    }\n    forEach(processed, item => {\n      removeItem(result, item)\n    })\n  }\n  return result\n\n  function topologicalSortHelper(node: string) {\n    temp[node] = true\n    const neighbors = graph[node]\n    for (let i = 0; i < neighbors.length; i++) {\n      const n = neighbors[i]\n      if (temp[n]) {\n        continue\n        // throw Error('found cycle in DAG')\n      }\n      if (!visited[n]) {\n        topologicalSortHelper(n)\n      }\n    }\n    temp[node] = false\n    visited[node] = true\n    result.push(node)\n  }\n}\n\nexport function allSettled(\n  start: any,\n  {scope, params: ctx}: {scope: any; params?: any},\n) {\n  if (!is.unit(start))\n    return Promise.reject(Error('first argument should be unit'))\n  const defer = createDefer()\n  //@ts-ignore\n  defer.parentFork = forkPage\n  const {forkInFlightCounter} = scope.graphite.scope\n  forkInFlightCounter.scope.defers.push(defer)\n  const contextStart = scope.find(start)\n\n  const launchUnits = [contextStart]\n  const launchParams = []\n  if (is.effect(start)) {\n    launchParams.push({\n      params: ctx,\n      req: {\n        rs(value: any) {\n          //@ts-ignore\n          defer.value = {status: 'done', value}\n        },\n        rj(value: any) {\n          //@ts-ignore\n          defer.value = {status: 'fail', value}\n        },\n      },\n    })\n  } else {\n    launchParams.push(ctx)\n  }\n  launchUnits.push(forkInFlightCounter)\n  launchParams.push(null)\n  launch({\n    target: launchUnits,\n    params: launchParams,\n    forkPage: scope,\n  })\n  return defer.req\n}\n\nfunction flatGraph(unit: any) {\n  const list = [] as Node[]\n  ;(function traverse(node) {\n    if (includes(list, node)) return\n    list.push(node)\n    forEachRelatedNode(node, traverse)\n  })(getGraph(unit))\n  return list\n}\n\n/**\n everything we need to clone graph section\n reachable from given unit\n */\nfunction cloneGraph(unit: any) {\n  const list = flatGraph(unit)\n  const refs = new Map()\n  const scope = {\n    defers: [],\n    inFlight: 0,\n    fxID: 0,\n  }\n  const changedStores = new Set<string>()\n  const putStoreToChanged = step.compute({\n    fn(upd, _, stack) {\n      if (\n        !stack.node.meta.isCombine ||\n        (getParent(stack) && getParent(stack).node.meta.op !== 'combine')\n      )\n        changedStores.add(stack.node.meta.forkOf.id)\n      return upd\n    },\n  })\n  const forkInFlightCounter = createNode({\n    scope,\n    node: [\n      step.compute({\n        fn(_, scope, stack) {\n          if (!stack.parent) {\n            scope.fxID += 1\n            return\n          }\n          if (stack.parent.node.meta.named === 'finally') {\n            scope.inFlight -= 1\n          } else {\n            scope.inFlight += 1\n            scope.fxID += 1\n          }\n        },\n      }),\n      step.barrier({priority: SAMPLER}),\n      step.run({\n        fn(_, scope) {\n          const {inFlight, defers, fxID} = scope\n          if (inFlight > 0 || defers.length === 0) return\n          Promise.resolve().then(() => {\n            if (scope.fxID !== fxID) return\n            forEach(defers.splice(0, defers.length), (defer: any) => {\n              setForkPage(defer.parentFork)\n              defer.rs(defer.value)\n            })\n          })\n        },\n      }),\n    ],\n    meta: {unit: FORK_COUNTER},\n  })\n  const nodeMap = {} as Record<string, Node>\n  const sidMap = {} as Record<string, Node>\n  const clones = list.map(node => {\n    const {seq, next, meta, scope} = node\n    const result = createNode({\n      node: seq.map(step => ({\n        id: step.id,\n        type: step.type,\n        data: {...step.data},\n        hasRef: step.hasRef,\n      })) as any,\n      child: [...next],\n      meta: {forkOf: node, ...meta},\n      scope: {...scope},\n    })\n    result.family = {\n      type: node.family.type,\n      links: [...getLinks(node)],\n      owners: [...getOwners(node)],\n    }\n    nodeMap[node.id] = result\n    if (meta.sid) sidMap[meta.sid] = result\n    return result\n  })\n  const page = {} as Record<string, StateRef>\n  forEach(clones, node => {\n    const {\n      reg,\n      scope,\n      meta: {onCopy, op, unit},\n    } = node\n    forIn(reg, (ref, id) => {\n      let newRef = refs.get(ref)\n      if (!newRef) {\n        newRef = {\n          id: ref.id,\n          current: ref.current, //ref.id in values ? values[ref.id] : ref.current,\n        }\n        refs.set(ref, newRef)\n      }\n      page[id] = reg[id] = newRef\n    })\n    if (onCopy) {\n      forEach(onCopy, (copyField: string) => {\n        const origValue = scope[copyField]\n        scope[copyField] = Array.isArray(origValue)\n          ? origValue.map(findClone)\n          : findClone(origValue)\n      })\n    }\n    forEachRelatedNode(node, (node, i, siblings) => {\n      siblings[i] = findClone(node)\n    })\n    const itemTag = op || unit\n    switch (itemTag) {\n      case STORE:\n        node.meta.wrapped = wrapStore(node)\n        if (node.meta.sid) node.seq.push(putStoreToChanged)\n        break\n      // case EVENT:\n      //   break\n      case EFFECT:\n        node.next.push(forkInFlightCounter)\n        break\n      case 'fx': {\n        scope.finally.next.push(forkInFlightCounter)\n        break\n      }\n      // case 'watch':\n      //   break\n    }\n  })\n\n  return {\n    cloneOf: unit,\n    changedStores,\n    nodeMap,\n    sidMap,\n    clones,\n    find: findClone,\n    reg: page,\n    getState: (store: any) => findClone(store).meta.wrapped.getState(),\n    graphite: createNode({\n      family: {\n        type: DOMAIN,\n        links: [forkInFlightCounter, ...clones],\n      },\n      meta: {unit: 'fork'},\n      scope: {forkInFlightCounter},\n    }),\n  }\n\n  function findClone(unit: any) {\n    const node = getGraph(unit)\n    const index = list.indexOf(node)\n    if (index === -1) {\n      let unitName = 'unit'\n      if (unit !== node && unit.id !== unit.shortName) unitName = unit.shortName\n      throwError(`${unitName} not found in forked scope`)\n    }\n    return clones[index]\n  }\n}\n\nfunction wrapStore(node: Node) {\n  return {\n    kind: STORE,\n    getState: () => node.reg[node.scope.state.id].current,\n    updates: {\n      watch: bind(watchUnit, node),\n    },\n    graphite: node,\n    family: node.family,\n  }\n}\n\nfunction forEachRelatedNode(\n  node: Node,\n  cb: (node: Node, index: number, siblings: Node[]) => void,\n) {\n  const unit = node.meta.unit\n  if (unit === 'fork' || unit === FORK_COUNTER) return\n  forEach(node.next, cb)\n  forEach(getOwners(node), cb)\n  forEach(getLinks(node), cb)\n}\n","export const observableSymbol: any =\n  (typeof Symbol !== 'undefined' && Symbol.observable) || '@@observable'\n","import {kind} from './index.h'\nimport {DOMAIN, STORE, EVENT, EFFECT} from './tag'\nimport {isObject, isFunction} from './is'\n\nexport const unit = (obj: any) =>\n  (isFunction(obj) || isObject(obj)) && 'kind' in obj\n\nconst is = (type: kind) => (obj: any) => unit(obj) && obj.kind === type\n\nexport const store = is(STORE)\nexport const event = is(EVENT)\nexport const effect = is(EFFECT)\nexport const domain = is(DOMAIN)\n","export const throwError = (message: string) => {\n  throw Error(message)\n}\n","const idCount = () => {\n  let id = 0\n  return () => (++id).toString(36)\n}\n\nexport const nextUnitID = idCount()\nexport const nextStepID = idCount()\nexport const nextNodeID = idCount()\n","export const bind = (fn: Function, target: any) => fn.bind(null, target)\nexport const bind2 = (fn: Function, target: any, arg: any) =>\n  fn.bind(null, target, arg)\n","import {StateRef, Run, Filter, Compute, Barrier, Check, Mov} from './index.h'\nimport {nextStepID} from './id'\nimport {bind2} from './bind'\nimport {BARRIER, FILTER, STACK, STORE} from './tag'\n\nconst cmd = (type: any, hasRef: boolean, data: any): any => ({\n  id: nextStepID(),\n  type,\n  data,\n  hasRef,\n})\n\nlet nextBarrierID = 0\n\nexport const barrier: (data: {priority?: 'barrier' | 'sampler'}) => Barrier = ({\n  priority = BARRIER,\n}) =>\n  cmd(BARRIER, false, {\n    barrierID: ++nextBarrierID,\n    priority,\n  })\nexport const mov: (data: {\n  from?: 'value' | 'store' | 'stack' | 'a' | 'b'\n  to?: 'stack' | 'a' | 'b' | 'store'\n  store?: any\n  target?: any\n}) => Mov = ({from = STORE, store, target, to = target ? STORE : STACK}) =>\n  cmd('mov', from === STORE, {from, store, to, target})\nexport const check: {\n  defined(): Check\n  changed(config: {store: StateRef}): Check\n} = {\n  defined: () => cmd('check', false, {type: 'defined'}),\n  changed: ({store}) => cmd('check', true, {type: 'changed', store}),\n}\nexport const compute: (data: {\n  fn: (data: any, scope: {[key: string]: any}, stack: any) => any\n}) => Compute = bind2(cmd, 'compute', false)\nexport const filter: (data: {\n  fn: (data: any, scope: {[key: string]: any}, stack: any) => any\n}) => Filter = bind2(cmd, FILTER, false)\nexport const run: (data: {\n  fn: (data: any, scope: {[key: string]: any}, stack: any) => any\n}) => Run = bind2(cmd, 'run', false)\nexport const update: (data: {store: StateRef}) => Mov = ({store}) =>\n  mov({from: STACK, target: store})\n","import {StateRef} from './index.h'\nimport {nextStepID} from './id'\n\nexport const createStateRef = (current?: any): StateRef => ({\n  id: nextStepID(),\n  current,\n})\nexport const readRef = ({current}: StateRef | {current: any}) => current\n","export const callStackAReg = (stack: any, {fn}: any, {a}: any) => fn(stack, a)\nexport const callARegStack = (stack: any, {fn}: any, {a}: any) => fn(a, stack)\nexport const callStack = (stack: any, {fn}: any, _: any) => fn(stack)\n","import {Node, StateRef} from './index.h'\n\nexport const getGraph = (graph: any): Node => graph.graphite || graph\nexport const getOwners = (node: Node) => node.family.owners\nexport const getLinks = (node: Node) => node.family.links\nexport const getStoreState = (store: any): StateRef => store.stateRef\nexport const getConfig = (opts: any) => opts.config\nexport const getNestedConfig = (opts: any) => opts.ɔ\nexport const getValue = (stack: any) => stack.value\nexport const getSubscribers = (store: any) => store.subscribers\nexport const getParent = (unit: any) => unit.parent\nexport const getForkPage = (val: any) => val.forkPage\n","import {NodeUnit} from './index.h'\nimport {getGraph, getOwners, getLinks} from './getter'\nimport {DOMAIN, CROSSLINK} from './tag'\n\nexport const own = (ownerUnit: NodeUnit, links: NodeUnit[]) => {\n  const owner = getGraph(ownerUnit)\n  for (let i = 0; i < links.length; i++) {\n    const link = getGraph(links[i])\n    if (owner.family.type !== DOMAIN) link.family.type = CROSSLINK\n    getOwners(link).push(owner)\n    getLinks(owner).push(link)\n  }\n}\n","import {getConfig, getNestedConfig} from './getter'\nimport {assertObject} from './is'\n\nexport const onConfigNesting = (\n  rawConfig: any,\n  fn: (babelData: any, userConfig: any) => void,\n) => {\n  assertObject(rawConfig)\n  if (getNestedConfig(rawConfig)) {\n    fn(getConfig(rawConfig), getNestedConfig(rawConfig))\n  }\n}\n\nexport const processArgsToConfig = (args: any[]): [any[], any | void] => {\n  let metadata\n  onConfigNesting(args[0], (injected, config) => {\n    metadata = injected\n    args = config\n  })\n  return [args, metadata]\n}\n","import {Node, NodeUnit} from './index.h'\nimport {getGraph, getOwners, getLinks, getSubscribers} from './getter'\nimport {is} from './is'\nimport {removeItem} from './collection'\nimport {CROSSLINK} from './tag'\n\nconst removeFromNode = (currentNode: Node, targetNode: Node) => {\n  removeItem(currentNode.next, targetNode)\n  removeItem(getOwners(currentNode), targetNode)\n  removeItem(getLinks(currentNode), targetNode)\n}\nconst clearNodeNormalized = (\n  targetNode: Node,\n  deep: boolean,\n  isDomainUnit: boolean,\n) => {\n  targetNode.next.length = 0\n  targetNode.seq.length = 0\n  //@ts-ignore\n  targetNode.scope = null\n  let currentNode\n  let list = getLinks(targetNode)\n  while ((currentNode = list.pop())) {\n    removeFromNode(currentNode, targetNode)\n    if (\n      deep ||\n      (isDomainUnit && !targetNode.meta.sample) ||\n      currentNode.family.type === CROSSLINK\n    ) {\n      clearNodeNormalized(\n        currentNode,\n        deep,\n        currentNode.meta.op !== 'on' && isDomainUnit,\n      )\n    }\n  }\n  list = getOwners(targetNode)\n  while ((currentNode = list.pop())) {\n    removeFromNode(currentNode, targetNode)\n    if (isDomainUnit && currentNode.family.type === CROSSLINK) {\n      clearNodeNormalized(\n        currentNode,\n        deep,\n        currentNode.meta.op !== 'on' && isDomainUnit,\n      )\n    }\n  }\n}\nconst clearMap = (map: any) => map.clear()\nexport const clearNode = (\n  graphite: NodeUnit,\n  {\n    deep,\n  }: {\n    deep?: boolean\n  } = {},\n) => {\n  let isDomainUnit = false\n  //@ts-ignore\n  if (graphite.ownerSet) graphite.ownerSet.delete(graphite)\n  if (is.store(graphite)) {\n    clearMap(getSubscribers(graphite))\n  } else if (is.domain(graphite)) {\n    isDomainUnit = true\n    //@ts-ignore\n    const history = graphite.history\n    clearMap(history.events)\n    clearMap(history.effects)\n    clearMap(history.stores)\n    clearMap(history.domains)\n  }\n  clearNodeNormalized(getGraph(graphite), !!deep, isDomainUnit)\n}\n","import {Subscription, NodeUnit} from './index.h'\nimport {bind2} from './bind'\nimport {clearNode} from './clearNode'\n\nexport const createSubscription = (node: NodeUnit): Subscription => {\n  const result = bind2(clearNode, node, undefined)\n  result.unsubscribe = result\n  return result\n}\n","import {onConfigNesting} from './config'\nimport {createNode} from './createNode'\nimport {Subscription, NodeUnit, Cmd} from './index.h'\nimport {createSubscription} from './subscription'\nimport {assertNodeSet} from './is'\n\nexport const createLinkNode = (\n  parent: NodeUnit,\n  child: NodeUnit | NodeUnit[],\n  {\n    node,\n    scope,\n    meta,\n  }: {\n    node?: Array<Cmd | false | void | null>\n    scope?: {[name: string]: any}\n    meta?: {[name: string]: any}\n  },\n) =>\n  createNode({\n    node,\n    parent,\n    child,\n    scope,\n    meta,\n    family: {\n      owners: [parent, child],\n      links: child,\n    },\n    regional: true,\n  })\nexport const forward = (opts: {\n  from: NodeUnit | NodeUnit[]\n  to: NodeUnit | NodeUnit[]\n  meta?: Record<string, any>\n}): Subscription => {\n  let config\n  onConfigNesting(opts, (injectedData, userConfig) => {\n    config = injectedData\n    opts = userConfig\n  })\n  const {from, to, meta = {op: 'forward'}} = opts\n  assertNodeSet(from, 'forward', '\"from\"')\n  assertNodeSet(to, 'forward', '\"to\"')\n  if (config) meta.config = config\n  return createSubscription(\n    createNode({\n      parent: from,\n      child: to,\n      meta,\n      family: {},\n      regional: true,\n    }),\n  )\n}\n","import {step} from './typedef'\nimport {callStack} from './caller'\nimport {createNode} from './createNode'\nimport {Subscription, NodeUnit} from './index.h'\nimport {createSubscription} from './subscription'\nimport {throwError} from './throw'\nimport {isFunction} from './is'\nimport {forkPage} from './kernel'\nimport {getGraph} from './getter'\n\nexport const watchUnit = (\n  unit: NodeUnit,\n  handler: (payload: any) => any,\n): Subscription => {\n  if (!isFunction(handler)) throwError('.watch argument should be a function')\n  if (forkPage) {\n    const forkedNode = forkPage.nodeMap[getGraph(unit).id]\n    if (forkedNode) unit = forkedNode\n  }\n  return createSubscription(\n    createNode({\n      scope: {fn: handler},\n      node: [step.run({fn: callStack})],\n      parent: unit,\n      meta: {op: 'watch'},\n      family: {\n        owners: unit,\n      },\n      regional: true,\n    }),\n  )\n}\n"]},"metadata":{},"sourceType":"module"}