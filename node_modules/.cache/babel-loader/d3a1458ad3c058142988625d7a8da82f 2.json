{"ast":null,"code":"'use strict';\n\nfunction e(e, r) {\n  (null == r || r > e.length) && (r = e.length);\n\n  for (var n = 0, t = new Array(r); n < r; n++) t[n] = e[n];\n\n  return t;\n}\n\nfunction r(r, n) {\n  var it = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n  if (it) return (it = it.call(r)).next.bind(it);\n\n  if (Array.isArray(r) || (it = function (r, n) {\n    if (r) {\n      if (\"string\" == typeof r) return e(r, n);\n      var t = {}.toString.call(r).slice(8, -1);\n      return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? e(r, n) : void 0;\n    }\n  }(r)) || n && r && \"number\" == typeof r.length) {\n    it && (r = it);\n    var t = 0;\n    return function () {\n      return t >= r.length ? {\n        done: 1\n      } : {\n        done: 0,\n        value: r[t++]\n      };\n    };\n  }\n\n  throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction n(e, r, n, t) {\n  (E(e) || z(e)) && ('family' in e || 'graphite' in e) || M(r + \": expect \" + n + \" to be a unit (store, event or effect)\" + t);\n}\n\nfunction t(e, r, t) {\n  if (Array.isArray(e)) for (var a = 0; a < e.length; a++) n(e[a], r, a + \" item of \" + t, '');else n(e, r, t, ' or array of units');\n}\n\nfunction a(e, r) {\n  var n = ue(e).meta;\n  ye = {\n    parent: ye,\n    value: e,\n    template: n.template || be(),\n    sidRoot: n.sidRoot || ye && ye.sidRoot\n  };\n\n  try {\n    return r();\n  } finally {\n    ye = ve(ye);\n  }\n}\n\nfunction o(e) {\n  for (var r = void 0 === e ? {} : e, n = r.node, t = void 0 === n ? [] : n, a = r.parent, o = r.child, i = void 0 === o ? r.to || r.target : o, u = r.scope, f = void 0 === u ? {} : u, c = r.meta, s = void 0 === c ? {} : c, l = r.family, p = void 0 === l ? {\n    type: 'regular'\n  } : l, d = r.regional, m = we(void 0 === a ? r.from || r.source : a), v = we(p.links), h = we(p.owners), g = [], y = {}, b = 0; b < t.length; b++) {\n    var k = t[b];\n    k && (g.push(k), xe(k, y));\n  }\n\n  for (var w = {\n    id: B(),\n    seq: g,\n    next: we(i),\n    meta: s,\n    scope: f,\n    family: {\n      type: p.type || \"crosslink\",\n      links: v,\n      owners: h\n    },\n    reg: y\n  }, x = 0; x < v.length; x++) fe(v[x]).push(w);\n\n  for (var S = 0; S < h.length; S++) ce(h[S]).push(w);\n\n  for (var A = 0; A < m.length; A++) m[A].next.push(w);\n\n  return d && ye && ge(de(ye), [w]), w;\n}\n\nfunction i(e, r, n) {\n  var t = Me,\n      a = null,\n      o = je;\n  if (e.target && (r = e.params, n = e.defer, t = 'page' in e ? e.page : t, e.stack && (a = e.stack), o = he(e) || o, e = e.target), o && je && o !== je && (je = null), Array.isArray(e)) for (var i = 0; i < e.length; i++) Pe('pure', t, ue(e[i]), a, r[i], o);else Pe('pure', t, ue(e), a, r, o);\n\n  if (!n || De) {\n    var u,\n        f,\n        c,\n        s,\n        l,\n        p,\n        d = {\n      isRoot: De,\n      currentPage: Me,\n      forkPage: je,\n      isWatch: Ie\n    };\n    De = 0;\n\n    e: for (; s = Ce();) {\n      var m = s.idx,\n          v = s.stack,\n          h = s.type;\n      c = v.node, Me = l = v.page, je = he(v), p = (l || c).reg;\n      var g = {\n        fail: 0,\n        scope: c.scope\n      };\n      u = f = 0;\n\n      for (var y = m; y < c.seq.length && !u; y++) {\n        var b = c.seq[y],\n            k = b.data;\n\n        switch (b.type) {\n          case \"barrier\":\n            var w = k.barrierID;\n            l && (w = l.fullID + \"_\" + w);\n            var x = k.priority;\n\n            if (y !== m || h !== x) {\n              _e.has(w) || (_e.add(w), Fe(y, v, x, w));\n              continue e;\n            }\n\n            _e.delete(w);\n\n            break;\n\n          case 'mov':\n            var S = void 0;\n\n            switch (k.from) {\n              case O:\n                S = de(v);\n                break;\n\n              case \"a\":\n              case 'b':\n                S = v[k.from];\n                break;\n\n              case \"value\":\n                S = k.store;\n                break;\n\n              case N:\n                p[k.store.id] || (v.page = l = Te(l, k.store.id), p = l ? l.reg : c.reg), S = te(p[k.store.id]);\n            }\n\n            switch (k.to) {\n              case O:\n                v.value = S;\n                break;\n\n              case \"a\":\n              case 'b':\n                v[k.to] = S;\n                break;\n\n              case N:\n                We(l, c, k.target.id).current = S;\n            }\n\n            break;\n\n          case 'check':\n            switch (k.type) {\n              case 'defined':\n                f = void 0 === de(v);\n                break;\n\n              case 'changed':\n                f = de(v) === te(We(l, c, k.store.id));\n            }\n\n            break;\n\n          case \"filter\":\n            f = !He(g, k, v);\n            break;\n\n          case 'run':\n            if (y !== m || \"effect\" !== h) {\n              Fe(y, v, \"effect\");\n              continue e;\n            }\n\n          case 'compute':\n            Ie = 'watch' === c.meta.op, v.value = He(g, k, v), Ie = d.isWatch;\n        }\n\n        u = g.fail || f;\n      }\n\n      if (!u) for (var A = 0; A < c.next.length; A++) Pe('child', l, c.next[A], v, de(v), he(v));\n    }\n\n    De = d.isRoot, Me = d.currentPage, je = he(d);\n  }\n}\n\nfunction u(e, r) {\n  void 0 === r && (r = 'combine');\n  var n = r + '(',\n      t = '',\n      a = 0;\n\n  for (var o in e) {\n    var i = e[o];\n    if (null != i && (n += t, n += C(i) ? i.compositeName.fullName : i.toString()), 25 === (a += 1)) break;\n    t = ', ';\n  }\n\n  return n + ')';\n}\n\nfunction f(e, r) {\n  var n,\n      t,\n      a,\n      o = e;\n  return r ? (a = r.compositeName, 0 === e.length ? (n = a.path, t = a.fullName) : (n = a.path.concat([e]), t = 0 === a.fullName.length ? e : a.fullName + '/' + e)) : (n = 0 === e.length ? [] : [e], t = e), {\n    shortName: o,\n    fullName: t,\n    path: n\n  };\n}\n\nfunction c(e, r) {\n  for (var n in e) r(e[n], n);\n}\n\nfunction s(e, r) {\n  e.forEach(r);\n}\n\nfunction l(e, r, n, t) {\n  var a = Me,\n      o = null;\n  if (r) for (o = Me; o && o.template !== r;) o = ve(o);\n  ze(o);\n  var i = e.create(n, t);\n  return ze(a), i;\n}\n\nfunction p(e, r) {\n  var n = function e(r) {\n    for (var n = arguments.length, a = new Array(n > 1 ? n - 1 : 0), o = 1; o < n; o++) a[o - 1] = arguments[o];\n\n    return Me ? l(e, t, r, a) : e.create(r, a);\n  };\n\n  n.graphite = o({\n    meta: ar(\"event\", n, r, e),\n    regional: 1\n  }), n.create = function (e) {\n    return i(je ? je.find(n) : n, e), e;\n  }, n.watch = G(rr, n), n.map = function (e) {\n    var r, t;\n    E(e) && (r = e, t = e.name, e = e.fn);\n    var a = p(Be(n, t), r);\n    return ir(n, a, j, e), a;\n  }, n.filter = function (e) {\n    return ur(n, \"filter\", e.fn ? e : e.fn, [Y({\n      fn: ie\n    })]);\n  }, n.filterMap = function (e) {\n    return ur(n, 'filterMap', e, [X({\n      fn: ie\n    }), Q.defined()]);\n  }, n.prepend = function (e) {\n    var r = p('* → ' + n.shortName, {\n      parent: ve(n)\n    }),\n        t = be();\n    return t && ue(r).seq.push(t.upward), ir(r, n, 'prepend', e), tr(n, r), r;\n  };\n  var t = be();\n  return n;\n}\n\nfunction d(e, n) {\n  function a(e, r) {\n    p.off(e), me(p).set(e, Ye(fr(e, p, 'on', 1, r, v)));\n  }\n\n  var u = ne(e),\n      f = ne(e),\n      c = or('updates'),\n      s = be();\n  u.after = [{\n    type: 'copy',\n    to: f\n  }], s && s.plain.push(u, f);\n  var l = u.id,\n      p = {\n    subscribers: new Map(),\n    updates: c,\n    defaultState: e,\n    stateRef: u,\n    getState: function () {\n      var e,\n          r = u;\n\n      if (Me) {\n        for (var n = Me; n && !n.reg[l];) n = ve(n);\n\n        n && (e = n);\n      }\n\n      return !e && je && je.reg[l] && (e = je), e && (r = e.reg[l]), te(r);\n    },\n    setState: function (e) {\n      var r;\n      je && (r = je.nodeMap[ue(p).id]), r || (r = p), i({\n        target: r,\n        params: e,\n        defer: 1\n      });\n    },\n    reset: function () {\n      for (var e = arguments.length, r = new Array(e), n = 0; n < e; n++) r[n] = arguments[n];\n\n      for (var t = 0, a = r; t < a.length; t++) {\n        var o = a[t];\n        p.on(o, function () {\n          return p.defaultState;\n        });\n      }\n\n      return p;\n    },\n    on: function (e, n) {\n      if (t(e, '.on', 'first argument'), Array.isArray(e)) for (var o, i = r(e); !(o = i()).done;) a(o.value, n);else a(e, n);\n      return p;\n    },\n    off: function (e) {\n      var r = me(p).get(e);\n      return r && (r(), me(p).delete(e)), p;\n    },\n    map: function (e, r) {\n      var n, t, a;\n      E(e) && (n = e, t = e.name, r = e.firstState, e = e.fn);\n      var o = p.getState(),\n          i = be();\n      i ? a = null : void 0 !== o && (a = e(o, r));\n      var f = d(a, {\n        name: Be(p, t),\n        config: n,\n        strict: 0\n      }),\n          c = fr(p, f, j, 0, e);\n      return se(f).before = [{\n        type: j,\n        fn: e,\n        from: u\n      }], i && ($e(i.plain, u) || $e(c.seq, i.loader) || c.seq.unshift(i.loader)), f;\n    },\n    watch: function (e, r) {\n      if (!r || !C(e)) {\n        var n = rr(p, e),\n            t = be();\n        return t ? t.watch.push({\n          of: u,\n          fn: e\n        }) : e(p.getState()), n;\n      }\n\n      return z(r) || M('second argument should be a function'), e.watch(function (e) {\n        return r(p.getState(), e);\n      });\n    }\n  },\n      m = ar(N, p, n),\n      v = p.defaultConfig.updateFilter;\n  return p.graphite = o({\n    scope: {\n      state: u\n    },\n    node: [Q.defined(), Q.changed({\n      store: f\n    }), v && L({\n      store: f,\n      to: \"a\"\n    }), v && Y({\n      fn: function (e, r, n) {\n        return v(e, n.a);\n      }\n    }), ee({\n      store: u\n    }), ee({\n      store: f\n    })],\n    child: c,\n    meta: m,\n    regional: 1\n  }), Oe && void 0 === e && M(\"current state can't be undefined, use null instead\"), ge(p, [c]), p;\n}\n\nfunction m() {\n  for (var e = arguments.length, r = new Array(e), n = 0; n < e; n++) r[n] = arguments[n];\n\n  var t, a, o;\n  Ge(r[0], function (e, n) {\n    o = e, r = n;\n  });\n  var i,\n      u,\n      f = r[r.length - 1];\n\n  if (z(f) ? (a = r.slice(0, -1), t = f) : a = r, 1 === a.length) {\n    var c = a[0];\n    F(c) || (i = c, u = 1);\n  }\n\n  return u || (i = a, t && (t = cr(t))), E(i) || M('shape should be an object'), sr(Array.isArray(i), i, o, t);\n}\n\nfunction v() {\n  var e = {};\n  return e.req = new Promise(function (r, n) {\n    e.rs = r, e.rj = n;\n  }), e.req.catch(function () {}), e;\n}\n\nfunction h(e, r) {\n  var n = p(e, r),\n      t = n.defaultConfig.handler || function () {\n    return M(\"no handler used in \" + n.getType());\n  },\n      a = ue(n);\n\n  a.meta.onCopy = ['runner'], a.meta.unit = n.kind = \"effect\", n.use = function (e) {\n    return z(e) || M('.use argument should be a function'), t = e, n;\n  };\n  var u = n.finally = or('finally'),\n      f = n.done = u.filterMap({\n    named: 'done',\n    fn: function (e) {\n      if ('done' === e.status) return {\n        params: e.params,\n        result: e.result\n      };\n    }\n  }),\n      c = n.fail = u.filterMap({\n    named: 'fail',\n    fn: function (e) {\n      if ('fail' === e.status) return {\n        params: e.params,\n        error: e.error\n      };\n    }\n  }),\n      s = n.doneData = f.map({\n    named: 'doneData',\n    fn: function (e) {\n      return e.result;\n    }\n  }),\n      l = n.failData = c.map({\n    named: 'failData',\n    fn: function (e) {\n      return e.error;\n    }\n  }),\n      m = o({\n    scope: {\n      getHandler: n.use.getCurrent = function () {\n        return t;\n      },\n      finally: u\n    },\n    node: [Z({\n      fn: function (e, r, n) {\n        var t,\n            a = e.params,\n            o = e.req,\n            i = r.finally,\n            u = r.getHandler,\n            f = lr({\n          params: a,\n          req: o,\n          ok: 1,\n          anyway: i,\n          stack: n\n        }),\n            c = lr({\n          params: a,\n          req: o,\n          ok: 0,\n          anyway: i,\n          stack: n\n        });\n\n        try {\n          t = u()(a);\n        } catch (s) {\n          return void c(s);\n        }\n\n        E(t) && z(t.then) ? t.then(f, c) : f(t);\n      }\n    })],\n    meta: {\n      op: 'fx',\n      fx: 'runner',\n      onCopy: ['finally']\n    }\n  });\n  a.scope.runner = m, a.seq.push(X({\n    fn: function (e, r, n) {\n      return ve(n) ? {\n        params: e,\n        req: {\n          rs: function () {},\n          rj: function () {}\n        }\n      } : e;\n    }\n  }), Z({\n    fn: function (e, r, n) {\n      return i({\n        target: r.runner,\n        params: e,\n        defer: 1,\n        forkPage: he(n)\n      }), e.params;\n    }\n  })), n.create = function (e) {\n    var r = v(),\n        t = {\n      params: e,\n      req: r\n    };\n\n    if (je) {\n      if (!Ie) {\n        var a = je;\n        r.req.finally(function () {\n          Ee(a);\n        }).catch(function () {});\n      }\n\n      i(je.find(n), t);\n    } else i(n, t);\n\n    return r.req;\n  };\n  var h = n.inFlight = d(0, {\n    named: 'inFlight'\n  }).on(n, function (e) {\n    return e + 1;\n  }).on(u, function (e) {\n    return e - 1;\n  }),\n      g = n.pending = h.map({\n    fn: function (e) {\n      return e > 0;\n    },\n    named: 'pending'\n  });\n  return ge(n, [u, f, c, s, l, g, h, m]), n;\n}\n\nfunction g(e, r) {\n  var n = p(r || u(e, 'merge'));\n  return t(e, 'merge', 'first argument'), er({\n    from: e,\n    to: n,\n    meta: {\n      op: 'merge'\n    }\n  }), n;\n}\n\nfunction y(e) {\n  var r = 0;\n  return s(mr, function (n) {\n    n in e && (null == e[n] && M(\"sample: \" + n + \" should be defined\"), r = 1);\n  }), r;\n}\n\nfunction b() {\n  for (var e, r, n = arguments.length, a = new Array(n), i = 0; i < n; i++) a[i] = arguments[i];\n\n  var u,\n      f,\n      c = Ve(a),\n      s = c[0],\n      l = s[0],\n      v = s[1],\n      h = s[2],\n      b = c[1];\n  void 0 === v && E(l) && y(l) && (v = l.clock, h = l.fn, f = l.greedy, e = l.target, r = l.name, u = l.sid, l = l.source);\n  var k = 1;\n  void 0 === l && (t(v, 'sample', 'clock'), Array.isArray(v) && (v = g(v)), l = v, k = 0), k && !C(l) && (l = m(l)), void 0 === v && (v = l), t(v, 'sample', 'clock'), r = b || r || l.shortName;\n  var w = be(),\n      x = !!e;\n  if (!e) if (F(l) && F(v)) {\n    var S = h ? h(te(se(l)), te(se(v))) : te(se(l));\n    e = d(S, {\n      name: r,\n      sid: u\n    });\n  } else e = p(r), w && ue(e).seq.push(w.loader);\n  var A = x && C(e) && ue(e).meta.nativeTemplate;\n\n  if (F(l)) {\n    var q = se(l);\n    ge(l, [Ze(v, e, {\n      scope: {\n        fn: h,\n        targetTemplate: A\n      },\n      node: [w && w.loader, !f && K({\n        priority: \"sampler\"\n      }), L({\n        store: q,\n        to: h ? \"a\" : O\n      }), h && X({\n        fn: oe\n      }), w && x && w.upward],\n      meta: {\n        op: \"sample\",\n        sample: N\n      }\n    })]), w && ($e(w.plain, q) || $e(w.closure, q) || w.closure.push(q));\n  } else {\n    var j = ne(0),\n        P = ne(),\n        R = ne();\n    w && w.plain.push(j, P, R), o({\n      parent: l,\n      node: [ee({\n        store: P\n      }), L({\n        from: \"value\",\n        store: 1,\n        target: j\n      })],\n      family: {\n        owners: [l, e, v],\n        links: e\n      },\n      meta: {\n        op: \"sample\",\n        sample: 'source'\n      },\n      regional: 1\n    }), ge(l, [Ze(v, e, {\n      scope: {\n        fn: h,\n        targetTemplate: A\n      },\n      node: [w && w.loader, ee({\n        store: R\n      }), L({\n        store: j\n      }), Y({\n        fn: function (e) {\n          return e;\n        }\n      }), !f && K({\n        priority: \"sampler\"\n      }), L({\n        store: P\n      }), L({\n        store: R,\n        to: \"a\"\n      }), h && X({\n        fn: ae\n      }), w && x && w.upward],\n      meta: {\n        op: \"sample\",\n        sample: 'clock'\n      }\n    })]);\n  }\n\n  return e;\n}\n\nfunction k(e) {\n  var r = Object.values(e),\n      n = {};\n  return s(r, function (e) {\n    n[e.id] = [];\n  }), s(r, function (e) {\n    var r = e.id,\n        t = e.before,\n        a = e.after;\n    t && s(t, function (e) {\n      n[e.from.id].push(r);\n    }), a && s(a, function (e) {\n      n[r].push(e.to.id);\n    });\n  }), n;\n}\n\nfunction w(e, n) {\n  if (void 0 === n && (n = function () {}), e instanceof Map) {\n    for (var t, a = {}, o = r(e); !(t = o()).done;) {\n      var i = t.value,\n          u = i[0],\n          f = i[1];\n      C(u) || M('Map key should be a unit'), n(u, f), a[u.sid] = f;\n    }\n\n    return a;\n  }\n\n  return e;\n}\n\nfunction x(e, r) {\n  function n(e) {\n    u[e] = 1;\n\n    for (var r = t[e], a = 0; a < r.length; a++) {\n      var f = r[a];\n      u[f] || i[f] || n(f);\n    }\n\n    u[e] = 0, i[e] = 1, o.push(e);\n  }\n\n  var t = {};\n\n  for (var a in e) t[a] = [].concat(new Set(e[a]));\n\n  var o = [],\n      i = {},\n      u = {};\n\n  for (var f in t) i[f] || u[f] || n(f);\n\n  return o.reverse(), r && r.size > 0 && function () {\n    for (var e, n = [], a = [].concat(r); e = a.shift();) n.push(e), s(t[e], function (e) {\n      $e(n, e) || $e(a, e) || a.push(e);\n    });\n\n    s(n, function (e) {\n      Je(o, e);\n    });\n  }(), o;\n}\n\nfunction S(e) {\n  var r = [];\n  return function e(n) {\n    $e(r, n) || (r.push(n), A(n, e));\n  }(ue(e)), r;\n}\n\nfunction A(e, r) {\n  var n = e.meta.unit;\n  'fork' !== n && \"forkInFlightCounter\" !== n && (s(e.next, r), s(fe(e), r), s(ce(e), r));\n}\n\nObject.defineProperty(exports, '__esModule', {\n  value: 1\n});\n\nfor (var q = 'undefined' != typeof Symbol && Symbol.observable || '@@observable', N = 'store', j = 'map', O = 'stack', C = function (e) {\n  return (z(e) || E(e)) && ('kind' in e);\n}, P = function (e) {\n  return function (r) {\n    return C(r) && r.kind === e;\n  };\n}, F = P(N), R = P(\"event\"), _ = P(\"effect\"), D = P(\"domain\"), I = {\n  __proto__: null,\n  unit: C,\n  store: F,\n  event: R,\n  effect: _,\n  domain: D\n}, M = function (e) {\n  throw Error(e);\n}, E = function (e) {\n  return 'object' == typeof e && null !== e;\n}, z = function (e) {\n  return 'function' == typeof e;\n}, T = function (e) {\n  E(e) || z(e) || M('expect first argument be an object');\n}, W = function () {\n  var e = 0;\n  return function () {\n    return (++e).toString(36);\n  };\n}, H = W(), U = W(), B = W(), G = function (e, r) {\n  return e.bind(null, r);\n}, V = function (e, r, n) {\n  return e.bind(null, r, n);\n}, $ = function (e, r, n) {\n  return {\n    id: U(),\n    type: e,\n    data: n,\n    hasRef: r\n  };\n}, J = 0, K = function (e) {\n  var r = e.priority;\n  return $(\"barrier\", 0, {\n    barrierID: ++J,\n    priority: void 0 === r ? \"barrier\" : r\n  });\n}, L = function (e) {\n  var r = e.from,\n      n = void 0 === r ? N : r,\n      t = e.target,\n      a = e.to;\n  return $('mov', n === N, {\n    from: n,\n    store: e.store,\n    to: void 0 === a ? t ? N : O : a,\n    target: t\n  });\n}, Q = {\n  defined: function () {\n    return $('check', 0, {\n      type: 'defined'\n    });\n  },\n  changed: function (e) {\n    return $('check', 1, {\n      type: 'changed',\n      store: e.store\n    });\n  }\n}, X = V($, 'compute', 0), Y = V($, \"filter\", 0), Z = V($, 'run', 0), ee = function (e) {\n  return L({\n    from: O,\n    target: e.store\n  });\n}, re = {\n  __proto__: null,\n  barrier: K,\n  mov: L,\n  check: Q,\n  compute: X,\n  filter: Y,\n  run: Z,\n  update: ee\n}, ne = function (e) {\n  return {\n    id: U(),\n    current: e\n  };\n}, te = function (e) {\n  return e.current;\n}, ae = function (e, r, n) {\n  return (0, r.fn)(e, n.a);\n}, oe = function (e, r, n) {\n  return (0, r.fn)(n.a, e);\n}, ie = function (e, r) {\n  return (0, r.fn)(e);\n}, ue = function (e) {\n  return e.graphite || e;\n}, fe = function (e) {\n  return e.family.owners;\n}, ce = function (e) {\n  return e.family.links;\n}, se = function (e) {\n  return e.stateRef;\n}, le = function (e) {\n  return e.config;\n}, pe = function (e) {\n  return e.ɔ;\n}, de = function (e) {\n  return e.value;\n}, me = function (e) {\n  return e.subscribers;\n}, ve = function (e) {\n  return e.parent;\n}, he = function (e) {\n  return e.forkPage;\n}, ge = function (e, r) {\n  for (var n = ue(e), t = 0; t < r.length; t++) {\n    var a = ue(r[t]);\n    \"domain\" !== n.family.type && (a.family.type = \"crosslink\"), fe(a).push(n), ce(n).push(a);\n  }\n}, ye = null, be = function () {\n  return ye && ye.template;\n}, ke = function (e) {\n  return e && ye && ye.sidRoot && (e = ye.sidRoot + \"ɔ\" + e), e;\n}, we = function (e) {\n  void 0 === e && (e = []);\n  var r = [];\n  if (Array.isArray(e)) for (var n = 0; n < e.length; n++) Array.isArray(e[n]) ? r.push.apply(r, e[n]) : r.push(e[n]);else r.push(e);\n  return r.map(ue);\n}, xe = function (e, r) {\n  var n,\n      t = e.type,\n      a = e.data;\n  e.hasRef && (r[(n = a.store).id] = n), 'mov' === t && a.to === N && (r[(n = a.target).id] = n);\n}, Se = null, Ae = function e(r, n) {\n  if (!r) return n;\n  if (!n) return r;\n  var t,\n      a = r.v.type === n.v.type;\n  return (a && r.v.id > n.v.id || !a && \"sampler\" === r.v.type) && (t = r, r = n, n = t), t = e(r.r, n), r.r = r.l, r.l = t, r;\n}, qe = [], Ne = 0; Ne < 5;) qe.push({\n  first: null,\n  last: null,\n  size: 0\n}), Ne += 1;\n\nvar je,\n    Oe,\n    Ce = function () {\n  for (var e = 0; e < 5; e++) {\n    var r = qe[e];\n\n    if (r.size > 0) {\n      if (2 === e || 3 === e) {\n        r.size -= 1;\n        var n = Se.v;\n        return Se = Ae(Se.l, Se.r), n;\n      }\n\n      1 === r.size && (r.last = null);\n      var t = r.first;\n      return r.first = t.r, r.size -= 1, t.v;\n    }\n  }\n},\n    Pe = function (e, r, n, t, a, o) {\n  return Fe(0, {\n    a: null,\n    b: null,\n    node: n,\n    parent: t,\n    value: a,\n    page: r,\n    forkPage: o\n  }, e);\n},\n    Fe = function (e, r, n, t) {\n  void 0 === t && (t = 0);\n  var a = Re(n),\n      o = qe[a],\n      i = {\n    v: {\n      idx: e,\n      stack: r,\n      type: n,\n      id: t\n    },\n    l: 0,\n    r: 0\n  };\n  2 === a || 3 === a ? Se = Ae(Se, i) : (0 === o.size ? o.first = i : o.last.r = i, o.last = i), o.size += 1;\n},\n    Re = function (e) {\n  switch (e) {\n    case 'child':\n      return 0;\n\n    case 'pure':\n      return 1;\n\n    case \"barrier\":\n      return 2;\n\n    case \"sampler\":\n      return 3;\n\n    case \"effect\":\n      return 4;\n\n    default:\n      return -1;\n  }\n},\n    _e = new Set(),\n    De = 1,\n    Ie = 0,\n    Me = null,\n    Ee = function (e) {\n  je = e;\n},\n    ze = function (e) {\n  Me = e;\n},\n    Te = function (e, r) {\n  if (e) {\n    for (; e && !e.reg[r];) e = ve(e);\n\n    if (e) return e;\n  }\n\n  return null;\n},\n    We = function (e, r, n) {\n  return (Te(e, n) || r).reg[n];\n},\n    He = function (e, r, n) {\n  var t = r.fn;\n\n  try {\n    return t(de(n), e.scope, n);\n  } catch (a) {\n    console.error(a), e.fail = 1;\n  }\n},\n    Ue = function (e, r) {\n  return '' + e.shortName + r;\n},\n    Be = function (e, r) {\n  return null == r ? Ue(e, ' → *') : r;\n},\n    Ge = function (e, r) {\n  T(e), pe(e) && r(le(e), pe(e));\n},\n    Ve = function (e) {\n  var r;\n  return Ge(e[0], function (n, t) {\n    r = n, e = t;\n  }), [e, r];\n},\n    $e = function (e, r) {\n  return e.includes(r);\n},\n    Je = function (e, r) {\n  var n = e.indexOf(r);\n  -1 !== n && e.splice(n, 1);\n},\n    Ke = function (e, r) {\n  Je(e.next, r), Je(fe(e), r), Je(ce(e), r);\n},\n    Le = function e(r, n, t) {\n  var a;\n  r.next.length = 0, r.seq.length = 0, r.scope = null;\n\n  for (var o = ce(r); a = o.pop();) Ke(a, r), (n || t && !r.meta.sample || \"crosslink\" === a.family.type) && e(a, n, 'on' !== a.meta.op && t);\n\n  for (o = fe(r); a = o.pop();) Ke(a, r), t && \"crosslink\" === a.family.type && e(a, n, 'on' !== a.meta.op && t);\n},\n    Qe = function (e) {\n  return e.clear();\n},\n    Xe = function (e, r) {\n  var n = (void 0 === r ? {} : r).deep,\n      t = 0;\n  if (e.ownerSet && e.ownerSet.delete(e), F(e)) Qe(me(e));else if (D(e)) {\n    t = 1;\n    var a = e.history;\n    Qe(a.events), Qe(a.effects), Qe(a.stores), Qe(a.domains);\n  }\n  Le(ue(e), !!n, t);\n},\n    Ye = function (e) {\n  var r = V(Xe, e, void 0);\n  return r.unsubscribe = r, r;\n},\n    Ze = function (e, r, n) {\n  return o({\n    node: n.node,\n    parent: e,\n    child: r,\n    scope: n.scope,\n    meta: n.meta,\n    family: {\n      owners: [e, r],\n      links: r\n    },\n    regional: 1\n  });\n},\n    er = function (e) {\n  var r;\n  Ge(e, function (n, t) {\n    r = n, e = t;\n  });\n  var n = e.from,\n      a = e.to,\n      i = e.meta,\n      u = void 0 === i ? {\n    op: 'forward'\n  } : i;\n  return t(n, 'forward', '\"from\"'), t(a, 'forward', '\"to\"'), r && (u.config = r), Ye(o({\n    parent: n,\n    child: a,\n    meta: u,\n    family: {},\n    regional: 1\n  }));\n},\n    rr = function (e, r) {\n  if (z(r) || M('.watch argument should be a function'), je) {\n    var n = je.nodeMap[ue(e).id];\n    n && (e = n);\n  }\n\n  return Ye(o({\n    scope: {\n      fn: r\n    },\n    node: [Z({\n      fn: ie\n    })],\n    parent: e,\n    meta: {\n      op: 'watch'\n    },\n    family: {\n      owners: e\n    },\n    regional: 1\n  }));\n},\n    nr = function e(r, n) {\n  return E(r) && (e(le(r), n), null != r.name && (E(r.name) ? e(r.name, n) : z(r.name) ? n.handler = r.name : n.name = r.name), r.loc && (n.loc = r.loc), (r.sid || null === r.sid) && (n.sid = r.sid), r.handler && (n.handler = r.handler), r.updateFilter && (n.updateFilter = r.updateFilter), ve(r) && (n.parent = ve(r)), 'strict' in r && (n.strict = r.strict), r.named && (n.named = r.named), e(pe(r), n)), n;\n},\n    tr = function (e, r, n) {\n  void 0 === n && (n = \"event\"), ve(e) && ve(e).hooks[n](r);\n},\n    ar = function (e, r, n, t) {\n  var a = nr({\n    name: t,\n    config: n\n  }, {}),\n      o = \"domain\" === e,\n      i = H(),\n      u = a.parent,\n      c = void 0 === u ? null : u,\n      s = a.sid,\n      l = void 0 === s ? null : s,\n      p = a.strict,\n      d = void 0 === p ? 1 : p,\n      m = a.named,\n      v = void 0 === m ? null : m,\n      h = v || a.name || (o ? '' : i),\n      g = f(h, c),\n      y = {\n    unit: r.kind = e,\n    name: r.shortName = h,\n    sid: r.sid = ke(l),\n    named: v,\n    unitId: r.id = i\n  };\n\n  if (r.parent = c, r.compositeName = g, r.defaultConfig = a, r.thru = function (e) {\n    return e(r);\n  }, r.getType = function () {\n    return g.fullName;\n  }, !o) {\n    r.subscribe = function (e) {\n      return T(e), r.watch(z(e) ? e : function (r) {\n        e.next && e.next(r);\n      });\n    }, r[q] = function () {\n      return r;\n    };\n    var b = be();\n    b && (y.nativeTemplate = b);\n  }\n\n  return Oe = d, y;\n},\n    or = function (e) {\n  return p({\n    named: e\n  });\n},\n    ir = function (e, r, n, t) {\n  return Ze(e, r, {\n    scope: {\n      fn: t\n    },\n    node: [X({\n      fn: ie\n    })],\n    meta: {\n      op: n\n    }\n  });\n},\n    ur = function (e, r, n, t) {\n  var a;\n  E(n) && (a = n, n = n.fn);\n  var o = p(Ue(e, ' →? *'), a);\n  return Ze(e, o, {\n    scope: {\n      fn: n\n    },\n    node: t,\n    meta: {\n      op: r\n    }\n  }), o;\n},\n    fr = function (e, r, n, t, a, o) {\n  var i = se(r),\n      u = [L({\n    store: i,\n    to: \"a\"\n  }), X({\n    fn: t ? oe : ae\n  }), Q.defined(), Q.changed({\n    store: i\n  }), o && Y({\n    fn: function (e, r, n) {\n      return o(e, n.a);\n    }\n  }), ee({\n    store: i\n  })],\n      f = be();\n\n  if (f && (u.unshift(f.loader), u.push(f.upward), F(e))) {\n    var c = se(e);\n    $e(f.plain, c) || ($e(f.closure, c) || f.closure.push(c), i.before || (i.before = []), i.before.push({\n      type: 'closure',\n      of: c\n    }));\n  }\n\n  return Ze(e, r, {\n    scope: {\n      fn: a\n    },\n    node: u,\n    meta: {\n      op: n\n    }\n  });\n},\n    cr = function (e) {\n  return function (r) {\n    return e.apply(void 0, r);\n  };\n},\n    sr = function (e, r, n, t) {\n  var a = e ? function (e) {\n    return e.slice();\n  } : function (e) {\n    return Object.assign({}, e);\n  },\n      o = e ? [] : {},\n      i = be(),\n      f = a(o),\n      s = ne(f),\n      l = ne(1);\n  s.type = e ? 'list' : 'shape', i && i.plain.push(s, l);\n  var p = d(f, {\n    name: n || u(r)\n  });\n  ue(p).meta.isCombine = 1;\n  var m = [Q.defined(), L({\n    store: s,\n    to: \"a\"\n  }), Y({\n    fn: function (e, r, n) {\n      return e !== n.a[r.key];\n    }\n  }), L({\n    store: l,\n    to: 'b'\n  }), X({\n    fn: function (e, r, n) {\n      var t = r.key;\n      n.b && (n.a = (0, r.clone)(n.a)), n.a[t] = e;\n    }\n  }), L({\n    from: \"a\",\n    target: s\n  }), L({\n    from: \"value\",\n    store: 0,\n    target: l\n  }), K({\n    priority: \"barrier\"\n  }), L({\n    from: \"value\",\n    store: 1,\n    target: l\n  }), L({\n    store: s\n  }), t && X({\n    fn: t\n  }), Q.changed({\n    store: se(p)\n  })],\n      v = s.before = [];\n  return c(r, function (e, r) {\n    if (F(e)) {\n      o[r] = e.defaultState, f[r] = e.getState();\n      var n = Ze(e, p, {\n        scope: {\n          key: r,\n          clone: a\n        },\n        node: m,\n        meta: {\n          op: 'combine'\n        }\n      }),\n          t = se(e);\n      v.push({\n        type: 'field',\n        field: r,\n        from: t\n      }), i && ($e(i.plain, t) || n.seq.unshift(i.loader));\n    } else f[r] = o[r] = e;\n  }), p.defaultShape = r, s.after = [t ? {\n    type: j,\n    to: se(p),\n    fn: t\n  } : {\n    type: 'copy',\n    to: se(p)\n  }], i || (p.defaultState = t ? se(p).current = t(f) : o), p;\n},\n    lr = function (e) {\n  var r = e.params,\n      n = e.req,\n      t = e.ok,\n      a = e.anyway,\n      o = e.stack;\n  return function (e) {\n    return i({\n      target: [a, pr],\n      params: [t ? {\n        status: 'done',\n        params: r,\n        result: e\n      } : {\n        status: 'fail',\n        params: r,\n        error: e\n      }, {\n        fn: t ? n.rs : n.rj,\n        value: e\n      }],\n      defer: 1,\n      page: o.page,\n      forkPage: he(o)\n    });\n  };\n},\n    pr = o({\n  node: [Z({\n    fn: function (e) {\n      (0, e.fn)(e.value);\n    }\n  })],\n  meta: {\n    op: 'fx',\n    fx: 'sidechain'\n  }\n}),\n    dr = function (e, r, n) {\n  return e.create = function (r) {\n    return i(e, r), r;\n  }, ue(e).seq.push(X({\n    fn: function (e, r, n) {\n      return n.forkPage = null, e;\n    }\n  })), e.watch(function (e) {\n    ge(n, [e]), r.add(e), e.ownerSet || (e.ownerSet = r), ve(e) || (e.parent = n);\n  }), ge(n, [e]), function (n) {\n    return r.forEach(n), e.watch(n);\n  };\n},\n    mr = ['source', 'clock', 'target'],\n    vr = function (e, r, n, t) {\n  var a = e[r];\n  a && i({\n    target: a,\n    params: Array.isArray(a) ? a.map(function () {\n      return n;\n    }) : n,\n    defer: 1,\n    stack: t\n  });\n};\n\nexports.allSettled = function (e, r) {\n  var n = r.scope,\n      t = r.params;\n  if (!C(e)) return Promise.reject(Error('first argument should be unit'));\n  var a = v();\n  a.parentFork = je;\n  var o = n.graphite.scope.forkInFlightCounter;\n  o.scope.defers.push(a);\n  var u = [n.find(e)],\n      f = [];\n  return _(e) ? f.push({\n    params: t,\n    req: {\n      rs: function (e) {\n        a.value = {\n          status: 'done',\n          value: e\n        };\n      },\n      rj: function (e) {\n        a.value = {\n          status: 'fail',\n          value: e\n        };\n      }\n    }\n  }) : f.push(t), u.push(o), f.push(null), i({\n    target: u,\n    params: f,\n    forkPage: n\n  }), a.req;\n}, exports.attach = function (e) {\n  var r, n;\n  Ge(e, function (r, t) {\n    n = r, e = t;\n  });\n  var t = e.source,\n      a = e.effect,\n      o = e.mapParams;\n  o || (o = t ? function (e, r) {\n    return r;\n  } : function (e) {\n    return e;\n  });\n\n  var u,\n      f = h(e, n),\n      c = ue(f).scope.runner,\n      s = function (e, r, n) {\n    var t,\n        a = e.params,\n        u = e.req,\n        f = r.finally,\n        c = r.effect,\n        s = lr({\n      params: a,\n      req: u,\n      ok: 0,\n      anyway: f,\n      stack: n\n    });\n\n    try {\n      t = o(a, n.a);\n    } catch (l) {\n      return s(l);\n    }\n\n    i({\n      target: c,\n      params: {\n        params: t,\n        req: {\n          rs: lr({\n            params: a,\n            req: u,\n            ok: 1,\n            anyway: f,\n            stack: n\n          }),\n          rj: s\n        }\n      },\n      page: n.page,\n      defer: 1\n    });\n  };\n\n  if (t) {\n    var l;\n    F(t) ? (l = t, ge(t, [f])) : (l = m(t), ge(f, [l]));\n    var p = L({\n      from: N,\n      store: se(l),\n      to: \"a\"\n    });\n    u = [Z({\n      fn: function (e) {\n        return e;\n      }\n    }), p, X({\n      fn: s\n    })], xe(p, c.reg);\n  } else u = [Z({\n    fn: s\n  })];\n\n  return ge(a, [f]), c.scope.effect = a, c.meta.onCopy.push(\"effect\"), (r = c.seq).splice.apply(r, [0, 1].concat(u)), tr(a, f, \"effect\"), f;\n}, exports.clearNode = Xe, exports.combine = m, exports.createApi = function () {\n  for (var e = arguments.length, r = new Array(e), n = 0; n < e; n++) r[n] = arguments[n];\n\n  var t = Ve(r),\n      a = t[0],\n      o = a[0],\n      i = a[1],\n      u = t[1],\n      f = {};\n  return c(i, function (e, r) {\n    var n = f[r] = p(r, {\n      parent: ve(o),\n      config: u\n    });\n    o.on(n, e), tr(o, n);\n  }), f;\n}, exports.createDomain = function e(r, n) {\n  var t = new Set(),\n      a = new Set(),\n      i = new Set(),\n      u = new Set(),\n      f = o({\n    family: {\n      type: \"domain\"\n    },\n    regional: 1\n  }),\n      s = {\n    history: {\n      domains: t,\n      stores: a,\n      effects: i,\n      events: u\n    },\n    graphite: f\n  };\n  f.meta = ar(\"domain\", s, n, r);\n  var l = ['onEvent', 'onEffect', 'onStore', 'onDomain'].map(or),\n      m = l[0],\n      v = l[1],\n      g = l[2],\n      y = l[3];\n  s.hooks = {\n    event: m,\n    effect: v,\n    store: g,\n    domain: y\n  }, s.onCreateEvent = dr(m, u, s), s.onCreateEffect = dr(v, i, s), s.onCreateStore = dr(g, a, s), s.onCreateDomain = dr(y, t, s), s.createEvent = s.event = function (e, r) {\n    return m(p(e, {\n      parent: s,\n      config: r\n    }));\n  }, s.createEffect = s.effect = function (e, r) {\n    return v(h(e, {\n      parent: s,\n      config: r\n    }));\n  }, s.createDomain = s.domain = function (r, n) {\n    return e({\n      name: r,\n      parent: s,\n      config: n\n    });\n  }, s.createStore = s.store = function (e, r) {\n    return g(d(e, {\n      parent: s,\n      config: r\n    }));\n  };\n  var b = ve(s);\n  return b && (c(s.hooks, function (e, r) {\n    er({\n      from: e,\n      to: b.hooks[r]\n    });\n  }), b.hooks.domain(s)), s;\n}, exports.createEffect = h, exports.createEvent = p, exports.createNode = o, exports.createStore = d, exports.createStoreObject = m, exports.fork = function (e, r) {\n  var n = void 0 === r ? {} : r,\n      t = n.values,\n      a = n.handlers;\n  D(e) || M('first argument of fork should be domain');\n  var i = !!t;\n  t = w(t || {}, function (e) {\n    return !F(e) && M('Values map can contain only stores as keys');\n  });\n\n  var u,\n      f,\n      l,\n      p,\n      d,\n      m,\n      v = function (e) {\n    function r(e) {\n      var r = ue(e),\n          t = n.indexOf(r);\n\n      if (-1 === t) {\n        var a = 'unit';\n        e !== r && e.id !== e.shortName && (a = e.shortName), M(a + \" not found in forked scope\");\n      }\n\n      return p[t];\n    }\n\n    var n = S(e),\n        t = new Map(),\n        a = new Set(),\n        i = X({\n      fn: function (e, r, n) {\n        return (!n.node.meta.isCombine || ve(n) && 'combine' !== ve(n).node.meta.op) && a.add(n.node.meta.forkOf.id), e;\n      }\n    }),\n        u = o({\n      scope: {\n        defers: [],\n        inFlight: 0,\n        fxID: 0\n      },\n      node: [X({\n        fn: function (e, r, n) {\n          n.parent ? 'finally' === n.parent.node.meta.named ? r.inFlight -= 1 : (r.inFlight += 1, r.fxID += 1) : r.fxID += 1;\n        }\n      }), K({\n        priority: \"sampler\"\n      }), Z({\n        fn: function (e, r) {\n          var n = r.defers,\n              t = r.fxID;\n          r.inFlight > 0 || 0 === n.length || Promise.resolve().then(function () {\n            r.fxID === t && s(n.splice(0, n.length), function (e) {\n              Ee(e.parentFork), e.rs(e.value);\n            });\n          });\n        }\n      })],\n      meta: {\n        unit: \"forkInFlightCounter\"\n      }\n    }),\n        f = {},\n        l = {},\n        p = n.map(function (e) {\n      var r = e.next,\n          n = e.meta,\n          t = e.scope,\n          a = o({\n        node: e.seq.map(function (e) {\n          return {\n            id: e.id,\n            type: e.type,\n            data: Object.assign({}, e.data),\n            hasRef: e.hasRef\n          };\n        }),\n        child: [].concat(r),\n        meta: Object.assign({\n          forkOf: e\n        }, n),\n        scope: Object.assign({}, t)\n      });\n      return a.family = {\n        type: e.family.type,\n        links: [].concat(ce(e)),\n        owners: [].concat(fe(e))\n      }, f[e.id] = a, n.sid && (l[n.sid] = a), a;\n    }),\n        d = {};\n    return s(p, function (e) {\n      var n = e.reg,\n          a = e.scope,\n          o = e.meta,\n          f = o.onCopy,\n          l = o.op,\n          p = o.unit;\n\n      switch (c(n, function (e, r) {\n        var a = t.get(e);\n        a || t.set(e, a = {\n          id: e.id,\n          current: e.current\n        }), d[r] = n[r] = a;\n      }), f && s(f, function (e) {\n        var n = a[e];\n        a[e] = Array.isArray(n) ? n.map(r) : r(n);\n      }), A(e, function (e, n, t) {\n        t[n] = r(e);\n      }), l || p) {\n        case N:\n          e.meta.wrapped = function (e) {\n            return {\n              kind: N,\n              getState: function () {\n                return e.reg[e.scope.state.id].current;\n              },\n              updates: {\n                watch: G(rr, e)\n              },\n              graphite: e,\n              family: e.family\n            };\n          }(e), e.meta.sid && e.seq.push(i);\n          break;\n\n        case \"effect\":\n          e.next.push(u);\n          break;\n\n        case 'fx':\n          a.finally.next.push(u);\n      }\n    }), {\n      cloneOf: e,\n      changedStores: a,\n      nodeMap: f,\n      sidMap: l,\n      clones: p,\n      find: r,\n      reg: d,\n      getState: function (e) {\n        return r(e).meta.wrapped.getState();\n      },\n      graphite: o({\n        family: {\n          type: \"domain\",\n          links: [u].concat(p)\n        },\n        meta: {\n          unit: 'fork'\n        },\n        scope: {\n          forkInFlightCounter: u\n        }\n      })\n    };\n  }(e);\n\n  if (i && (u = S(e), f = {}, l = {}, p = new Set(), d = new Set(), m = Object.getOwnPropertyNames(t), s(u, function (e) {\n    var r = e.meta.nativeTemplate;\n    c(e.reg, function (e, n) {\n      f[n] = e, r && d.add(n);\n    });\n  }), s(v.clones, function (e) {\n    var r = e.reg,\n        n = e.meta,\n        a = n.sid;\n\n    if (n.unit === N && a && $e(m, a)) {\n      var o = e.scope.state;\n      r[o.id].current = t[a], p.add(o), v.changedStores.add(e.meta.forkOf.id);\n    }\n\n    c(r, function (e, r) {\n      l[r] = e;\n    });\n  }), s(x(k(f), d), function (e) {\n    (function (e, r) {\n      var n = 0;\n\n      if (r && r.before && !p.has(e) && s(r.before, function (r) {\n        switch (r.type) {\n          case j:\n            e.current = r.fn(l[r.from.id].current);\n            break;\n\n          case 'field':\n            var t = l[r.from.id];\n            n || (n = 1, e.current = Array.isArray(e.current) ? [].concat(e.current) : Object.assign({}, e.current)), e.current[r.field] = t.current;\n        }\n      }), r && r.after) {\n        var t = e.current;\n        s(r.after, function (e) {\n          var r = l[e.to.id];\n\n          switch (e.type) {\n            case 'copy':\n              r.current = t;\n              break;\n\n            case j:\n              r.current = e.fn(t);\n          }\n        });\n      }\n    })(l[e], f[e]);\n  })), a) {\n    a = w(a, function (e) {\n      return !_(e) && M(\"Handlers map can contain only effects as keys\");\n    });\n    var h = Object.keys(a);\n    s(v.clones, function (e) {\n      var r = e.scope,\n          n = e.meta;\n      n.sid && $e(h, n.sid) && (r.runner.scope.getHandler = function () {\n        return a[n.sid];\n      });\n    });\n  }\n\n  return v;\n}, exports.forward = er, exports.fromObservable = function (e) {\n  T(e);\n  var r = q in e ? e[q]() : e;\n  r.subscribe || M('expect observable to have .subscribe');\n  var n = p(),\n      t = V(Xe, n, void 0);\n  return r.subscribe({\n    next: n,\n    error: t,\n    complete: t\n  }), n;\n}, exports.guard = function () {\n  for (var e = {\n    op: 'guard'\n  }, r = 'guard', n = arguments.length, a = new Array(n), i = 0; i < n; i++) a[i] = arguments[i];\n\n  var u = Ve(a),\n      f = u[0],\n      c = f[0],\n      s = f[1],\n      l = u[1];\n  l && (e.config = l, l.name && (r = l.name)), s || (c = (s = c).source);\n  var d = s,\n      v = d.filter,\n      h = d.greedy,\n      y = d.clock,\n      k = d.name,\n      w = void 0 === k ? r : k,\n      x = s.target || p(w, e.config),\n      S = C(v),\n      A = 1;\n  return void 0 === c && (t(y, 'guard', 'clock'), Array.isArray(y) && (y = g(y)), c = y, A = 0), A && !C(c) && (c = m(c)), y && (t(y, 'guard', 'clock'), c = b({\n    source: c,\n    clock: y,\n    greedy: h,\n    fn: S ? null : function (e, r) {\n      return {\n        source: e,\n        clock: r\n      };\n    }\n  })), t(x, 'guard', 'target'), S ? b({\n    source: v,\n    clock: c,\n    target: o({\n      node: [Y({\n        fn: function (e) {\n          return e.guard;\n        }\n      }), X({\n        fn: function (e) {\n          return e.data;\n        }\n      })],\n      child: x,\n      meta: e,\n      family: {\n        owners: [c, v, x].concat([].concat(y || [])),\n        links: x\n      },\n      regional: 1\n    }),\n    fn: function (e, r) {\n      return {\n        guard: e,\n        data: r\n      };\n    },\n    greedy: h,\n    name: w\n  }) : (z(v) || M('`filter` should be function or unit'), Ze(c, x, {\n    scope: {\n      fn: v\n    },\n    node: y ? [Y({\n      fn: function (e, r) {\n        return (0, r.fn)(e.source, e.clock);\n      }\n    }), X({\n      fn: function (e) {\n        return e.source;\n      }\n    })] : [Y({\n      fn: ie\n    })],\n    meta: e\n  })), x;\n}, exports.hydrate = function (e, r) {\n  var n = r.values,\n      t = E(e) && e.cloneOf;\n  D(e) || t || M('first argument of hydrate should be domain or scope'), E(n) || M('values property should be an object');\n  var a,\n      o,\n      u = w(n);\n  if (t) a = [], o = [], c(u, function (r, n) {\n    var t = e.sidMap[n];\n    t && (a.push(t), o.push(r), e.changedStores.add(t.meta.forkOf.id));\n  });else {\n    var f = function (e) {\n      var r = e.flatGraphUnits,\n          n = e.values,\n          t = e.collectWatches,\n          a = [],\n          o = [],\n          i = {},\n          u = new Set(),\n          f = Object.getOwnPropertyNames(n);\n      return s(r, function (e) {\n        var r = e.reg,\n            s = e.meta,\n            l = s.op,\n            p = s.sid;\n\n        if (s.unit === N && p && $e(f, p)) {\n          var d = e.scope.state;\n          d.current = n[p], u.add(d);\n        }\n\n        if (t && 'watch' === l) {\n          var m = e.family.owners[0];\n          m.meta.unit === N && (a.push(e), o.push(m.scope.state));\n        }\n\n        c(r, function (e, r) {\n          i[r] = e;\n        });\n      }), s(x(k(i)), function (e) {\n        (function (e) {\n          var r = 0;\n\n          if (e.before && !u.has(e) && s(e.before, function (n) {\n            switch (n.type) {\n              case j:\n                e.current = n.fn(n.from.current);\n                break;\n\n              case 'field':\n                var t = n.from;\n                r || (r = 1, e.current = Array.isArray(e.current) ? [].concat(e.current) : Object.assign({}, e.current)), e.current[n.field] = t.current;\n            }\n          }), e.after) {\n            var n = e.current;\n            s(e.after, function (e) {\n              var r = e.to;\n\n              switch (e.type) {\n                case 'copy':\n                  r.current = n;\n                  break;\n\n                case j:\n                  r.current = e.fn(n);\n              }\n            });\n          }\n        })(i[e]);\n      }), {\n        storeWatches: a,\n        storeWatchesRefs: o\n      };\n    }({\n      flatGraphUnits: S(e),\n      values: u,\n      collectWatches: 1\n    });\n\n    a = f.storeWatches, o = f.storeWatchesRefs.map(function (e) {\n      return e.current;\n    });\n  }\n  i({\n    target: a,\n    params: o,\n    forkPage: t ? e : 0\n  });\n}, exports.is = I, exports.launch = i, exports.merge = g, exports.restore = function (e, r, n) {\n  if (F(e)) return e;\n\n  if (C(e)) {\n    var t,\n        a = ve(e);\n    return R(e) && (t = d(r, {\n      parent: a,\n      name: e.shortName,\n      \"ɔ\": n\n    }).on(e, function (e, r) {\n      return r;\n    })), _(e) && (t = d(r, {\n      parent: a,\n      name: e.shortName,\n      \"ɔ\": n\n    }).on(e.done, function (e, r) {\n      return r.result;\n    })), a && a.hooks.store(t), t;\n  }\n\n  var o = Array.isArray(e) ? [] : {};\n  return c(e, function (e, r) {\n    o[r] = F(e) ? e : d(e, {\n      name: r\n    });\n  }), o;\n}, exports.sample = b, exports.scopeBind = function (e) {\n  je || M('scopeBind cannot be called outside of forked .watch');\n  var r = je,\n      n = je.find(e);\n  return _(e) ? function (e) {\n    var t = v();\n    i({\n      target: n,\n      params: {\n        params: e,\n        req: t\n      },\n      forkPage: r\n    });\n  } : function (e) {\n    return i({\n      target: n,\n      params: e,\n      forkPage: r\n    }), e;\n  };\n}, exports.serialize = function (e, r) {\n  var n = e.changedStores,\n      t = void 0 === r ? {} : r,\n      a = t.ignore,\n      o = void 0 === a ? [] : a,\n      i = t.onlyChanges,\n      u = {};\n  return s(e.clones, function (e) {\n    var r = e.meta,\n        t = e.scope,\n        a = e.reg;\n\n    if (r.unit === N) {\n      var o = r.sid;\n      o && (!i && !r.isCombine || n.has(r.forkOf.id)) && (u[o] = a[t.state.id].current);\n    }\n  }), s(o, function (e) {\n    var r = e.sid;\n    r && delete u[r];\n  }), u;\n}, exports.setStoreName = function (e, r) {\n  var n = f(r, ve(e));\n\n  if (e.shortName = r, e.compositeName) {\n    var t = e.compositeName;\n    t.path = n.path, t.shortName = n.shortName, t.fullName = n.fullName;\n  } else e.compositeName = n;\n}, exports.split = function () {\n  for (var e, r = arguments.length, n = new Array(r), t = 0; t < r; t++) n[t] = arguments[t];\n\n  var a = Ve(n),\n      i = a[0],\n      u = i[0],\n      f = i[1],\n      s = a[1],\n      l = !f;\n  l && (e = u.cases, f = u.match, u = u.source);\n  var d = F(f),\n      m = !C(f) && z(f),\n      v = !d && !m && E(f);\n  e || (e = {}), l || (v || M('match should be an object'), c(f, function (r, n) {\n    e[n] = p(s);\n  }), e.__ = p(s));\n  var h,\n      g = be(),\n      y = new Set([].concat(u, Object.values(e))),\n      b = Object.keys(d || m ? e : f);\n  if (d || m) d && y.add(f), h = [d && K({\n    priority: 'sampler'\n  }), d && L({\n    store: se(f),\n    to: 'a'\n  }), Y({\n    fn: function (e, r, n) {\n      var t = String(d ? n.a : f(e));\n      vr(r, $e(b, t) ? t : '__', e, n);\n    }\n  })];else if (v) {\n    var k = ne({});\n    k.type = 'shape';\n    var w,\n        x = k.before = [],\n        S = [L({\n      store: k,\n      to: \"a\"\n    }), X({\n      fn: function (e, r, n) {\n        n.a[r.key] = e;\n      }\n    })],\n        A = [];\n    c(f, function (e, r) {\n      if (C(e)) {\n        w = 1, A.push(r), y.add(e);\n        var n = Ze(e, [], {\n          node: S,\n          scope: {\n            key: r\n          }\n        });\n\n        if (F(e)) {\n          k.current[r] = e.getState();\n          var t = se(e);\n          x.push({\n            type: 'field',\n            field: r,\n            from: t\n          }), g && ($e(g.plain, t) || n.seq.unshift(g.loader));\n        }\n      }\n    }), w && g && g.plain.push(k), h = [w && K({\n      priority: 'sampler'\n    }), w && L({\n      store: k,\n      to: 'a'\n    }), Y({\n      fn: function (e, r, n) {\n        for (var t = 0; t < b.length; t++) {\n          var a = b[t];\n          if ($e(A, a) ? n.a[a] : f[a](e)) return void vr(r, a, e, n);\n        }\n\n        vr(r, '__', e, n);\n      }\n    })];\n  } else M('expect match to be unit, function or object');\n  if (o({\n    meta: {\n      onCopy: Object.keys(e),\n      op: 'split'\n    },\n    parent: u,\n    scope: e,\n    node: h,\n    family: {\n      type: 'crosslink',\n      owners: Array.from(y)\n    },\n    regional: 1\n  }), !l) return e;\n}, exports.step = re, exports.version = \"21.8.12\", exports.withFactory = function (e) {\n  var r = e.name,\n      n = e.loc,\n      t = e.method,\n      i = e.fn;\n  return a(o({\n    meta: {\n      sidRoot: ke(e.sid),\n      name: r,\n      loc: n,\n      method: t\n    }\n  }), i);\n}, exports.withRegion = a;","map":null,"metadata":{},"sourceType":"script"}