{"ast":null,"code":"function e(e, t, r, a) {\n  (V(e) || J(e)) && ('family' in e || 'graphite' in e) || B(`${t}: expect ${r} to be a unit (store, event or effect)${a}`);\n}\n\nfunction t(t, r, a) {\n  if (Array.isArray(t)) for (let n = 0; n < t.length; n++) e(t[n], r, `${n} item of ${a}`, '');else e(t, r, a, ' or array of units');\n}\n\nfunction r(e, t) {\n  let r = ge(e).meta;\n  Ce = {\n    parent: Ce,\n    value: e,\n    template: r.template || je(),\n    sidRoot: r.sidRoot || Ce && Ce.sidRoot\n  };\n\n  try {\n    return t();\n  } finally {\n    Ce = xe(Ce);\n  }\n}\n\nfunction a({\n  node: e = [],\n  from: t,\n  source: r,\n  parent: a = t || r,\n  to: n,\n  target: o,\n  child: s = n || o,\n  scope: l = {},\n  meta: i = {},\n  family: f = {\n    type: 'regular'\n  },\n  regional: c\n} = {}) {\n  let u = Fe(a),\n      p = Fe(f.links),\n      d = Fe(f.owners),\n      m = [],\n      h = {};\n\n  for (let t = 0; t < e.length; t++) {\n    let r = e[t];\n    r && (m.push(r), Re(r, h));\n  }\n\n  let g = {\n    id: Y(),\n    seq: m,\n    next: Fe(s),\n    meta: i,\n    scope: l,\n    family: {\n      type: f.type || \"crosslink\",\n      links: p,\n      owners: d\n    },\n    reg: h\n  };\n\n  for (let e = 0; e < p.length; e++) ye(p[e]).push(g);\n\n  for (let e = 0; e < d.length; e++) ke(d[e]).push(g);\n\n  for (let e = 0; e < u.length; e++) u[e].next.push(g);\n\n  return c && Ce && Ae(Se(Ce), [g]), g;\n}\n\nfunction n(e, t, r) {\n  let a = Be,\n      n = null,\n      o = He;\n  if (e.target && (t = e.params, r = e.defer, a = 'page' in e ? e.page : a, e.stack && (n = e.stack), o = Ne(e) || o, e = e.target), o && He && o !== He && (He = null), Array.isArray(e)) for (let r = 0; r < e.length; r++) Ee('pure', a, ge(e[r]), n, t[r], o);else Ee('pure', a, ge(e), n, t, o);\n  if (r && !Ge) return;\n  let s,\n      l,\n      i,\n      f,\n      c,\n      u,\n      p = {\n    isRoot: Ge,\n    currentPage: Be,\n    forkPage: He,\n    isWatch: Ue\n  };\n  Ge = 0;\n\n  e: for (; f = $e();) {\n    let {\n      idx: e,\n      stack: t,\n      type: r\n    } = f;\n    i = t.node, Be = c = t.page, He = Ne(t), u = (c || i).reg;\n    let a = {\n      fail: 0,\n      scope: i.scope\n    };\n    s = l = 0;\n\n    for (let n = e; n < i.seq.length && !s; n++) {\n      let o = i.seq[n],\n          f = o.data;\n\n      switch (o.type) {\n        case \"barrier\":\n          {\n            let a = f.barrierID;\n            c && (a = `${c.fullID}_${a}`);\n            let o = f.priority;\n\n            if (n !== e || r !== o) {\n              Te.has(a) || (Te.add(a), ze(n, t, o, a));\n              continue e;\n            }\n\n            Te.delete(a);\n            break;\n          }\n\n        case 'mov':\n          {\n            let e;\n\n            switch (f.from) {\n              case \"stack\":\n                e = Se(t);\n                break;\n\n              case \"a\":\n              case 'b':\n                e = t[f.from];\n                break;\n\n              case \"value\":\n                e = f.store;\n                break;\n\n              case I:\n                u[f.store.id] || (t.page = c = Ke(c, f.store.id), u = c ? c.reg : i.reg), e = pe(u[f.store.id]);\n            }\n\n            switch (f.to) {\n              case \"stack\":\n                t.value = e;\n                break;\n\n              case \"a\":\n              case 'b':\n                t[f.to] = e;\n                break;\n\n              case I:\n                Le(c, i, f.target.id).current = e;\n            }\n\n            break;\n          }\n\n        case 'check':\n          switch (f.type) {\n            case 'defined':\n              l = void 0 === Se(t);\n              break;\n\n            case 'changed':\n              l = Se(t) === pe(Le(c, i, f.store.id));\n          }\n\n          break;\n\n        case \"filter\":\n          l = !Qe(a, f, t);\n          break;\n\n        case 'run':\n          if (n !== e || \"effect\" !== r) {\n            ze(n, t, \"effect\");\n            continue e;\n          }\n\n        case 'compute':\n          Ue = 'watch' === i.meta.op, t.value = Qe(a, f, t), Ue = p.isWatch;\n      }\n\n      s = a.fail || l;\n    }\n\n    if (!s) for (let e = 0; e < i.next.length; e++) Ee('child', c, i.next[e], t, Se(t), Ne(t));\n  }\n\n  Ge = p.isRoot, Be = p.currentPage, He = Ne(p);\n}\n\nfunction o(e, t = \"combine\") {\n  let r = t + '(',\n      a = '',\n      n = 0;\n\n  for (let t in e) {\n    let o = e[t];\n    if (null != o && (r += a, r += E(o) ? o.compositeName.fullName : o.toString()), n += 1, 25 === n) break;\n    a = ', ';\n  }\n\n  return r += ')', r;\n}\n\nfunction s(e, t) {\n  let r = l(t, xe(e));\n  if (e.shortName = t, !e.compositeName) return void (e.compositeName = r);\n  let a = e.compositeName;\n  a.path = r.path, a.shortName = r.shortName, a.fullName = r.fullName;\n}\n\nfunction l(e, t) {\n  let r,\n      a,\n      n,\n      o = e;\n  return t ? (n = t.compositeName, 0 === e.length ? (r = n.path, a = n.fullName) : (r = n.path.concat([e]), a = 0 === n.fullName.length ? e : n.fullName + '/' + e)) : (r = 0 === e.length ? [] : [e], a = e), {\n    shortName: o,\n    fullName: a,\n    path: r\n  };\n}\n\nfunction i(e, t) {\n  for (let r in e) t(e[r], r);\n}\n\nfunction f(e, t) {\n  e.forEach(t);\n}\n\nfunction c(e, t) {\n  let r = (e, ...t) => Be ? ((e, t, r, a) => {\n    let n = Be,\n        o = null;\n    if (t) for (o = Be; o && o.template !== t;) o = xe(o);\n    Je(o);\n    let s = e.create(r, a);\n    return Je(n), s;\n  })(r, o, e, t) : r.create(e, t);\n\n  r.graphite = a({\n    meta: ht(\"event\", r, t, e),\n    regional: 1\n  }), r.create = e => (n(He ? He.find(r) : r, e), e), r.watch = Z(ut, r), r.map = e => {\n    let t, a;\n    V(e) && (t = e, a = e.name, e = e.fn);\n    let n = c(Ye(r, a), t);\n    return yt(r, n, $, e), n;\n  }, r.filter = e => kt(r, \"filter\", e.fn ? e : e.fn, [le({\n    fn: he\n  })]), r.filterMap = e => kt(r, 'filterMap', e, [se({\n    fn: he\n  }), oe.defined()]), r.prepend = e => {\n    let t = c('* → ' + r.shortName, {\n      parent: xe(r)\n    }),\n        a = je();\n    return a && ge(t).seq.push(a.upward), yt(t, r, 'prepend', e), mt(r, t), t;\n  };\n  let o = je();\n  return r;\n}\n\nfunction u(e, r) {\n  function o(e, t) {\n    p.off(e), qe(p).set(e, lt(bt(e, p, 'on', 1, t, m)));\n  }\n\n  let s = ue(e),\n      l = ue(e),\n      i = gt('updates'),\n      f = je();\n  s.after = [{\n    type: 'copy',\n    to: l\n  }], f && f.plain.push(s, l);\n  let c = s.id,\n      p = {\n    subscribers: new Map(),\n    updates: i,\n    defaultState: e,\n    stateRef: s,\n\n    getState() {\n      let e,\n          t = s;\n\n      if (Be) {\n        let t = Be;\n\n        for (; t && !t.reg[c];) t = xe(t);\n\n        t && (e = t);\n      }\n\n      return !e && He && He.reg[c] && (e = He), e && (t = e.reg[c]), pe(t);\n    },\n\n    setState(e) {\n      let t;\n      He && (t = He.nodeMap[ge(p).id]), t || (t = p), n({\n        target: t,\n        params: e,\n        defer: 1\n      });\n    },\n\n    reset(...e) {\n      for (let t of e) p.on(t, () => p.defaultState);\n\n      return p;\n    },\n\n    on(e, r) {\n      if (t(e, '.on', 'first argument'), Array.isArray(e)) for (let t of e) o(t, r);else o(e, r);\n      return p;\n    },\n\n    off(e) {\n      let t = qe(p).get(e);\n      return t && (t(), qe(p).delete(e)), p;\n    },\n\n    map(e, t) {\n      let r, a, n;\n      V(e) && (r = e, a = e.name, t = e.firstState, e = e.fn);\n      let o = p.getState(),\n          l = je();\n      l ? n = null : void 0 !== o && (n = e(o, t));\n      let i = u(n, {\n        name: Ye(p, a),\n        config: r,\n        strict: 0\n      }),\n          f = bt(p, i, $, 0, e);\n      return be(i).before = [{\n        type: $,\n        fn: e,\n        from: s\n      }], l && (tt(l.plain, s) || tt(f.seq, l.loader) || f.seq.unshift(l.loader)), i;\n    },\n\n    watch(e, t) {\n      if (!t || !E(e)) {\n        let t = ut(p, e),\n            r = je();\n        return r ? r.watch.push({\n          of: s,\n          fn: e\n        }) : e(p.getState()), t;\n      }\n\n      return J(t) || B('second argument should be a function'), e.watch(e => t(p.getState(), e));\n    }\n\n  },\n      d = ht(I, p, r),\n      m = p.defaultConfig.updateFilter;\n  return p.graphite = a({\n    scope: {\n      state: s\n    },\n    node: [oe.defined(), oe.changed({\n      store: l\n    }), m && ne({\n      store: l,\n      to: \"a\"\n    }), m && le({\n      fn: (e, t, {\n        a: r\n      }) => m(e, r)\n    }), fe({\n      store: s\n    }), fe({\n      store: l\n    })],\n    child: i,\n    meta: d,\n    regional: 1\n  }), dt && void 0 === e && B(\"current state can't be undefined, use null instead\"), Ae(p, [i]), p;\n}\n\nfunction p(...e) {\n  let t, r, a;\n  Ze(e[0], (t, r) => {\n    a = t, e = r;\n  });\n  let n,\n      o,\n      s = e[e.length - 1];\n\n  if (J(s) ? (r = e.slice(0, -1), t = s) : r = e, 1 === r.length) {\n    let e = r[0];\n    W(e) || (n = e, o = 1);\n  }\n\n  return o || (n = r, t && (t = vt(t))), V(n) || B('shape should be an object'), wt(Array.isArray(n), n, a, t);\n}\n\nfunction d() {\n  let e = {};\n  return e.req = new Promise((t, r) => {\n    e.rs = t, e.rj = r;\n  }), e.req.catch(() => {}), e;\n}\n\nfunction m(e, t) {\n  let r = c(e, t),\n      o = r.defaultConfig.handler || (() => B(`no handler used in ${r.getType()}`)),\n      s = ge(r);\n\n  s.meta.onCopy = ['runner'], s.meta.unit = r.kind = \"effect\", r.use = e => (J(e) || B('.use argument should be a function'), o = e, r);\n  let l = r.finally = gt('finally'),\n      i = r.done = l.filterMap({\n    named: 'done',\n\n    fn({\n      status: e,\n      params: t,\n      result: r\n    }) {\n      if ('done' === e) return {\n        params: t,\n        result: r\n      };\n    }\n\n  }),\n      f = r.fail = l.filterMap({\n    named: 'fail',\n\n    fn({\n      status: e,\n      params: t,\n      error: r\n    }) {\n      if ('fail' === e) return {\n        params: t,\n        error: r\n      };\n    }\n\n  }),\n      p = r.doneData = i.map({\n    named: 'doneData',\n    fn: ({\n      result: e\n    }) => e\n  }),\n      m = r.failData = f.map({\n    named: 'failData',\n    fn: ({\n      error: e\n    }) => e\n  }),\n      h = a({\n    scope: {\n      getHandler: r.use.getCurrent = () => o,\n      finally: l\n    },\n    node: [ie({\n      fn({\n        params: e,\n        req: t\n      }, {\n        finally: r,\n        getHandler: a\n      }, n) {\n        let o,\n            s = St({\n          params: e,\n          req: t,\n          ok: 1,\n          anyway: r,\n          stack: n\n        }),\n            l = St({\n          params: e,\n          req: t,\n          ok: 0,\n          anyway: r,\n          stack: n\n        });\n\n        try {\n          o = a()(e);\n        } catch (e) {\n          return void l(e);\n        }\n\n        V(o) && J(o.then) ? o.then(s, l) : s(o);\n      }\n\n    })],\n    meta: {\n      op: 'fx',\n      fx: 'runner',\n      onCopy: ['finally']\n    }\n  });\n  s.scope.runner = h, s.seq.push(se({\n    fn: (e, t, r) => xe(r) ? {\n      params: e,\n      req: {\n        rs(e) {},\n\n        rj(e) {}\n\n      }\n    } : e\n  }), ie({\n    fn: (e, {\n      runner: t\n    }, r) => (n({\n      target: t,\n      params: e,\n      defer: 1,\n      forkPage: Ne(r)\n    }), e.params)\n  })), r.create = e => {\n    let t = d(),\n        a = {\n      params: e,\n      req: t\n    };\n\n    if (He) {\n      if (!Ue) {\n        let e = He;\n        t.req.finally(() => {\n          Ve(e);\n        }).catch(() => {});\n      }\n\n      n(He.find(r), a);\n    } else n(r, a);\n\n    return t.req;\n  };\n  let g = r.inFlight = u(0, {\n    named: 'inFlight'\n  }).on(r, e => e + 1).on(l, e => e - 1),\n      y = r.pending = g.map({\n    fn: e => e > 0,\n    named: 'pending'\n  });\n  return Ae(r, [l, i, f, p, m, y, g, h]), r;\n}\n\nfunction h(e) {\n  let t;\n  Ze(e, (r, a) => {\n    t = r, e = a;\n  });\n  let {\n    source: r,\n    effect: a,\n    mapParams: o\n  } = e;\n  o || (o = r ? (e, t) => t : e => e);\n\n  let s,\n      l = m(e, t),\n      {\n    runner: i\n  } = ge(l).scope,\n      f = ({\n    params: e,\n    req: t\n  }, {\n    finally: r,\n    effect: a\n  }, s) => {\n    let l,\n        i = St({\n      params: e,\n      req: t,\n      ok: 0,\n      anyway: r,\n      stack: s\n    });\n\n    try {\n      l = o(e, s.a);\n    } catch (e) {\n      return i(e);\n    }\n\n    n({\n      target: a,\n      params: {\n        params: l,\n        req: {\n          rs: St({\n            params: e,\n            req: t,\n            ok: 1,\n            anyway: r,\n            stack: s\n          }),\n          rj: i\n        }\n      },\n      page: s.page,\n      defer: 1\n    });\n  };\n\n  if (r) {\n    let e;\n    W(r) ? (e = r, Ae(r, [l])) : (e = p(r), Ae(l, [e]));\n    let t = ne({\n      from: I,\n      store: be(e),\n      to: \"a\"\n    });\n    s = [ie({\n      fn: e => e\n    }), t, se({\n      fn: f\n    })], Re(t, i.reg);\n  } else s = [ie({\n    fn: f\n  })];\n\n  return Ae(a, [l]), i.scope.effect = a, i.meta.onCopy.push(\"effect\"), i.seq.splice(0, 1, ...s), mt(a, l, \"effect\"), l;\n}\n\nfunction g(...e) {\n  let [[t, r], a] = et(e),\n      n = {};\n  return i(r, (e, r) => {\n    let o = n[r] = c(r, {\n      parent: xe(t),\n      config: a\n    });\n    t.on(o, e), mt(t, o);\n  }), n;\n}\n\nfunction y(e, t) {\n  let r = new Set(),\n      n = new Set(),\n      o = new Set(),\n      s = new Set(),\n      l = a({\n    family: {\n      type: \"domain\"\n    },\n    regional: 1\n  }),\n      f = {\n    history: {\n      domains: r,\n      stores: n,\n      effects: o,\n      events: s\n    },\n    graphite: l\n  };\n  l.meta = ht(\"domain\", f, t, e);\n  let [p, d, h, g] = ['onEvent', 'onEffect', 'onStore', 'onDomain'].map(gt);\n  f.hooks = {\n    event: p,\n    effect: d,\n    store: h,\n    domain: g\n  }, f.onCreateEvent = xt(p, s, f), f.onCreateEffect = xt(d, o, f), f.onCreateStore = xt(h, n, f), f.onCreateDomain = xt(g, r, f), f.createEvent = f.event = (e, t) => p(c(e, {\n    parent: f,\n    config: t\n  })), f.createEffect = f.effect = (e, t) => d(m(e, {\n    parent: f,\n    config: t\n  })), f.createDomain = f.domain = (e, t) => y({\n    name: e,\n    parent: f,\n    config: t\n  }), f.createStore = f.store = (e, t) => h(u(e, {\n    parent: f,\n    config: t\n  }));\n  let k = xe(f);\n  return k && (i(f.hooks, (e, t) => {\n    ct({\n      from: e,\n      to: k.hooks[t]\n    });\n  }), k.hooks.domain(f)), f;\n}\n\nfunction k(e) {\n  K(e);\n  let t = _ in e ? e[_]() : e;\n  t.subscribe || B('expect observable to have .subscribe');\n  let r = c(),\n      a = ee(st, r, void 0);\n  return t.subscribe({\n    next: r,\n    error: a,\n    complete: a\n  }), r;\n}\n\nfunction b(e, r) {\n  let a = c(r || o(e, 'merge'));\n  return t(e, 'merge', 'first argument'), ct({\n    from: e,\n    to: a,\n    meta: {\n      op: 'merge'\n    }\n  }), a;\n}\n\nfunction v(...e) {\n  let r,\n      n,\n      o,\n      s,\n      [[l, i, d], m] = et(e);\n  void 0 === i && V(l) && (e => {\n    let t = 0;\n    return f(Nt, r => {\n      r in e && (null == e[r] && B(`sample: ${r} should be defined`), t = 1);\n    }), t;\n  })(l) && (i = l.clock, d = l.fn, s = l.greedy, r = l.target, n = l.name, o = l.sid, l = l.source);\n  let h = 1;\n  void 0 === l && (t(i, 'sample', 'clock'), Array.isArray(i) && (i = b(i)), l = i, h = 0), h && !E(l) && (l = p(l)), void 0 === i && (i = l), t(i, 'sample', 'clock'), n = m || n || l.shortName;\n  let g = je(),\n      y = !!r;\n  r || (W(l) && W(i) ? r = u(d ? d(pe(be(l)), pe(be(i))) : pe(be(l)), {\n    name: n,\n    sid: o\n  }) : (r = c(n), g && ge(r).seq.push(g.loader)));\n  let k = y && E(r) && ge(r).meta.nativeTemplate;\n\n  if (W(l)) {\n    let e = be(l);\n    Ae(l, [ft(i, r, {\n      scope: {\n        fn: d,\n        targetTemplate: k\n      },\n      node: [g && g.loader, !s && ae({\n        priority: \"sampler\"\n      }), ne({\n        store: e,\n        to: d ? \"a\" : \"stack\"\n      }), d && se({\n        fn: me\n      }), g && y && g.upward],\n      meta: {\n        op: \"sample\",\n        sample: I\n      }\n    })]), g && (tt(g.plain, e) || tt(g.closure, e) || g.closure.push(e));\n  } else {\n    let e = ue(0),\n        t = ue(),\n        n = ue();\n    g && g.plain.push(e, t, n), a({\n      parent: l,\n      node: [fe({\n        store: t\n      }), ne({\n        from: \"value\",\n        store: 1,\n        target: e\n      })],\n      family: {\n        owners: [l, r, i],\n        links: r\n      },\n      meta: {\n        op: \"sample\",\n        sample: 'source'\n      },\n      regional: 1\n    }), Ae(l, [ft(i, r, {\n      scope: {\n        fn: d,\n        targetTemplate: k\n      },\n      node: [g && g.loader, fe({\n        store: n\n      }), ne({\n        store: e\n      }), le({\n        fn: e => e\n      }), !s && ae({\n        priority: \"sampler\"\n      }), ne({\n        store: t\n      }), ne({\n        store: n,\n        to: \"a\"\n      }), d && se({\n        fn: de\n      }), g && y && g.upward],\n      meta: {\n        op: \"sample\",\n        sample: 'clock'\n      }\n    })]);\n  }\n\n  return r;\n}\n\nfunction w(...e) {\n  let r = {\n    op: 'guard'\n  },\n      n = 'guard',\n      [[o, s], l] = et(e);\n  l && (r.config = l, l.name && (n = l.name)), s || (s = o, o = s.source);\n  let {\n    filter: i,\n    greedy: f,\n    clock: u,\n    name: d = n\n  } = s,\n      m = s.target || c(d, r.config),\n      h = E(i),\n      g = 1;\n  return void 0 === o && (t(u, 'guard', 'clock'), Array.isArray(u) && (u = b(u)), o = u, g = 0), g && !E(o) && (o = p(o)), u && (t(u, 'guard', 'clock'), o = v({\n    source: o,\n    clock: u,\n    greedy: f,\n    fn: h ? null : (e, t) => ({\n      source: e,\n      clock: t\n    })\n  })), t(m, 'guard', 'target'), h ? v({\n    source: i,\n    clock: o,\n    target: a({\n      node: [le({\n        fn: ({\n          guard: e\n        }) => e\n      }), se({\n        fn: ({\n          data: e\n        }) => e\n      })],\n      child: m,\n      meta: r,\n      family: {\n        owners: [o, i, m, ...[].concat(u || [])],\n        links: m\n      },\n      regional: 1\n    }),\n    fn: (e, t) => ({\n      guard: e,\n      data: t\n    }),\n    greedy: f,\n    name: d\n  }) : (J(i) || B('`filter` should be function or unit'), ft(o, m, {\n    scope: {\n      fn: i\n    },\n    node: u ? [le({\n      fn: ({\n        source: e,\n        clock: t\n      }, {\n        fn: r\n      }) => r(e, t)\n    }), se({\n      fn: ({\n        source: e\n      }) => e\n    })] : [le({\n      fn: he\n    })],\n    meta: r\n  })), m;\n}\n\nfunction S(e, t, r) {\n  if (W(e)) return e;\n\n  if (E(e)) {\n    let a,\n        n = xe(e);\n    return T(e) && (a = u(t, {\n      parent: n,\n      name: e.shortName,\n      ɔ: r\n    }).on(e, (e, t) => t)), H(e) && (a = u(t, {\n      parent: n,\n      name: e.shortName,\n      ɔ: r\n    }).on(e.done, (e, {\n      result: t\n    }) => t)), n && n.hooks.store(a), a;\n  }\n\n  let a = Array.isArray(e) ? [] : {};\n  return i(e, (e, t) => {\n    a[t] = W(e) ? e : u(e, {\n      name: t\n    });\n  }), a;\n}\n\nfunction q(...e) {\n  let t,\n      [[r, n], o] = et(e),\n      s = !n;\n  s && (t = r.cases, n = r.match, r = r.source);\n  let l = W(n),\n      f = !E(n) && J(n),\n      u = !l && !f && V(n);\n  t || (t = {}), s || (u || B('match should be an object'), i(n, (e, r) => {\n    t[r] = c(o);\n  }), t.__ = c(o));\n  let p,\n      d = je(),\n      m = new Set([].concat(r, Object.values(t))),\n      h = Object.keys(l || f ? t : n);\n  if (l || f) l && m.add(n), p = [l && ae({\n    priority: 'sampler'\n  }), l && ne({\n    store: be(n),\n    to: 'a'\n  }), le({\n    fn(e, t, r) {\n      let a = String(l ? r.a : n(e));\n      At(t, tt(h, a) ? a : '__', e, r);\n    }\n\n  })];else if (u) {\n    let e = ue({});\n    e.type = 'shape';\n    let t,\n        r = e.before = [],\n        a = [ne({\n      store: e,\n      to: \"a\"\n    }), se({\n      fn(e, {\n        key: t\n      }, {\n        a: r\n      }) {\n        r[t] = e;\n      }\n\n    })],\n        o = [];\n    i(n, (n, s) => {\n      if (E(n)) {\n        t = 1, o.push(s), m.add(n);\n        let l = ft(n, [], {\n          node: a,\n          scope: {\n            key: s\n          }\n        });\n\n        if (W(n)) {\n          e.current[s] = n.getState();\n          let t = be(n);\n          r.push({\n            type: 'field',\n            field: s,\n            from: t\n          }), d && (tt(d.plain, t) || l.seq.unshift(d.loader));\n        }\n      }\n    }), t && d && d.plain.push(e), p = [t && ae({\n      priority: 'sampler'\n    }), t && ne({\n      store: e,\n      to: 'a'\n    }), le({\n      fn(e, t, r) {\n        for (let a = 0; a < h.length; a++) {\n          let s = h[a];\n          if (tt(o, s) ? r.a[s] : n[s](e)) return void At(t, s, e, r);\n        }\n\n        At(t, '__', e, r);\n      }\n\n    })];\n  } else B('expect match to be unit, function or object');\n  if (a({\n    meta: {\n      onCopy: Object.keys(t),\n      op: 'split'\n    },\n    parent: r,\n    scope: t,\n    node: p,\n    family: {\n      type: 'crosslink',\n      owners: Array.from(m)\n    },\n    regional: 1\n  }), !s) return t;\n}\n\nfunction x(e, {\n  values: t\n}) {\n  let r = V(e) && e.cloneOf;\n  G(e) || r || B('first argument of hydrate should be domain or scope'), V(t) || B('values property should be an object');\n  let a,\n      o,\n      s = j(t);\n  if (r) a = [], o = [], i(s, (t, r) => {\n    let n = e.sidMap[r];\n    n && (a.push(n), o.push(t), e.changedStores.add(n.meta.forkOf.id));\n  });else {\n    let t = (({\n      flatGraphUnits: e,\n      values: t,\n      collectWatches: r\n    }) => {\n      let a = [],\n          n = [],\n          o = {},\n          s = new Set(),\n          l = Object.getOwnPropertyNames(t);\n      return f(e, e => {\n        let {\n          reg: f\n        } = e,\n            {\n          op: c,\n          unit: u,\n          sid: p\n        } = e.meta;\n\n        if (u === I && p && tt(l, p)) {\n          let {\n            state: r\n          } = e.scope;\n          r.current = t[p], s.add(r);\n        }\n\n        if (r && 'watch' === c) {\n          let t = e.family.owners[0];\n          t.meta.unit === I && (a.push(e), n.push(t.scope.state));\n        }\n\n        i(f, (e, t) => {\n          o[t] = e;\n        });\n      }), f(P(N(o)), e => {\n        (e => {\n          let t = 0;\n          if (e.before && !s.has(e) && f(e.before, r => {\n            switch (r.type) {\n              case $:\n                e.current = r.fn(r.from.current);\n                break;\n\n              case 'field':\n                {\n                  let a = r.from;\n                  t || (t = 1, e.current = Array.isArray(e.current) ? [...e.current] : { ...e.current\n                  }), e.current[r.field] = a.current;\n                  break;\n                }\n            }\n          }), !e.after) return;\n          let r = e.current;\n          f(e.after, e => {\n            let t = e.to;\n\n            switch (e.type) {\n              case 'copy':\n                t.current = r;\n                break;\n\n              case $:\n                t.current = e.fn(r);\n            }\n          });\n        })(o[e]);\n      }), {\n        storeWatches: a,\n        storeWatchesRefs: n\n      };\n    })({\n      flatGraphUnits: R(e),\n      values: s,\n      collectWatches: 1\n    });\n\n    a = t.storeWatches, o = t.storeWatchesRefs.map(({\n      current: e\n    }) => e);\n  }\n  n({\n    target: a,\n    params: o,\n    forkPage: r ? e : 0\n  });\n}\n\nfunction N(e) {\n  let t = Object.values(e),\n      r = {};\n  return f(t, ({\n    id: e\n  }) => {\n    r[e] = [];\n  }), f(t, ({\n    id: e,\n    before: t,\n    after: a\n  }) => {\n    t && f(t, t => {\n      r[t.from.id].push(e);\n    }), a && f(a, t => {\n      r[e].push(t.to.id);\n    });\n  }), r;\n}\n\nfunction A({\n  clones: e,\n  changedStores: t\n}, {\n  ignore: r = [],\n  onlyChanges: a\n} = {}) {\n  let n = {};\n  return f(e, ({\n    meta: e,\n    scope: r,\n    reg: o\n  }) => {\n    if (e.unit !== I) return;\n    let {\n      sid: s\n    } = e;\n    s && (!a && !e.isCombine || t.has(e.forkOf.id)) && (n[s] = o[r.state.id].current);\n  }), f(r, ({\n    sid: e\n  }) => {\n    e && delete n[e];\n  }), n;\n}\n\nfunction C(e) {\n  He || B('scopeBind cannot be called outside of forked .watch');\n  let t = He,\n      r = He.find(e);\n  return H(e) ? e => {\n    let a = d();\n    n({\n      target: r,\n      params: {\n        params: e,\n        req: a\n      },\n      forkPage: t\n    });\n  } : e => (n({\n    target: r,\n    params: e,\n    forkPage: t\n  }), e);\n}\n\nfunction j(e, t = () => {}) {\n  if (e instanceof Map) {\n    let r = {};\n\n    for (let [a, n] of e) E(a) || B('Map key should be a unit'), t(a, n), r[a.sid] = n;\n\n    return r;\n  }\n\n  return e;\n}\n\nfunction O(e, {\n  values: t,\n  handlers: r\n} = {}) {\n  G(e) || B('first argument of fork should be domain');\n  let n = !!t;\n  t = j(t || {}, e => !W(e) && B('Values map can contain only stores as keys'));\n\n  let o = (e => {\n    function t(e) {\n      let t = ge(e),\n          a = r.indexOf(t);\n\n      if (-1 === a) {\n        let r = 'unit';\n        e !== t && e.id !== e.shortName && (r = e.shortName), B(`${r} not found in forked scope`);\n      }\n\n      return p[a];\n    }\n\n    let r = R(e),\n        n = new Map(),\n        o = new Set(),\n        s = se({\n      fn: (e, t, r) => ((!r.node.meta.isCombine || xe(r) && 'combine' !== xe(r).node.meta.op) && o.add(r.node.meta.forkOf.id), e)\n    }),\n        l = a({\n      scope: {\n        defers: [],\n        inFlight: 0,\n        fxID: 0\n      },\n      node: [se({\n        fn(e, t, r) {\n          r.parent ? 'finally' === r.parent.node.meta.named ? t.inFlight -= 1 : (t.inFlight += 1, t.fxID += 1) : t.fxID += 1;\n        }\n\n      }), ae({\n        priority: \"sampler\"\n      }), ie({\n        fn(e, t) {\n          let {\n            inFlight: r,\n            defers: a,\n            fxID: n\n          } = t;\n          r > 0 || 0 === a.length || Promise.resolve().then(() => {\n            t.fxID === n && f(a.splice(0, a.length), e => {\n              Ve(e.parentFork), e.rs(e.value);\n            });\n          });\n        }\n\n      })],\n      meta: {\n        unit: \"forkInFlightCounter\"\n      }\n    }),\n        c = {},\n        u = {},\n        p = r.map(e => {\n      let {\n        seq: t,\n        next: r,\n        meta: n,\n        scope: o\n      } = e,\n          s = a({\n        node: t.map(e => ({\n          id: e.id,\n          type: e.type,\n          data: { ...e.data\n          },\n          hasRef: e.hasRef\n        })),\n        child: [...r],\n        meta: {\n          forkOf: e,\n          ...n\n        },\n        scope: { ...o\n        }\n      });\n      return s.family = {\n        type: e.family.type,\n        links: [...ke(e)],\n        owners: [...ye(e)]\n      }, c[e.id] = s, n.sid && (u[n.sid] = s), s;\n    }),\n        d = {};\n    return f(p, e => {\n      let {\n        reg: r,\n        scope: a,\n        meta: {\n          onCopy: o,\n          op: c,\n          unit: u\n        }\n      } = e;\n\n      switch (i(r, (e, t) => {\n        let a = n.get(e);\n        a || (a = {\n          id: e.id,\n          current: e.current\n        }, n.set(e, a)), d[t] = r[t] = a;\n      }), o && f(o, e => {\n        let r = a[e];\n        a[e] = Array.isArray(r) ? r.map(t) : t(r);\n      }), D(e, (e, r, a) => {\n        a[r] = t(e);\n      }), c || u) {\n        case I:\n          e.meta.wrapped = (e => ({\n            kind: I,\n            getState: () => e.reg[e.scope.state.id].current,\n            updates: {\n              watch: Z(ut, e)\n            },\n            graphite: e,\n            family: e.family\n          }))(e), e.meta.sid && e.seq.push(s);\n          break;\n\n        case M:\n          e.next.push(l);\n          break;\n\n        case 'fx':\n          a.finally.next.push(l);\n      }\n    }), {\n      cloneOf: e,\n      changedStores: o,\n      nodeMap: c,\n      sidMap: u,\n      clones: p,\n      find: t,\n      reg: d,\n      getState: e => t(e).meta.wrapped.getState(),\n      graphite: a({\n        family: {\n          type: \"domain\",\n          links: [l, ...p]\n        },\n        meta: {\n          unit: 'fork'\n        },\n        scope: {\n          forkInFlightCounter: l\n        }\n      })\n    };\n  })(e);\n\n  if (n && (() => {\n    let r = R(e),\n        a = {},\n        n = {},\n        s = new Set(),\n        l = new Set(),\n        c = Object.getOwnPropertyNames(t);\n    f(r, ({\n      reg: e,\n      meta: t\n    }) => {\n      let {\n        nativeTemplate: r\n      } = t;\n      i(e, (e, t) => {\n        a[t] = e, r && l.add(t);\n      });\n    }), f(o.clones, e => {\n      let {\n        reg: r\n      } = e,\n          {\n        unit: a,\n        sid: l\n      } = e.meta;\n\n      if (a === I && l && tt(c, l)) {\n        let {\n          state: a\n        } = e.scope;\n        r[a.id].current = t[l], s.add(a), o.changedStores.add(e.meta.forkOf.id);\n      }\n\n      i(r, (e, t) => {\n        n[t] = e;\n      });\n    }), f(P(N(a), l), e => {\n      ((e, t) => {\n        let r = 0;\n        if (t && t.before && !s.has(e) && f(t.before, t => {\n          switch (t.type) {\n            case $:\n              e.current = t.fn(n[t.from.id].current);\n              break;\n\n            case 'field':\n              {\n                let a = n[t.from.id];\n                r || (r = 1, e.current = Array.isArray(e.current) ? [...e.current] : { ...e.current\n                }), e.current[t.field] = a.current;\n                break;\n              }\n          }\n        }), !t || !t.after) return;\n        let a = e.current;\n        f(t.after, e => {\n          let t = n[e.to.id];\n\n          switch (e.type) {\n            case 'copy':\n              t.current = a;\n              break;\n\n            case $:\n              t.current = e.fn(a);\n          }\n        });\n      })(n[e], a[e]);\n    });\n  })(), r) {\n    r = j(r, e => !H(e) && B(\"Handlers map can contain only effects as keys\"));\n    let e = Object.keys(r);\n    f(o.clones, ({\n      scope: t,\n      meta: a\n    }) => {\n      a.sid && tt(e, a.sid) && (t.runner.scope.getHandler = () => r[a.sid]);\n    });\n  }\n\n  return o;\n}\n\nfunction P(e, t) {\n  function r(e) {\n    s[e] = 1;\n    let t = a[e];\n\n    for (let e = 0; e < t.length; e++) {\n      let a = t[e];\n      s[a] || o[a] || r(a);\n    }\n\n    s[e] = 0, o[e] = 1, n.push(e);\n  }\n\n  let a = {};\n\n  for (let t in e) a[t] = [...new Set(e[t])];\n\n  let n = [],\n      o = {},\n      s = {};\n\n  for (let e in a) o[e] || s[e] || r(e);\n\n  if (n.reverse(), t && t.size > 0) {\n    let e,\n        r = [],\n        o = [...t];\n\n    for (; e = o.shift();) r.push(e), f(a[e], e => {\n      tt(r, e) || tt(o, e) || o.push(e);\n    });\n\n    f(r, e => {\n      rt(n, e);\n    });\n  }\n\n  return n;\n}\n\nfunction F(e, {\n  scope: t,\n  params: r\n}) {\n  if (!E(e)) return Promise.reject(Error('first argument should be unit'));\n  let a = d();\n  a.parentFork = He;\n  let {\n    forkInFlightCounter: o\n  } = t.graphite.scope;\n  o.scope.defers.push(a);\n  let s = [t.find(e)],\n      l = [];\n  return H(e) ? l.push({\n    params: r,\n    req: {\n      rs(e) {\n        a.value = {\n          status: 'done',\n          value: e\n        };\n      },\n\n      rj(e) {\n        a.value = {\n          status: 'fail',\n          value: e\n        };\n      }\n\n    }\n  }) : l.push(r), s.push(o), l.push(null), n({\n    target: s,\n    params: l,\n    forkPage: t\n  }), a.req;\n}\n\nfunction R(e) {\n  let t = [];\n  return function e(r) {\n    tt(t, r) || (t.push(r), D(r, e));\n  }(ge(e)), t;\n}\n\nfunction D(e, t) {\n  let r = e.meta.unit;\n  'fork' !== r && \"forkInFlightCounter\" !== r && (f(e.next, t), f(ye(e), t), f(ke(e), t));\n}\n\nlet _ = 'undefined' != typeof Symbol && Symbol.observable || '@@observable',\n    I = 'store',\n    M = 'effect',\n    $ = 'map',\n    E = e => (J(e) || V(e)) && 'kind' in e;\n\nconst z = e => t => E(t) && t.kind === e;\n\nlet W = z(I),\n    T = z(\"event\"),\n    H = z(M),\n    G = z(\"domain\");\nvar U = {\n  __proto__: null,\n  unit: E,\n  store: W,\n  event: T,\n  effect: H,\n  domain: G\n};\n\nlet B = e => {\n  throw Error(e);\n},\n    V = e => 'object' == typeof e && null !== e,\n    J = e => 'function' == typeof e,\n    K = e => {\n  V(e) || J(e) || B('expect first argument be an object');\n};\n\nconst L = () => {\n  let e = 0;\n  return () => (++e).toString(36);\n};\n\nlet Q = L(),\n    X = L(),\n    Y = L(),\n    Z = (e, t) => e.bind(null, t),\n    ee = (e, t, r) => e.bind(null, t, r);\n\nconst te = (e, t, r) => ({\n  id: X(),\n  type: e,\n  data: r,\n  hasRef: t\n});\n\nlet re = 0,\n    ae = ({\n  priority: e = \"barrier\"\n}) => te(\"barrier\", 0, {\n  barrierID: ++re,\n  priority: e\n}),\n    ne = ({\n  from: e = I,\n  store: t,\n  target: r,\n  to: a = r ? I : \"stack\"\n}) => te('mov', e === I, {\n  from: e,\n  store: t,\n  to: a,\n  target: r\n}),\n    oe = {\n  defined: () => te('check', 0, {\n    type: 'defined'\n  }),\n  changed: ({\n    store: e\n  }) => te('check', 1, {\n    type: 'changed',\n    store: e\n  })\n},\n    se = ee(te, 'compute', 0),\n    le = ee(te, \"filter\", 0),\n    ie = ee(te, 'run', 0),\n    fe = ({\n  store: e\n}) => ne({\n  from: \"stack\",\n  target: e\n});\n\nvar ce = {\n  __proto__: null,\n  barrier: ae,\n  mov: ne,\n  check: oe,\n  compute: se,\n  filter: le,\n  run: ie,\n  update: fe\n};\n\nlet ue = e => ({\n  id: X(),\n  current: e\n}),\n    pe = ({\n  current: e\n}) => e,\n    de = (e, {\n  fn: t\n}, {\n  a: r\n}) => t(e, r),\n    me = (e, {\n  fn: t\n}, {\n  a: r\n}) => t(r, e),\n    he = (e, {\n  fn: t\n}) => t(e),\n    ge = e => e.graphite || e,\n    ye = e => e.family.owners,\n    ke = e => e.family.links,\n    be = e => e.stateRef,\n    ve = e => e.config,\n    we = e => e.ɔ,\n    Se = e => e.value,\n    qe = e => e.subscribers,\n    xe = e => e.parent,\n    Ne = e => e.forkPage,\n    Ae = (e, t) => {\n  let r = ge(e);\n\n  for (let e = 0; e < t.length; e++) {\n    let a = ge(t[e]);\n    \"domain\" !== r.family.type && (a.family.type = \"crosslink\"), ye(a).push(r), ke(r).push(a);\n  }\n},\n    Ce = null,\n    je = () => Ce && Ce.template,\n    Oe = e => (e && Ce && Ce.sidRoot && (e = `${Ce.sidRoot}ɔ${e}`), e),\n    Pe = ({\n  sid: e,\n  name: t,\n  loc: n,\n  method: o,\n  fn: s\n}) => r(a({\n  meta: {\n    sidRoot: Oe(e),\n    name: t,\n    loc: n,\n    method: o\n  }\n}), s);\n\nconst Fe = (e = []) => {\n  let t = [];\n  if (Array.isArray(e)) for (let r = 0; r < e.length; r++) Array.isArray(e[r]) ? t.push(...e[r]) : t.push(e[r]);else t.push(e);\n  return t.map(ge);\n};\n\nlet Re = ({\n  hasRef: e,\n  type: t,\n  data: r\n}, a) => {\n  let n;\n  e && (n = r.store, a[n.id] = n), 'mov' === t && r.to === I && (n = r.target, a[n.id] = n);\n},\n    De = null;\n\nconst _e = (e, t) => {\n  if (!e) return t;\n  if (!t) return e;\n  let r,\n      a = e.v.type === t.v.type;\n  return (a && e.v.id > t.v.id || !a && \"sampler\" === e.v.type) && (r = e, e = t, t = r), r = _e(e.r, t), e.r = e.l, e.l = r, e;\n},\n      Ie = [];\n\nlet Me = 0;\n\nfor (; Me < 5;) Ie.push({\n  first: null,\n  last: null,\n  size: 0\n}), Me += 1;\n\nconst $e = () => {\n  for (let e = 0; e < 5; e++) {\n    let t = Ie[e];\n\n    if (t.size > 0) {\n      if (2 === e || 3 === e) {\n        t.size -= 1;\n        let e = De.v;\n        return De = _e(De.l, De.r), e;\n      }\n\n      1 === t.size && (t.last = null);\n      let r = t.first;\n      return t.first = r.r, t.size -= 1, r.v;\n    }\n  }\n},\n      Ee = (e, t, r, a, n, o) => ze(0, {\n  a: null,\n  b: null,\n  node: r,\n  parent: a,\n  value: n,\n  page: t,\n  forkPage: o\n}, e),\n      ze = (e, t, r, a = 0) => {\n  let n = We(r),\n      o = Ie[n],\n      s = {\n    v: {\n      idx: e,\n      stack: t,\n      type: r,\n      id: a\n    },\n    l: 0,\n    r: 0\n  };\n  2 === n || 3 === n ? De = _e(De, s) : (0 === o.size ? o.first = s : o.last.r = s, o.last = s), o.size += 1;\n},\n      We = e => {\n  switch (e) {\n    case 'child':\n      return 0;\n\n    case 'pure':\n      return 1;\n\n    case \"barrier\":\n      return 2;\n\n    case \"sampler\":\n      return 3;\n\n    case M:\n      return 4;\n\n    default:\n      return -1;\n  }\n},\n      Te = new Set();\n\nlet He,\n    Ge = 1,\n    Ue = 0,\n    Be = null,\n    Ve = e => {\n  He = e;\n},\n    Je = e => {\n  Be = e;\n};\n\nconst Ke = (e, t) => {\n  if (e) {\n    for (; e && !e.reg[t];) e = xe(e);\n\n    if (e) return e;\n  }\n\n  return null;\n},\n      Le = (e, t, r) => (Ke(e, r) || t).reg[r],\n      Qe = (e, {\n  fn: t\n}, r) => {\n  try {\n    return t(Se(r), e.scope, r);\n  } catch (t) {\n    console.error(t), e.fail = 1;\n  }\n};\n\nlet Xe = (e, t) => '' + e.shortName + t,\n    Ye = (e, t) => null == t ? Xe(e, ' → *') : t,\n    Ze = (e, t) => {\n  K(e), we(e) && t(ve(e), we(e));\n},\n    et = e => {\n  let t;\n  return Ze(e[0], (r, a) => {\n    t = r, e = a;\n  }), [e, t];\n},\n    tt = (e, t) => e.includes(t),\n    rt = (e, t) => {\n  let r = e.indexOf(t);\n  -1 !== r && e.splice(r, 1);\n};\n\nconst at = (e, t) => {\n  rt(e.next, t), rt(ye(e), t), rt(ke(e), t);\n},\n      nt = (e, t, r) => {\n  let a;\n  e.next.length = 0, e.seq.length = 0, e.scope = null;\n  let n = ke(e);\n\n  for (; a = n.pop();) at(a, e), (t || r && !e.meta.sample || \"crosslink\" === a.family.type) && nt(a, t, 'on' !== a.meta.op && r);\n\n  for (n = ye(e); a = n.pop();) at(a, e), r && \"crosslink\" === a.family.type && nt(a, t, 'on' !== a.meta.op && r);\n},\n      ot = e => e.clear();\n\nlet st = (e, {\n  deep: t\n} = {}) => {\n  let r = 0;\n  if (e.ownerSet && e.ownerSet.delete(e), W(e)) ot(qe(e));else if (G(e)) {\n    r = 1;\n    let t = e.history;\n    ot(t.events), ot(t.effects), ot(t.stores), ot(t.domains);\n  }\n  nt(ge(e), !!t, r);\n},\n    lt = e => {\n  let t = ee(st, e, void 0);\n  return t.unsubscribe = t, t;\n},\n    ft = (e, t, {\n  node: r,\n  scope: n,\n  meta: o\n}) => a({\n  node: r,\n  parent: e,\n  child: t,\n  scope: n,\n  meta: o,\n  family: {\n    owners: [e, t],\n    links: t\n  },\n  regional: 1\n}),\n    ct = e => {\n  let r;\n  Ze(e, (t, a) => {\n    r = t, e = a;\n  });\n  let {\n    from: n,\n    to: o,\n    meta: s = {\n      op: 'forward'\n    }\n  } = e;\n  return t(n, 'forward', '\"from\"'), t(o, 'forward', '\"to\"'), r && (s.config = r), lt(a({\n    parent: n,\n    child: o,\n    meta: s,\n    family: {},\n    regional: 1\n  }));\n},\n    ut = (e, t) => {\n  if (J(t) || B('.watch argument should be a function'), He) {\n    let t = He.nodeMap[ge(e).id];\n    t && (e = t);\n  }\n\n  return lt(a({\n    scope: {\n      fn: t\n    },\n    node: [ie({\n      fn: he\n    })],\n    parent: e,\n    meta: {\n      op: 'watch'\n    },\n    family: {\n      owners: e\n    },\n    regional: 1\n  }));\n};\n\nconst pt = (e, t) => (V(e) && (pt(ve(e), t), null != e.name && (V(e.name) ? pt(e.name, t) : J(e.name) ? t.handler = e.name : t.name = e.name), e.loc && (t.loc = e.loc), (e.sid || null === e.sid) && (t.sid = e.sid), e.handler && (t.handler = e.handler), e.updateFilter && (t.updateFilter = e.updateFilter), xe(e) && (t.parent = xe(e)), 'strict' in e && (t.strict = e.strict), e.named && (t.named = e.named), pt(we(e), t)), t);\n\nlet dt,\n    mt = (e, t, r = \"event\") => {\n  xe(e) && xe(e).hooks[r](t);\n},\n    ht = (e, t, r, a) => {\n  let n = pt({\n    name: a,\n    config: r\n  }, {}),\n      o = \"domain\" === e,\n      s = Q(),\n      {\n    parent: i = null,\n    sid: f = null,\n    strict: c = 1,\n    named: u = null\n  } = n,\n      p = u || n.name || (o ? '' : s),\n      d = l(p, i),\n      m = {\n    unit: t.kind = e,\n    name: t.shortName = p,\n    sid: t.sid = Oe(f),\n    named: u,\n    unitId: t.id = s\n  };\n\n  if (t.parent = i, t.compositeName = d, t.defaultConfig = n, t.thru = e => e(t), t.getType = () => d.fullName, !o) {\n    t.subscribe = e => (K(e), t.watch(J(e) ? e : t => {\n      e.next && e.next(t);\n    })), t[_] = () => t;\n    let e = je();\n    e && (m.nativeTemplate = e);\n  }\n\n  return dt = c, m;\n},\n    gt = e => c({\n  named: e\n});\n\nconst yt = (e, t, r, a) => ft(e, t, {\n  scope: {\n    fn: a\n  },\n  node: [se({\n    fn: he\n  })],\n  meta: {\n    op: r\n  }\n}),\n      kt = (e, t, r, a) => {\n  let n;\n  V(r) && (n = r, r = r.fn);\n  let o = c(Xe(e, ' →? *'), n);\n  return ft(e, o, {\n    scope: {\n      fn: r\n    },\n    node: a,\n    meta: {\n      op: t\n    }\n  }), o;\n},\n      bt = (e, t, r, a, n, o) => {\n  let s = be(t),\n      l = [ne({\n    store: s,\n    to: \"a\"\n  }), se({\n    fn: a ? me : de\n  }), oe.defined(), oe.changed({\n    store: s\n  }), o && le({\n    fn: (e, t, {\n      a: r\n    }) => o(e, r)\n  }), fe({\n    store: s\n  })],\n      i = je();\n\n  if (i && (l.unshift(i.loader), l.push(i.upward), W(e))) {\n    let t = be(e);\n    tt(i.plain, t) || (tt(i.closure, t) || i.closure.push(t), s.before || (s.before = []), s.before.push({\n      type: 'closure',\n      of: t\n    }));\n  }\n\n  return ft(e, t, {\n    scope: {\n      fn: n\n    },\n    node: l,\n    meta: {\n      op: r\n    }\n  });\n},\n      vt = e => t => e(...t),\n      wt = (e, t, r, a) => {\n  let n = e ? e => e.slice() : e => ({ ...e\n  }),\n      s = e ? [] : {},\n      l = je(),\n      f = n(s),\n      c = ue(f),\n      p = ue(1);\n  c.type = e ? 'list' : 'shape', l && l.plain.push(c, p);\n  let d = u(f, {\n    name: r || o(t)\n  });\n  ge(d).meta.isCombine = 1;\n  let m = [oe.defined(), ne({\n    store: c,\n    to: \"a\"\n  }), le({\n    fn: (e, {\n      key: t\n    }, {\n      a: r\n    }) => e !== r[t]\n  }), ne({\n    store: p,\n    to: 'b'\n  }), se({\n    fn(e, {\n      clone: t,\n      key: r\n    }, a) {\n      a.b && (a.a = t(a.a)), a.a[r] = e;\n    }\n\n  }), ne({\n    from: \"a\",\n    target: c\n  }), ne({\n    from: \"value\",\n    store: 0,\n    target: p\n  }), ae({\n    priority: \"barrier\"\n  }), ne({\n    from: \"value\",\n    store: 1,\n    target: p\n  }), ne({\n    store: c\n  }), a && se({\n    fn: a\n  }), oe.changed({\n    store: be(d)\n  })],\n      h = c.before = [];\n  return i(t, (e, t) => {\n    if (!W(e)) return void (f[t] = s[t] = e);\n    s[t] = e.defaultState, f[t] = e.getState();\n    let r = ft(e, d, {\n      scope: {\n        key: t,\n        clone: n\n      },\n      node: m,\n      meta: {\n        op: 'combine'\n      }\n    }),\n        a = be(e);\n    h.push({\n      type: 'field',\n      field: t,\n      from: a\n    }), l && (tt(l.plain, a) || r.seq.unshift(l.loader));\n  }), d.defaultShape = t, c.after = [a ? {\n    type: $,\n    to: be(d),\n    fn: a\n  } : {\n    type: 'copy',\n    to: be(d)\n  }], l || (d.defaultState = a ? be(d).current = a(f) : s), d;\n};\n\nlet St = ({\n  params: e,\n  req: t,\n  ok: r,\n  anyway: a,\n  stack: o\n}) => s => n({\n  target: [a, qt],\n  params: [r ? {\n    status: 'done',\n    params: e,\n    result: s\n  } : {\n    status: 'fail',\n    params: e,\n    error: s\n  }, {\n    fn: r ? t.rs : t.rj,\n    value: s\n  }],\n  defer: 1,\n  page: o.page,\n  forkPage: Ne(o)\n}),\n    qt = a({\n  node: [ie({\n    fn({\n      fn: e,\n      value: t\n    }) {\n      e(t);\n    }\n\n  })],\n  meta: {\n    op: 'fx',\n    fx: 'sidechain'\n  }\n});\n\nconst xt = (e, t, r) => (e.create = t => (n(e, t), t), ge(e).seq.push(se({\n  fn: (e, t, r) => (r.forkPage = null, e)\n})), e.watch(e => {\n  Ae(r, [e]), t.add(e), e.ownerSet || (e.ownerSet = t), xe(e) || (e.parent = r);\n}), Ae(r, [e]), r => (t.forEach(r), e.watch(r))),\n      Nt = ['source', 'clock', 'target'],\n      At = (e, t, r, a) => {\n  let o = e[t];\n  o && n({\n    target: o,\n    params: Array.isArray(o) ? o.map(() => r) : r,\n    defer: 1,\n    stack: a\n  });\n},\n      Ct = \"21.8.12\";\n\nexport { F as allSettled, h as attach, st as clearNode, p as combine, g as createApi, y as createDomain, m as createEffect, c as createEvent, a as createNode, u as createStore, p as createStoreObject, O as fork, ct as forward, k as fromObservable, w as guard, x as hydrate, U as is, n as launch, b as merge, S as restore, v as sample, C as scopeBind, A as serialize, s as setStoreName, q as split, ce as step, Ct as version, Pe as withFactory, r as withRegion };","map":{"version":3,"sources":["effector/is.ts","effector/region.ts","effector/createNode.ts","effector/tag.ts","effector/kernel.ts","effector/naming.ts","effector/collection.ts","effector/createUnit.ts","effector/combine.ts","effector/defer.ts","effector/createEffect.ts","effector/attach.ts","effector/createApi.ts","effector/createDomain.ts","effector/fromObservable.ts","effector/merge.ts","effector/sample.ts","effector/guard.ts","effector/restore.ts","effector/split.ts","effector/fork.ts","effector/observable.ts","effector/validate.ts","effector/throw.ts","effector/id.ts","effector/bind.ts","effector/step.ts","effector/stateRef.ts","effector/caller.ts","effector/getter.ts","effector/own.ts","effector/config.ts","effector/clearNode.ts","effector/subscription.ts","effector/forward.ts","effector/watch.ts"],"names":["isObject","value","isFunction","assertObject","throwError","assertNodeSetItem","method","valueName","reason","assertNodeSet","Array","isArray","i","length","regionStack","readTemplate","template","readSidRoot","sid","sidRoot","withRegion","unit","cb","unitMeta","getGraph","meta","parent","getParent","withFactory","name","loc","fn","createNode","arrifyNodes","list","result","push","map","addToReg","hasRef","type","data","reg","store","id","to","STORE","target","node","from","source","child","scope","family","familyRaw","regional","sources","links","owners","seq","item","nextNodeID","next","getOwners","getLinks","own","getValue","EFFECT","MAP","heap","merge","a","b","ret","isSameType","v","r","l","queue","ix","first","last","size","deleteMin","pushFirstHeapItem","page","forkPage","pushHeap","idx","stack","priority","getPriority","bucket","t","barriers","Set","isRoot","isWatch","currentPage","setForkPage","newForkPage","setCurrentPage","newPage","getPageForRef","getPageRef","launch","payload","upsert","pageForLaunch","stackForLaunch","forkPageForLaunch","params","defer","getForkPage","lastStartedState","stop","skip","kernelLoop","local","fail","stepn","step","barrierID","fullID","has","add","delete","readRef","current","undefined","tryRun","op","err","console","error","joinName","tag","shortName","mapName","unitObjectName","objOrArr","comma","key","is","compositeName","fullName","toString","setStoreName","rawName","createName","currentComposite","path","composite","concat","forIn","obj","includes","removeItem","pos","indexOf","splice","forEach","normalizeConfig","part","config","getConfig","handler","updateFilter","strict","named","getNestedConfig","applyParentHook","hookType","hooks","isStrict","initUnit","kind","rawConfigA","rawConfigB","isDomain","nextUnitID","unitId","defaultConfig","thru","getType","subscribe","observer","watch","upd","observableSymbol","nativeTemplate","createNamedEvent","createEvent","createComputation","createLinkNode","callStack","createEventFiltration","event","mapped","args","oldPage","create","nameOrConfig","maybeConfig","graphite","find","bind","watchUnit","filter","filterMap","defined","prepend","contramapped","upward","createStore","defaultState","props","plainState","createStateRef","oldState","updates","after","plain","plainStateId","subscribers","Map","stateRef","getState","targetRef","reachedPage","setState","state","nodeMap","reset","units","on","nodeSet","onEvent","off","currentSubscription","getSubscribers","get","firstState","lastResult","storeState","innerStore","linkNode","updateStore","getStoreState","before","loader","unshift","eventOrFn","subscription","of","set","createSubscription","changed","update","_","stateFirst","storeRef","callARegStack","callStackAReg","ref","closure","combine","stores","onConfigNesting","injectedData","userConfig","rawHandler","slice","structStoreShape","shapeReady","spreadArgs","storeCombination","clone","stateNew","rawShape","isFresh","isCombine","childRef","field","defaultShape","createDefer","req","Promise","rs","rj","catch","createEffect","instance","onCopy","use","anyway","finally","done","status","doneData","failData","effectRunner","getHandler","getCurrent","onResolve","onSettled","ok","onReject","then","fx","runner","savedFork","inFlight","x","pending","amount","sidechain","attach","injected","effect","mapParams","attached","runnerSteps","runnerFn","computedParams","readStateRef","createApi","setters","metadata","processArgsToConfig","createHook","trigger","acc","res","ownerSet","hook","createDomain","domains","effects","events","history","domain","onCreateEvent","onCreateEffect","onCreateStore","onCreateDomain","forward","fromObservable","observable","observableItem","disposer","bind2","clearNode","complete","sampleConfigFields","atLeastOneFieldExists","sample","clock","greedy","needToCombine","isUpward","targetTemplate","sourceRef","hasSource","sourceState","clockState","guard","filterIsUnit","restore","ɔ","launchCase","scopeTargets","split","targets","match","knownCases","cases","matchIsUnit","matchIsFunction","matchIsShape","__","Object","values","caseNames","keys","splitterSeq","String","lastValues","updaterSteps","needBarrier","storeOrFn","updater","caseName","hydrate","isScope","cloneOf","normalizedValues","normalizeValues","storeWatches","storeWatchesRefs","val","sidMap","changedStores","forkOf","fillResult","fillValues","flatGraphUnits","flatGraph","collectWatches","refsMap","predefinedRefs","valuesSidList","getOwnPropertyNames","owner","createRefGraph","toposort","execRef","cmd","items","refGraph","serialize","clones","ignore","onlyChanges","scopeBind","savedForkPage","localUnit","assertEach","fork","handlers","needToFill","forked","cloneGraph","handlerKeys","sourceList","sourceRefsMap","templateOwnedRefs","rawGraph","graph","visited","temp","topologicalSortHelper","reverse","processed","ignored","shift","neighbors","n","allSettled","start","ctx","reject","Error","parentFork","forkInFlightCounter","defers","launchUnits","launchParams","traverse","forEachRelatedNode","refs","fxID","putStoreToChanged","resolve","newRef","copyField","origValue","findClone","siblings","wrapped","wrapStore","index","unitName","Symbol","message","idCount","nextStepID","arg","nextBarrierID","barrier","mov","check","compute","run","opts","ownerUnit","link","rawConfig","removeFromNode","currentNode","targetNode","clearNodeNormalized","deep","isDomainUnit","pop","clearMap","clear","unsubscribe","forkedNode"],"mappings":"AAaA,SAASK,CAAT,CAA2BJ,CAA3B,EAAuCK,CAAvC,EAAuDC,CAAvD,EAA0EC,CAA1E,EAA0EA;AAAAA,GAClER,CAAAA,CAASC,CAATD,CAAAA,IAAoBE,CAAAA,CAAWD,CAAXC,CAD8CM,MACrB,YAAYP,CAAZ,IAAwB,cAAcA,CADjBO,KAEtEJ,CAAAA,CAAY,GAAEE,CAAAA,YAAkBC,CAAAA,yCAAkDC,CAAAA,EAAlFJ,CAFsEI;AAKnE;;AAAA,SAASC,CAAT,CAAuBR,CAAvB,EAAmCK,CAAnC,EAAmDC,CAAnD,EAAmDA;AAAAA,MACpDG,KAAAA,CAAMC,OAAND,CAAcT,CAAdS,CADoDH,EACtCN,KACX,IAAIW,CAAAA,GAAI,CADGX,EACAW,CAAAA,GAAIX,CAAAA,CAAMY,MADVZ,EACkBW,CAAAA,EADlBX,EAGdI,CAAAA,CADaJ,CAAAA,CAAMW,CAANX,CACbI,EAAwBC,CAAxBD,EAAiC,GAAEO,CAAAA,YAAaL,CAAAA,EAAhDF,EAA6D,EAA7DA,CAAAA,CAJoDE,KAOtDF,CAAAA,CAAkBJ,CAAlBI,EAAyBC,CAAzBD,EAAiCE,CAAjCF,EAA4C,oBAA5CA,CAAAA;ACLG;;AAAA,SAASe,CAAT,CAAoBC,CAApB,EAA+BC,CAA/B,EAA+BA;AAAAA,MAC9BC,CAAAA,GAAWC,EAAAA,CAASH,CAATG,CAAAA,CAAeC,IADIH;AAEpCR,EAAAA,EAAAA,GAAc;AACZY,IAAAA,MAAAA,EAAQZ,EADI;AAEZb,IAAAA,KAAAA,EAAOoB,CAFK;AAGZL,IAAAA,QAAAA,EAAUO,CAAAA,CAASP,QAATO,IAAqBR,EAAAA,EAHnB;AAIZI,IAAAA,OAAAA,EAASI,CAAAA,CAASJ,OAATI,IAAqBT,EAAAA,IAAeA,EAAAA,CAAYK;AAJ7C,GAAdL;;AAI2DK,MAAAA;AAAAA,WAGlDG,CAAAA,EAHkDH;AAGlDG,GAHkDH,SAGlDG;AAEPR,IAAAA,EAAAA,GAAca,EAAAA,CAAUb,EAAVa,CAAdb;AAAwBA;ACIrB;;AAAA,SAASkB,CAAT,CAASA;AAAWgB,EAAAA,IAAAA,EACzBA,CAAAA,GAAO,EADOhB;AAAWgB,EAAAA,IAAAA,EAEzBC,CAFcjB;AAAWgB,EAAAA,MAAAA,EAGzBE,CAHclB;AAAWgB,EAAAA,MAAAA,EAIzBtB,CAAAA,GAASuB,CAAAA,IAAQC,CAJHlB;AAAWgB,EAAAA,EAAAA,EAKzBH,CALcb;AAAWgB,EAAAA,MAAAA,EAMzBD,CANcf;AAAWgB,EAAAA,KAAAA,EAOzBG,CAAAA,GAAQN,CAAAA,IAAME,CAPAf;AAAWgB,EAAAA,KAAAA,EAQzBI,CAAAA,GAAQ,EARMpB;AAAWgB,EAAAA,IAAAA,EASzBvB,CAAAA,GAAO,EATOO;AAUdqB,EAAAA,MAAAA,EAAQC,CAAAA,GAAY;AAACd,IAAAA,IAAAA,EAAM;AAAP,GAVNR;AAAWgB,EAAAA,QAAAA,EAWzBO;AAXcvB,IA4BZ,EA5BG,EA4BH;AAAA,MACIwB,CAAAA,GAAUvB,EAAAA,CAAYP,CAAZO,CADd;AAAA,MAEIwB,CAAAA,GAAQxB,EAAAA,CAAYqB,CAAAA,CAAUG,KAAtBxB,CAFZ;AAAA,MAGIyB,CAAAA,GAASzB,EAAAA,CAAYqB,CAAAA,CAAUI,MAAtBzB,CAHb;AAAA,MAII0B,CAAAA,GAAa,EAJjB;AAAA,MAKIjB,CAAAA,GAAgC,EALpC;;AAKoC,OACjC,IAAI9B,CAAAA,GAAI,CADyB,EACtBA,CAAAA,GAAIoC,CAAAA,CAAKnC,MADa,EACLD,CAAAA,EADK,EACA;AAAA,QAC9BgD,CAAAA,GAAOZ,CAAAA,CAAKpC,CAALoC,CADuB;AAE/BY,IAAAA,CAAAA,KACLD,CAAAA,CAAIvB,IAAJuB,CAASC,CAATD,GACArB,EAAAA,CAASsB,CAATtB,EAAeI,CAAfJ,CAFKsB,CAAAA;AAEUlB;;AAAAA,MAEXP,CAAAA,GAAe;AACnBS,IAAAA,EAAAA,EAAIiB,CAAAA,EADe;AAEnBF,IAAAA,GAAAA,EAAAA,CAFmB;AAGnBG,IAAAA,IAAAA,EAAM7B,EAAAA,CAAYkB,CAAZlB,CAHa;AAInBR,IAAAA,IAAAA,EAAAA,CAJmB;AAKnB2B,IAAAA,KAAAA,EAAAA,CALmB;AAMnBC,IAAAA,MAAAA,EAAQ;AACNb,MAAAA,IAAAA,EAAMc,CAAAA,CAAUd,IAAVc,IC7Ea,WD4Eb;AAENG,MAAAA,KAAAA,EAAAA,CAFM;AAGNC,MAAAA,MAAAA,EAAAA;AAHM,KANW;AAWnBhB,IAAAA,GAAAA,EAAAA;AAXmB,GAFJA;;AAafA,OAEG,IAAI9B,CAAAA,GAAI,CAFX8B,EAEc9B,CAAAA,GAAI6C,CAAAA,CAAM5C,MAFxB6B,EAEgC9B,CAAAA,EAFhC8B,EAGAqB,EAAAA,CAAUN,CAAAA,CAAM7C,CAAN6C,CAAVM,CAAAA,CAAoB3B,IAApB2B,CAAyB5B,CAAzB4B;;AAAyB5B,OAEtB,IAAIvB,CAAAA,GAAI,CAFcuB,EAEXvB,CAAAA,GAAI8C,CAAAA,CAAO7C,MAFAsB,EAEQvB,CAAAA,EAFRuB,EAGzB6B,EAAAA,CAASN,CAAAA,CAAO9C,CAAP8C,CAATM,CAAAA,CAAoB5B,IAApB4B,CAAyB7B,CAAzB6B;;AAAyB7B,OAEtB,IAAIvB,CAAAA,GAAI,CAFcuB,EAEXvB,CAAAA,GAAI4C,CAAAA,CAAQ3C,MAFDsB,EAESvB,CAAAA,EAFTuB,EAGzBqB,CAAAA,CAAQ5C,CAAR4C,CAAAA,CAAWM,IAAXN,CAAgBpB,IAAhBoB,CAAqBrB,CAArBqB;;AAAqBrB,SAEnBoB,CAAAA,IAAYzC,EAAZyC,IACFU,EAAAA,CAAIC,EAAAA,CAASpD,EAAToD,CAAJD,EAA2B,CAAC9B,CAAD,CAA3B8B,CADEV,EAGGpB,CALgBA;AEwIlB;;AAAA,SAASsE,CAAT,CAAgBpF,CAAhB,EAA2BqF,CAA3B,EAA0CC,CAA1C,EAA0CA;AAAAA,MAC3CC,CAAAA,GAAgBV,EAD2BS;AAAAA,MAE3CE,CAAAA,GAAiB,IAF0BF;AAAAA,MAG3CG,CAAAA,GAAoBxB,EAHuBqB;AAGvBrB,MACpBjE,CAAAA,CAAK0B,MAAL1B,KACFqF,CAAAA,GAAUrF,CAAAA,CAAK0F,MAAfL,EACAC,CAAAA,GAAStF,CAAAA,CAAK2F,KADdN,EAEAE,CAAAA,GAAgB,UAAUvF,CAAV,GAAiBA,CAAAA,CAAKgE,IAAtB,GAA6BuB,CAF7CF,EAGIrF,CAAAA,CAAI,KAAJA,KAAawF,CAAAA,GAAiBxF,CAAAA,CAAI,KAAlCA,CAHJqF,EAIAI,CAAAA,GAAoBG,EAAAA,CAAY5F,CAAZ4F,CAAAA,IAAqBH,CAJzCJ,EAKArF,CAAAA,GAAOA,CAAAA,CAAK0B,MANV1B,GAQAyF,CAAAA,IAAqBxB,EAArBwB,IAAiCA,CAAAA,KAAsBxB,EAAvDwB,KACFxB,EAAAA,GAAW,IADTwB,CARAzF,EAWAX,KAAAA,CAAMC,OAAND,CAAcW,CAAdX,CAZoB4E,EAYNjE,KACX,IAAIT,CAAAA,GAAI,CADGS,EACAT,CAAAA,GAAIS,CAAAA,CAAKR,MADTQ,EACiBT,CAAAA,EADjBS,EAEd+D,EAAAA,CACE,MADFA,EAEEwB,CAFFxB,EAGE5D,EAAAA,CAASH,CAAAA,CAAKT,CAALS,CAATG,CAHF4D,EAIEyB,CAJFzB,EAKEsB,CAAAA,CAAQ9F,CAAR8F,CALFtB,EAME0B,CANF1B,CAAAA,CAdoBE,KAwBtBF,EAAAA,CACE,MADFA,EAEEwB,CAFFxB,EAGE5D,EAAAA,CAASH,CAATG,CAHF4D,EAIEyB,CAJFzB,EAKEsB,CALFtB,EAME0B,CANF1B,CAAAA;AAME0B,MAGAH,CAAAA,IAAAA,CAAWX,EAHXc,EAGmB;AAAA,MAInBK,CAJmB;AAAA,MAKnBC,CALmB;AAAA,MAMnBpE,CANmB;AAAA,MAOnB/C,CAPmB;AAAA,MAQnBoF,CARmB;AAAA,MASnB3C,CATmB;AAAA,MAEjBwE,CAAAA,GAAmB;AAAClB,IAAAA,MAAAA,EAAAA,EAAD;AAASE,IAAAA,WAAAA,EAAAA,EAAT;AAAsBZ,IAAAA,QAAAA,EAAAA,EAAtB;AAAgCW,IAAAA,OAAAA,EAAAA;AAAhC,GAFF;AAGvBD,EAAAA,EAAAA,GAAS,CAATA;;AAOAqB,EAAAA,CAAAA,EAAY,OAAQpH,CAAAA,GAAQkF,EAAAA,EAAhB,GAA8B;AAAA,QAAA;AAClCK,MAAAA,GAAAA,EAACA,CADiC;AAClCA,MAAAA,KAAAA,EAAMC,CAD4B;AAClCD,MAAAA,IAAAA,EAAahD;AADqB,QACbvC,CADa;AAExC+C,IAAAA,CAAAA,GAAOyC,CAAAA,CAAMzC,IAAbA,EACAkD,EAAAA,GAAcb,CAAAA,GAAOI,CAAAA,CAAMJ,IAD3BrC,EAEAsC,EAAAA,GAAW2B,EAAAA,CAAYxB,CAAZwB,CAFXjE,EAGAN,CAAAA,GAAAA,CAAO2C,CAAAA,IAAcrC,CAArBN,EAA2BA,GAH3BM;AAG2BN,QACrB4E,CAAAA,GAAe;AACnBC,MAAAA,IAAAA,EAAM,CADa;AAEnBnE,MAAAA,KAAAA,EAAOJ,CAAAA,CAAKI;AAFO,KADMV;AAK3ByE,IAAAA,CAAAA,GAAOC,CAAAA,GAAO,CAAdD;;AAAc,SACT,IAAIK,CAAAA,GAAQhC,CADH,EACQgC,CAAAA,GAAQxE,CAAAA,CAAKW,GAALX,CAASnC,MAAjB2G,IAAiB3G,CAAWsG,CADpC,EAC0CK,CAAAA,EAD1C,EACmD;AAAA,UACzDC,CAAAA,GAAOzE,CAAAA,CAAKW,GAALX,CAASwE,CAATxE,CADkD;AAAA,UAEzDP,CAAAA,GAAOgF,CAAAA,CAAKhF,IAF6C;;AAE7CA,cACVgF,CAAAA,CAAKjF,IADKC;AACLD,aD3RI,SC2RJA;AD3RI;AAAA,gBC6RTI,CAAAA,GAAKH,CAAAA,CAAKiF,SD7RD;AC8RTrC,YAAAA,CAAAA,KACFzC,CAAAA,GAAM,GAAEyC,CAAAA,CAAKsC,MAAAA,IAAU/E,CAAAA,EADrByC,CAAAA;AACqBzC,gBAEnB8C,CAAAA,GAAWjD,CAAAA,CAAKiD,QAFG9C;;AAEH8C,gBAClB8B,CAAAA,KAAUhC,CAAVgC,IAAiBhF,CAAAA,KAASkD,CADRA,EACkB;AACjCI,cAAAA,EAAAA,CAAS8B,GAAT9B,CAAalD,CAAbkD,MACHA,EAAAA,CAAS+B,GAAT/B,CAAalD,CAAbkD,GACAP,EAAAA,CAASiC,CAATjC,EAAgBE,CAAhBF,EAAuBG,CAAvBH,EAAiC3C,CAAjC2C,CAFGO;AAE8BlD,uBAE1ByE,CAF0BzE;AAIrCkD;;AAAAA,YAAAA,EAAAA,CAASgC,MAAThC,CAAgBlD,CAAhBkD;AAAgBlD;AAAAA;;AAAAA,aAGb,KAHaA;AAGb;AAAA,gBACC3C,CADD;;AACCA,oBAEIwC,CAAAA,CAAKQ,IAFThD;AAESgD,mBDhTF,OCgTEA;AACChD,gBAAAA,CAAAA,GAAQiE,EAAAA,CAASuB,CAATvB,CAARjE;AAAiBwF;;AAAAA,mBD3SpB,GC2SoBA;AD3SpB,mBC6SJ,GD7SI;AC8SPxF,gBAAAA,CAAAA,GAAQwF,CAAAA,CAAMhD,CAAAA,CAAKQ,IAAXwC,CAARxF;AAAmBgD;;AAAAA,mBDlTZ,OCkTYA;AAEThD,gBAAAA,CAAAA,GAAQwC,CAAAA,CAAKE,KAAb1C;AAAa0C;;AAAAA,mBACpBG,CADoBH;AAElBD,gBAAAA,CAAAA,CAAID,CAAAA,CAAKE,KAALF,CAAWG,EAAfF,CAAAA,KAEH+C,CAAAA,CAAMJ,IAANI,GAAaJ,CAAAA,GAAOkB,EAAAA,CAAclB,CAAdkB,EAAoB9D,CAAAA,CAAKE,KAALF,CAAWG,EAA/B2D,CAApBd,EACA/C,CAAAA,GAAM2C,CAAAA,GAAOA,CAAAA,CAAK3C,GAAZ2C,GAAkBrC,CAAAA,CAAKN,GAH1BA,GAOLzC,CAAAA,GAAQ8H,EAAAA,CAAQrF,CAAAA,CAAID,CAAAA,CAAKE,KAALF,CAAWG,EAAfF,CAARqF,CAPHrF;AAVLzC;;AAiB+B2C,oBAI3BH,CAAAA,CAAKI,EAJsBD;AAItBC,mBDnUF,OCmUEA;AACC4C,gBAAAA,CAAAA,CAAMxF,KAANwF,GAAcxF,CAAdwF;AAAcxF;;AAAAA,mBD9TjB,GC8TiBA;AD9TjB,mBCgUJ,GDhUI;ACiUPwF,gBAAAA,CAAAA,CAAMhD,CAAAA,CAAKI,EAAX4C,CAAAA,GAAiBxF,CAAjBwF;AAAiBxF;;AAAAA,mBAEd6C,CAFc7C;AAGjBuG,gBAAAA,EAAAA,CAAWnB,CAAXmB,EAAiBxD,CAAjBwD,EAAuB/D,CAAAA,CAAKM,MAALN,CAAYG,EAAnC4D,CAAAA,CAAuCwB,OAAvCxB,GAAiDvG,CAAjDuG;AAX+B5D;;AAWkB3C;AAAAA;;AAAAA,aAKlD,OALkDA;AAKlD,kBACKwC,CAAAA,CAAKD,IADV;AACUA,iBACN,SADMA;AAET4E,cAAAA,CAAAA,GAAAA,KAA2Ba,CAA3Bb,KAAOlD,EAAAA,CAASuB,CAATvB,CAAPkD;AAAgB3B;;AAAAA,iBAEb,SAFaA;AAGhB2B,cAAAA,CAAAA,GACElD,EAAAA,CAASuB,CAATvB,CAAAA,KACA6D,EAAAA,CAAQvB,EAAAA,CAAWnB,CAAXmB,EAAiBxD,CAAjBwD,EAAuB/D,CAAAA,CAAKE,KAALF,CAAWG,EAAlC4D,CAARuB,CAFFX;AAND;;AAQ6CxE;;AAAAA,aDlVpC,QCkVoCA;AAUhDwE,UAAAA,CAAAA,GAAAA,CAAQc,EAAAA,CAAOZ,CAAPY,EAAczF,CAAdyF,EAAoBzC,CAApByC,CAARd;AAA4B3B;;AAAAA,aAEzB,KAFyBA;AAEzB,cAEC+B,CAAAA,KAAUhC,CAAVgC,ID1WQ,aC0WShF,CAFlB,EAEmC;AACpC+C,YAAAA,EAAAA,CAASiC,CAATjC,EAAgBE,CAAhBF,ED3WU,QC2WVA,CAAAA;AD3WU,qBC4WD8B,CD5WC;AC4WDA;;AAAAA,aAER,SAFQA;AAGXpB,UAAAA,EAAAA,GAA2B,YAAjBjD,CAAAA,CAAKvB,IAALuB,CAAUmF,EAApBlC,EACAR,CAAAA,CAAMxF,KAANwF,GAAcyC,EAAAA,CAAOZ,CAAPY,EAAczF,CAAdyF,EAAoBzC,CAApByC,CADdjC,EAEAA,EAAAA,GAAUiB,CAAAA,CAAiBjB,OAF3BA;AA/EcxD;;AAoFlB0E,MAAAA,CAAAA,GAAOG,CAAAA,CAAMC,IAAND,IAAcF,CAArBD;AAAqBC;;AAAAA,QAAAA,CAElBD,CAFkBC,EAElBD,KACE,IAAIK,CAAAA,GAAQ,CADdL,EACiBK,CAAAA,GAAQxE,CAAAA,CAAKc,IAALd,CAAUnC,MADnCsG,EAC2CK,CAAAA,EAD3CL,EAED/B,EAAAA,CACE,OADFA,EAEEC,CAFFD,EAGEpC,CAAAA,CAAKc,IAALd,CAAUwE,CAAVxE,CAHFoC,EAIEK,CAJFL,EAKElB,EAAAA,CAASuB,CAATvB,CALFkB,EAME6B,EAAAA,CAAYxB,CAAZwB,CANF7B,CAAAA;AAWNY;;AAAAA,EAAAA,EAAAA,GAASkB,CAAAA,CAAiBlB,MAA1BA,EACAE,EAAAA,GAAcgB,CAAAA,CAAiBhB,WAD/BF,EAEAV,EAAAA,GAAW2B,EAAAA,CAAYC,CAAZD,CAFXjB;AC5XK;;AAAA,SAAS2C,CAAT,CAAwBC,CAAxB,EAAuCtI,CAAAA,GAAiB,SAAxD,EAAwD;AAAA,MACzDuB,CAAAA,GAAOvB,CAAAA,GAAS,GADyC;AAAA,MAEzDuI,CAAAA,GAAQ,EAFiD;AAAA,MAGzDjI,CAAAA,GAAI,CAHqD;;AAGrD,OAEH,IAAMkI,CAFH,IAEUF,CAFV,EAEoB;AAAA,QAEpBvH,CAAAA,GAAOuH,CAAAA,CAASE,CAATF,CAFa;AAEJE,QACV,QAARzH,CAAQ,KACVQ,CAAAA,IAAQgH,CAARhH,EAEAA,CAAAA,IAAQkH,CAAAA,CAAQ1H,CAAR0H,CAAAA,GAAgB1H,CAAAA,CAAK2H,aAAL3H,CAAmB4H,QAAnCF,GAA8C1H,CAAAA,CAAK6H,QAAL7H,EAH5C,GAKZT,CAAAA,IAAK,CALO,EAOF,OAANA,CARkBkI,EAQR;AACdD,IAAAA,CAAAA,GAAQ,IAARA;AAAQ;;AAAA,SAEVhH,CAAAA,IAAQ,GAARA,EACOA,CAHG;AAML;;AAAA,SAASsH,CAAT,CAA6BxG,CAA7B,EAAkDyG,CAAlD,EAAkDA;AAAAA,MACjDJ,CAAAA,GAAgBK,CAAAA,CAAWD,CAAXC,EAAoB1H,EAAAA,CAAUgB,CAAVhB,CAApB0H,CADiCD;AACHzG,MACpDA,CAAAA,CAAM8F,SAAN9F,GAAkByG,CAAlBzG,EAAkByG,CACbzG,CAAAA,CAAMqG,aAFyCrG,EAEzCqG,OAAAA,MACTrG,CAAAA,CAAMqG,aAANrG,GAAsBqG,CADbA,CAAAA;AACaA,MAGlBM,CAAAA,GAAmB3G,CAAAA,CAAMqG,aAHPA;AAIxBM,EAAAA,CAAAA,CAAiBC,IAAjBD,GAAwBN,CAAAA,CAAcO,IAAtCD,EACAA,CAAAA,CAAiBb,SAAjBa,GAA6BN,CAAAA,CAAcP,SAD3Ca,EAEAA,CAAAA,CAAiBL,QAAjBK,GAA4BN,CAAAA,CAAcC,QAF1CK;AAWK;;AAAA,SAASD,CAAT,CAAoBxH,CAApB,EAAkCH,CAAlC,EAAkCA;AAAAA,MACnC6H,CADmC7H;AAAAA,MAEnCuH,CAFmCvH;AAAAA,MAGnC8H,CAHmC9H;AAAAA,MAIjC+G,CAAAA,GAAY5G,CAJqBH;AAIrBG,SACbH,CAAAA,IAQH8H,CAAAA,GAAY9H,CAAAA,CAAOsH,aAAnBQ,EACoB,MAAhB3H,CAAAA,CAAKhB,MAAW,IAClB0I,CAAAA,GAAOC,CAAAA,CAAUD,IAAjBA,EACAN,CAAAA,GAAWO,CAAAA,CAAUP,QAFH,KAIlBM,CAAAA,GAAOC,CAAAA,CAAUD,IAAVC,CAAeC,MAAfD,CAAsB,CAAC3H,CAAD,CAAtB2H,CAAPD,EAEEN,CAAAA,GADgC,MAA9BO,CAAAA,CAAUP,QAAVO,CAAmB3I,MAAW,GACrBgB,CADqB,GAGhB2H,CAAAA,CAAUP,QAAVO,GAAqB,GAArBA,GAA2B3H,CAR3B,CATjBH,KAED6H,CAAAA,GADkB,MAAhB1H,CAAAA,CAAKhB,MAAW,GACX,EADW,GAGX,CAACgB,CAAD,CAFP0H,EAIFN,CAAAA,GAAWpH,CANRH,CAAAA,EAqBE;AAAC+G,IAAAA,SAAAA,EAAAA,CAAD;AAAYQ,IAAAA,QAAAA,EAAAA,CAAZ;AAAsBM,IAAAA,IAAAA,EAAAA;AAAtB,GAtBW1H;ACtDb;;AAAA,SAAS6H,CAAT,CACLC,CADK,EAELrI,CAFK,EAELA;AAAAA,OAEK,IAAMwH,CAFXxH,IAEkBqI,CAFlBrI,EAGEA,CAAAA,CAAGqI,CAAAA,CAAIb,CAAJa,CAAHrI,EAAawH,CAAbxH,CAAAA;AAkBG;;AAAA,SAAS2I,CAAT,CAAiB/H,CAAjB,EAA4BH,CAA5B,EAA4BA;AACjCG,EAAAA,CAAAA,CAAK+H,OAAL/H,CAAaH,CAAbG;AC+HK;;AAAA,SAAS8J,CAAT,CACLU,CADK,EAELC,CAFK,EAELA;AAAAA,MAEMN,CAAAA,GAAa,CAAC3F,CAAD,EAACA,GAAqB6F,CAAtB,KACbrG,EAAAA,GApBR,CAAA,CAAoB7E,CAApB,EAA+BL,CAA/B,EAA8C0F,CAA9C,EAA4D6F,CAA5D,KAA4DA;AAAAA,QACpDC,CAAAA,GAAUtG,EAD0CqG;AAAAA,QAEtDlH,CAAAA,GAAO,IAF+CkH;AAE/C,QACPvL,CADO,EACPA,KACFqE,CAAAA,GAAOa,EADLlF,EAEKqE,CAAAA,IAAQA,CAAAA,CAAKrE,QAALqE,KAAkBrE,CAF/BA,GAGAqE,CAAAA,GAAO1D,EAAAA,CAAU0D,CAAV1D,CAAP0D;AAGJgB,IAAAA,EAAAA,CAAehB,CAAfgB,CAAAA;AAAehB,QACTlD,CAAAA,GAASd,CAAAA,CAAKoL,MAALpL,CAAYqF,CAAZrF,EAAqBkL,CAArBlL,CADAgE;AACqBkH,WACpClG,EAAAA,CAAemG,CAAfnG,CAAAA,EACOlE,CAF6BoK;AAE7BpK,GAZT,EAqBwBkK,CArBxB,EAqB+BrL,CArB/B,EAqByC0F,CArBzC,EAqBkD6F,CArBlD,CAoBQrG,GAGGmG,CAAAA,CAAMI,MAANJ,CAAa3F,CAAb2F,EAAsBE,CAAtBF,CANTM;;AAQAN,EAAAA,CAAAA,CAAMO,QAANP,GAAiBrK,CAAAA,CAAW;AAC1BP,IAAAA,IAAAA,EAAMsJ,EAAAA,CJjKW,OIiKXA,EAAgBsB,CAAhBtB,EAAuB4B,CAAvB5B,EAAoC2B,CAApC3B,CADoB;AAE1BxH,IAAAA,QAAAA,EAAU;AAFgB,GAAXvB,CAAjBqK,EAKAA,CAAAA,CAAMI,MAANJ,GAAgBtF,CAAAA,KAEdN,CAAAA,CADenB,EAAAA,GAAWA,EAAAA,CAASuH,IAATvH,CAAc+G,CAAd/G,CAAXA,GAAkC+G,CACjD5F,EAAeM,CAAfN,CAAAA,EACOM,CAHOA,CALhBsF,EAUAA,CAAAA,CAAMV,KAANU,GAAcS,CAAAA,CAAKC,EAALD,EAAgBT,CAAhBS,CAVdT,EAWAA,CAAAA,CAAMhK,GAANgK,GAAatK,CAAAA,IAAAA;AAAAA,QACPqI,CADOrI,EAEPF,CAFOE;AAGP/B,IAAAA,CAAAA,CAAS+B,CAAT/B,CAAAA,KACFoK,CAAAA,GAASrI,CAATqI,EACAvI,CAAAA,GAAOE,CAAAA,CAAGF,IADVuI,EAEArI,CAAAA,GAAKA,CAAAA,CAAGA,EAHN/B;AAGM+B,QAEJuK,CAAAA,GAASN,CAAAA,CAAYtD,EAAAA,CAAQ2D,CAAR3D,EAAe7G,CAAf6G,CAAZsD,EAAkC5B,CAAlC4B,CAFLjK;AAEuCqI,WACjD6B,EAAAA,CAAkBI,CAAlBJ,EAAyBK,CAAzBL,EAAiC7H,CAAjC6H,EAAsClK,CAAtCkK,CAAAA,EACOK,CAF0ClC;AAE1CkC,GArBTD,EAuBAA,CAAAA,CAAMW,MAANX,GAAgBtK,CAAAA,IACdqK,EAAAA,CAAsBC,CAAtBD,EJ7KkB,QI6KlBA,EAAqCrK,CAAAA,CAAGA,EAAHA,GAAQA,CAARA,GAAaA,CAAAA,CAAGA,EAArDqK,EAAyD,CACvD3E,EAAAA,CAAY;AAAC1F,IAAAA,EAAAA,EAAIoK;AAAL,GAAZ1E,CADuD,CAAzD2E,CAxBFC,EA2BAA,CAAAA,CAAMY,SAANZ,GAAmBtK,CAAAA,IACjBqK,EAAAA,CAAsBC,CAAtBD,EAA6B,WAA7BA,EAA0CrK,CAA1CqK,EAA8C,CAC5C3E,EAAAA,CAAa;AAAC1F,IAAAA,EAAAA,EAAIoK;AAAL,GAAb1E,CAD4C,EAE5CA,EAAAA,CAAWyF,OAAXzF,EAF4C,CAA9C2E,CA5BFC,EAgCAA,CAAAA,CAAMc,OAANd,GAAiBtK,CAAAA,IAAAA;AAAAA,QACTqL,CAAAA,GAA2BpB,CAAAA,CAAY,SAASK,CAAAA,CAAM5D,SAA3BuD,EAAsC;AACrEtK,MAAAA,MAAAA,EAAQC,EAAAA,CAAU0K,CAAV1K;AAD6D,KAAtCqK,CADlBjK;AAAAA,QAITf,CAAAA,GAAWD,EAAAA,EAJFgB;AAIEhB,WACbC,CAAAA,IACFQ,EAAAA,CAAS4L,CAAT5L,CAAAA,CAAuBmC,GAAvBnC,CAA2BY,IAA3BZ,CAAgCR,CAAAA,CAASqM,MAAzC7L,CADER,EAGJiL,EAAAA,CAAkBmB,CAAlBnB,EAAgCI,CAAhCJ,EAAuC,SAAvCA,EAAkDlK,CAAlDkK,CAHIjL,EAIJ2J,EAAAA,CAAgB0B,CAAhB1B,EAAuByC,CAAvBzC,CAJI3J,EAKGoM,CANUrM;AAMVqM,GA1CTf;AA0CSe,MAEHpM,CAAAA,GAAWD,EAAAA,EAFRqM;AAEQrM,SACVsL,CADUtL;AAIZ;;AAAA,SAASuM,CAAT,CACLC,CADK,EAELC,CAFK,EAELA;AAAAA,WA8HSqB,CA9HTrB,CA8HiBnB,CA9HjBmB,EA8H6BzL,CA9H7ByL,EA8H6BzL;AAC3BY,IAAAA,CAAAA,CAAMmM,GAANnM,CAAU0J,CAAV1J,GACAqM,EAAAA,CAAerM,CAAfqM,CAAAA,CAAsBe,GAAtBf,CACE3C,CADF2C,EAEEgB,EAAAA,CACET,EAAAA,CAAYlD,CAAZkD,EAAmB5M,CAAnB4M,EAA0B,IAA1BA,EAAgC,CAAhCA,EAAsCxN,CAAtCwN,EAA0ChF,CAA1CgF,CADFS,CAFFhB,CADArM;AAI8C4H;;AAAAA,MAjI1CkD,CAAAA,GAAaC,EAAAA,CAAeH,CAAfG,CAiI6BnD;AAAAA,MAhI1CoD,CAAAA,GAAWD,EAAAA,CAAeH,CAAfG,CAgI+BnD;AAAAA,MA/H1CqD,CAAAA,GAAU7B,EAAAA,CAAiB,SAAjBA,CA+HgCxB;AAAAA,MA9H1CvJ,CAAAA,GAAWD,EAAAA,EA8H+BwJ;AA7HhDkD,EAAAA,CAAAA,CAAWI,KAAXJ,GAAmB,CAAC;AAACjL,IAAAA,IAAAA,EAAM,MAAP;AAAeK,IAAAA,EAAAA,EAAI8K;AAAnB,GAAD,CAAnBF,EACIzM,CAAAA,IACFA,CAAAA,CAAS8M,KAAT9M,CAAeoB,IAAfpB,CAAoByM,CAApBzM,EAAgC2M,CAAhC3M,CAFFyM;AAEkCE,MAE5BI,CAAAA,GAAeN,CAAAA,CAAW7K,EAFE+K;AAAAA,MAG5BhL,CAAAA,GAAa;AACjBqL,IAAAA,WAAAA,EAAa,IAAIC,GAAJ,EADI;AAEjBL,IAAAA,OAAAA,EAAAA,CAFiB;AAGjBL,IAAAA,YAAAA,EAAAA,CAHiB;AAIjBW,IAAAA,QAAAA,EAAUT,CAJO;;AAKjBU,IAAAA,QAAAA,GAAAA;AAAAA,UAEME,CAFNF;AAAAA,UACMC,CAAAA,GAAYX,CADlBU;;AACkBV,UAEZvH,EAFYuH,EAEC;AAAA,YACXpI,CAAAA,GAAOa,EADI;;AACJA,eACJb,CAAAA,IAAAA,CAASA,CAAAA,CAAK3C,GAAL2C,CAAS0I,CAAT1I,CADLa,GAETb,CAAAA,GAAO1D,EAAAA,CAAU0D,CAAV1D,CAAP0D;;AAEEA,QAAAA,CAAAA,KAAMgJ,CAAAA,GAAchJ,CAApBA,CAAAA;AAAoBA;;AAAAA,aAAAA,CAErBgJ,CAFqBhJ,IAENC,EAFMD,IAEMC,EAAAA,CAAS5C,GAAT4C,CAAayI,CAAbzI,CAFND,KAGxBgJ,CAAAA,GAAc/I,EAHUD,GAKtBgJ,CAAAA,KAAaD,CAAAA,GAAYC,CAAAA,CAAY3L,GAAZ2L,CAAgBN,CAAhBM,CAAzBA,CALsBhJ,EAMnB0C,EAAAA,CAAQqG,CAARrG,CANmB1C;AAMX+I,KAnBA;;AAqBjBE,IAAAA,QAAAA,CAASC,CAATD,EAASC;AAAAA,UACHxL,CADGwL;AAEHjJ,MAAAA,EAAAA,KACFvC,CAAAA,GAASuC,EAAAA,CAASkJ,OAATlJ,CAAiB9D,EAAAA,CAASmB,CAATnB,CAAAA,CAAgBoB,EAAjC0C,CADPA,CAAAA,EAGCvC,CAAAA,KAAQA,CAAAA,GAASJ,CAAjBI,CAHDuC,EAIJmB,CAAAA,CAAO;AACL1D,QAAAA,MAAAA,EAAAA,CADK;AAELgE,QAAAA,MAAAA,EAAQwH,CAFH;AAGLvH,QAAAA,KAAAA,EAAO;AAHF,OAAPP,CAJInB;AAOK,KA9BM;;AAiCjBmJ,IAAAA,KAAAA,CAAAA,GAASC,CAATD,EAASC;AAAAA,WACF,IAAMrN,CADJqN,IACYA,CADZA,EACmB/L,CAAAA,CAAMgM,EAANhM,CAAStB,CAATsB,EAAe,MAAMA,CAAAA,CAAM4K,YAA3B5K;;AAA2B4K,aAC9C5K,CAD8C4K;AAC9C5K,KAnCQ;;AAqCjBgM,IAAAA,EAAAA,CAAGC,CAAHD,EAAiB5M,CAAjB4M,EAAiB5M;AAAAA,UACftB,CAAAA,CAAcmO,CAAdnO,EAAuB,KAAvBA,EAA8B,gBAA9BA,CAAAA,EACIC,KAAAA,CAAMC,OAAND,CAAckO,CAAdlO,CAFWqB,EAEG6M,KACX,IAAMvC,CADKuC,IACIA,CADJA,EAEdC,CAAAA,CAAQxC,CAARwC,EAAe9M,CAAf8M,CAAAA,CAJW9M,KAOb8M,CAAAA,CAAQD,CAARC,EAAiB9M,CAAjB8M,CAAAA;AAAiB9M,aAEZY,CAFYZ;AAEZY,KA9CQ;;AAgDjBmM,IAAAA,GAAAA,CAAIzN,CAAJyN,EAAIzN;AAAAA,UACI0N,CAAAA,GAAsBC,EAAAA,CAAerM,CAAfqM,CAAAA,CAAsBC,GAAtBD,CAA0B3N,CAA1B2N,CAD1B3N;AACoDA,aAClD0N,CAAAA,KACFA,CAAAA,IACAC,EAAAA,CAAerM,CAAfqM,CAAAA,CAAsBlH,MAAtBkH,CAA6B3N,CAA7B2N,CAFED,CAAAA,EAIGpM,CAL+CtB;AAK/CsB,KAtDQ;;AAwDjBN,IAAAA,GAAAA,CAAIN,CAAJM,EAAa6M,CAAb7M,EAAa6M;AAAAA,UACP9E,CADO8E,EAEPrN,CAFOqN,EASPC,CATOD;AAGPlP,MAAAA,CAAAA,CAAS+B,CAAT/B,CAAAA,KACFoK,CAAAA,GAASrI,CAATqI,EACAvI,CAAAA,GAAOE,CAAAA,CAAGF,IADVuI,EAEA8E,CAAAA,GAAanN,CAAAA,CAAGmN,UAFhB9E,EAGArI,CAAAA,GAAKA,CAAAA,CAAGA,EAJN/B;AAIM+B,UAGJqN,CAAAA,GAAazM,CAAAA,CAAMwL,QAANxL,EAHTZ;AAAAA,UAIJf,CAAAA,GAAWD,EAAAA,EAJPgB;AAKNf,MAAAA,CAAAA,GACFmO,CAAAA,GAAa,IADXnO,GACW,KACWiH,CADX,KACJmH,CADI,KAEbD,CAAAA,GAAapN,CAAAA,CAAGqN,CAAHrN,EAAemN,CAAfnN,CAFA,CADXf;AAG0BkO,UAGxBG,CAAAA,GAAyB/B,CAAAA,CAAY6B,CAAZ7B,EAAwB;AACrDzL,QAAAA,IAAAA,EAAM6G,EAAAA,CAAQ/F,CAAR+F,EAAe7G,CAAf6G,CAD+C;AAErD0B,QAAAA,MAAAA,EAAAA,CAFqD;AAGrDI,QAAAA,MAAAA,EAAQ;AAH6C,OAAxB8C,CAHD4B;AAAAA,UAQxBI,CAAAA,GAAWC,EAAAA,CAAY5M,CAAZ4M,EAAmBF,CAAnBE,EAA+BnL,CAA/BmL,EAAoC,CAApCA,EAA2CxN,CAA3CwN,CARaL;AAQ8BnN,aAE5DyN,EAAAA,CAAcH,CAAdG,CAAAA,CAA0BC,MAA1BD,GAAmC,CACjC;AACEhN,QAAAA,IAAAA,EAAM4B,CADR;AAEErC,QAAAA,EAAAA,EAAAA,CAFF;AAGEkB,QAAAA,IAAAA,EAAMwK;AAHR,OADiC,CAAnC+B,EAOIxO,CAAAA,KACG4I,EAAAA,CAAS5I,CAAAA,CAAS8M,KAAlBlE,EAAyB6D,CAAzB7D,CAAAA,IACEA,EAAAA,CAAS0F,CAAAA,CAAS3L,GAAlBiG,EAAuB5I,CAAAA,CAAS0O,MAAhC9F,CADFA,IAED0F,CAAAA,CAAS3L,GAAT2L,CAAaK,OAAbL,CAAqBtO,CAAAA,CAAS0O,MAA9BJ,CAHFtO,CAPJwO,EAcOH,CAhBqDtN;AAgBrDsN,KA/FQ;;AAiGjB1D,IAAAA,KAAAA,CAAMiE,CAANjE,EAAsB5J,CAAtB4J,EAAsB5J;AAAAA,UAAAA,CACfA,CADeA,IACfA,CAAOgH,CAAAA,CAAQ6G,CAAR7G,CADQhH,EACY;AAAA,YACxB8N,CAAAA,GAAe9C,EAAAA,CAAUpK,CAAVoK,EAAiB6C,CAAjB7C,CADS;AAAA,YAExB/L,CAAAA,GAAWD,EAAAA,EAFa;AAEbA,eACbC,CAAAA,GACFA,CAAAA,CAAS2K,KAAT3K,CAAeoB,IAAfpB,CAAoB;AAClB8O,UAAAA,EAAAA,EAAIrC,CADc;AAElB1L,UAAAA,EAAAA,EAAI6N;AAFc,SAApB5O,CADEA,GAMF4O,CAAAA,CAAUjN,CAAAA,CAAMwL,QAANxL,EAAViN,CANE5O,EAQG6O,CATU9O;AASV8O;;AAAAA,aAEJ3P,CAAAA,CAAW6B,CAAX7B,CAAAA,IAAgBE,CAAAA,CAAW,sCAAXA,CAAhBF,EACE0P,CAAAA,CAAUjE,KAAViE,CAAiBlJ,CAAAA,IAAiB3E,CAAAA,CAAGY,CAAAA,CAAMwL,QAANxL,EAAHZ,EAAqB2E,CAArB3E,CAAlC6N,CAHEC;AAGqDnJ;;AAhH/C,GAHeiH;AAAAA,MA+H5BlM,CAAAA,GAAOsJ,EAAAA,CAASjI,CAATiI,EAAgBpI,CAAhBoI,EAAuByC,CAAvBzC,CA/HqB4C;AAAAA,MAgI5BpD,CAAAA,GAAe5H,CAAAA,CAAM2I,aAAN3I,CAAoB4H,YAhIPoD;AAgIOpD,SACzC5H,CAAAA,CAAMiK,QAANjK,GAAiBX,CAAAA,CAAW;AAC1BoB,IAAAA,KAAAA,EAAO;AAACmL,MAAAA,KAAAA,EAAOd;AAAR,KADmB;AAE1BzK,IAAAA,IAAAA,EAAM,CACJyE,EAAAA,CAAWyF,OAAXzF,EADI,EAEJA,EAAAA,CAAWwI,OAAXxI,CAAmB;AACjB9E,MAAAA,KAAAA,EAAOgL;AADU,KAAnBlG,CAFI,EAKJ8C,CAAAA,IAAgB9C,EAAAA,CAAS;AAAC9E,MAAAA,KAAAA,EAAOgL,CAAR;AAAkB9K,MAAAA,EAAAA,EJtV5B;AIsVU,KAAT4E,CALZ,EAMJ8C,CAAAA,IACE9C,EAAAA,CAAY;AACV1F,MAAAA,EAAAA,EAAI,CAACmO,CAAD,EAASC,CAAT,EAASA;AAAI5L,QAAAA,CAAAA,EAAAA;AAAJ4L,OAAT,KAAoB5F,CAAAA,CAAa2F,CAAb3F,EAAqBhG,CAArBgG;AADd,KAAZ9C,CAPE,EAUJA,EAAAA,CAAY;AACV9E,MAAAA,KAAAA,EAAO8K;AADG,KAAZhG,CAVI,EAaJA,EAAAA,CAAY;AACV9E,MAAAA,KAAAA,EAAOgL;AADG,KAAZlG,CAbI,CAFoB;AAmB1BtE,IAAAA,KAAAA,EAAOyK,CAnBmB;AAoB1BnM,IAAAA,IAAAA,EAAAA,CApB0B;AAqB1B8B,IAAAA,QAAAA,EAAU;AArBgB,GAAXvB,CAAjBW,EAuBImI,EAAAA,IAAAA,KAA6B7C,CAA7B6C,KAAYyC,CAAZzC,IACF1K,CAAAA,CAAW,oDAAXA,CAxBFuC,EAyBAsB,EAAAA,CAAItB,CAAJsB,EAAW,CAAC2J,CAAD,CAAX3J,CAzBAtB,EA0BOA,CA3BkC4H;AC7UpC;;AAAA,SAASmG,CAAT,CAASA,GAAWnE,CAApB,EAAoBA;AAAAA,MACrBjC,CADqBiC,EAErBoE,CAFqBpE,EAGrBnC,CAHqBmC;AAIzBqE,EAAAA,EAAAA,CAAgBrE,CAAAA,CAAK,CAALA,CAAhBqE,EAAyB,CAACC,CAAD,EAAeC,CAAf,KAAeA;AACtC1G,IAAAA,CAAAA,GAASyG,CAATzG,EACAmC,CAAAA,GAAOuE,CADP1G;AACO0G,GAFTF,CAAAA;AAESE,MAULG,CAVKH;AAAAA,MAWLI,CAXKJ;AAAAA,MAEHC,CAAAA,GAAaxE,CAAAA,CAAKA,CAAAA,CAAK1L,MAAL0L,GAAc,CAAnBA,CAFVuE;;AAE6B,MAClC5Q,CAAAA,CAAW6Q,CAAX7Q,CAAAA,IACFyQ,CAAAA,GAASpE,CAAAA,CAAKyE,KAALzE,CAAW,CAAXA,EAAW,CAAI,CAAfA,CAAToE,EACArG,CAAAA,GAAUyG,CAFR7Q,IAIFyQ,CAAAA,GAASpE,CAJPrM,EASkB,MAAlByQ,CAAAA,CAAO9P,MAV2B,EAUb;AAAA,QACjB8I,CAAAA,GAAMgH,CAAAA,CAAO,CAAPA,CADW;AAKlB5H,IAAAA,CAAAA,CAASY,CAATZ,CAAAA,KAcHkI,CAAAA,GAAmBtH,CAAnBsH,EACAC,CAAAA,GAAa,CAfVnI;AAeU;;AAAA,SAGZmI,CAAAA,KAIHD,CAAAA,GAAmBN,CAAnBM,EAKI3G,CAAAA,KACFA,CAAAA,GAAU6G,EAAAA,CAAW7G,CAAX6G,CADR7G,CATD4G,CAAAA,EAaAlR,CAAAA,CAASiR,CAATjR,CAAAA,IAA4BI,CAAAA,CAAW,2BAAXA,CAb5B8Q,EAcEE,EAAAA,CACL1Q,KAAAA,CAAMC,OAAND,CAAcuQ,CAAdvQ,CADK0Q,EAELH,CAFKG,EAGLhH,CAHKgH,EAIL9G,CAJK8G,CAjBU;ACpDZ;;AAAA,SAASS,CAAT,GAASA;AAAAA,MAKR1P,CAAAA,GAAS,EALD0P;AAKC,SAKf1P,CAAAA,CAAO2P,GAAP3P,GAAa,IAAI4P,OAAJ,CAAY,CAACC,CAAD,EAAKC,CAAL,KAAKA;AAC5B9P,IAAAA,CAAAA,CAAO6P,EAAP7P,GAAY6P,CAAZ7P,EACAA,CAAAA,CAAO8P,EAAP9P,GAAY8P,CADZ9P;AACY8P,GAFD,CAAb9P,EAIAA,CAAAA,CAAO2P,GAAP3P,CAAW+P,KAAX/P,CAAiBiG,MAAAA,CAAAA,CAAjBjG,CAJAA,EAKOA,CAVQ;ACMV;;AAAA,SAASgQ,CAAT,CACLzF,CADK,EAELC,CAFK,EAELA;AAAAA,MAEMyF,CAAAA,GAAgBpG,CAAAA,CAAYU,CAAZV,EAA0BW,CAA1BX,CAFtBW;AAAAA,MAGIrC,CAAAA,GACF8H,CAAAA,CAAS9G,aAAT8G,CAAuB9H,OAAvB8H,KAAuB9H,MAChBlK,CAAAA,CAAY,sBAAqBgS,CAAAA,CAAS5G,OAAT4G,EAAS5G,EAA1CpL,CADPgS,CAJFzF;AAAAA,MAMM3J,CAAAA,GAAOxB,EAAAA,CAAS4Q,CAAT5Q,CANbmL;;AAOA3J,EAAAA,CAAAA,CAAKvB,IAALuB,CAAUqP,MAAVrP,GAAmB,CAAC,QAAD,CAAnBA,EACAA,CAAAA,CAAKvB,IAALuB,CAAU3B,IAAV2B,GAAiBoP,CAAAA,CAASpH,IAAToH,GPnBG,QOkBpBpP,EAEAoP,CAAAA,CAASE,GAATF,GAAgBrQ,CAAAA,KACT7B,CAAAA,CAAW6B,CAAX7B,CAAAA,IAAgBE,CAAAA,CAAW,oCAAXA,CAAhBF,EACLoK,CAAAA,GAAUvI,CADL7B,EAEEkS,CAHOrQ,CAFhBiB;AAKSoP,MAEHG,CAAAA,GAAUH,CAAAA,CAASI,OAATJ,GAAmBrG,EAAAA,CAAiB,SAAjBA,CAF1BqG;AAAAA,MAGHK,CAAAA,GAAQL,CAAAA,CAASK,IAATL,GAAiBG,CAAAA,CAAetF,SAAfsF,CAAyB;AACtD9H,IAAAA,KAAAA,EAAO,MAD+C;;AAEtD1I,IAAAA,EAAAA,CAAAA;AAAG2Q,MAAAA,MAAAA,EAACA,CAAJ3Q;AAAG2Q,MAAAA,MAAAA,EAAS3L,CAAZhF;AAAG2Q,MAAAA,MAAAA,EAAiBvQ;AAApBJ,KAAAA,EAAoBI;AAAAA,UACH,WAAXuQ,CADcvQ,EACK,OAAO;AAAC4E,QAAAA,MAAAA,EAAAA,CAAD;AAAS5E,QAAAA,MAAAA,EAAAA;AAAT,OAAP;AAAgBA;;AAHa,GAAzBoQ,CAHtBH;AAAAA,MASH7K,CAAAA,GAAQ6K,CAAAA,CAAS7K,IAAT6K,GAAiBG,CAAAA,CAAetF,SAAfsF,CAAyB;AACtD9H,IAAAA,KAAAA,EAAO,MAD+C;;AAEtD1I,IAAAA,EAAAA,CAAAA;AAAG2Q,MAAAA,MAAAA,EAACA,CAAJ3Q;AAAG2Q,MAAAA,MAAAA,EAAS3L,CAAZhF;AAAG2Q,MAAAA,KAAAA,EAAiBpK;AAApBvG,KAAAA,EAAoBuG;AAAAA,UACH,WAAXoK,CADcpK,EACK,OAAO;AAACvB,QAAAA,MAAAA,EAAAA,CAAD;AAASuB,QAAAA,KAAAA,EAAAA;AAAT,OAAP;AAAgBA;;AAHa,GAAzBiK,CATtBH;AAAAA,MAeHO,CAAAA,GAAYP,CAAAA,CAASO,QAATP,GAAoBK,CAAAA,CAAKpQ,GAALoQ,CAAS;AAC7ChI,IAAAA,KAAAA,EAAO,UADsC;AAE7C1I,IAAAA,EAAAA,EAAI,CAAA;AAAEI,MAAAA,MAAAA,EAAAA;AAAF,KAAA,KAAmBA;AAFsB,GAATsQ,CAf7BL;AAAAA,MAmBHQ,CAAAA,GAAYR,CAAAA,CAASQ,QAATR,GAAoB7K,CAAAA,CAAKlF,GAALkF,CAAS;AAC7CkD,IAAAA,KAAAA,EAAO,UADsC;AAE7C1I,IAAAA,EAAAA,EAAI,CAAA;AAAEuG,MAAAA,KAAAA,EAAAA;AAAF,KAAA,KAAkBA;AAFuB,GAATf,CAnB7B6K;AAAAA,MAwBHS,CAAAA,GAAe7Q,CAAAA,CAAW;AAC9BoB,IAAAA,KAAAA,EAAO;AACL0P,MAAAA,UAAAA,EAAYV,CAAAA,CAASE,GAATF,CAAaW,UAAbX,GAA0B,MAAM9H,CADvC;AAELkI,MAAAA,OAAAA,EAASD;AAFJ,KADuB;AAK9BvP,IAAAA,IAAAA,EAAM,CACJyE,EAAAA,CAAS;AACP1F,MAAAA,EAAAA,CAAAA;AAAGgF,QAAAA,MAAAA,EAACA,CAAJhF;AAAGgF,QAAAA,GAAAA,EAAS+K;AAAZ/P,OAAAA,EAAY+P;AAAOU,QAAAA,OAAAA,EAASD,CAAhBT;AAAMgB,QAAAA,UAAAA,EAAkBA;AAAxBhB,OAAZ/P,EAAiD0D,CAAjD1D,EAAiD0D;AAAAA,YAe3CtD,CAf2CsD;AAAAA,YACzCuN,CAAAA,GAAYC,EAAAA,CAAU;AAC1BlM,UAAAA,MAAAA,EAAAA,CAD0B;AAE1B+K,UAAAA,GAAAA,EAAAA,CAF0B;AAG1BoB,UAAAA,EAAAA,EAAI,CAHsB;AAI1BX,UAAAA,MAAAA,EAAAA,CAJ0B;AAK1B9M,UAAAA,KAAAA,EAAAA;AAL0B,SAAVwN,CAD6BxN;AAAAA,YAQzC0N,CAAAA,GAAWF,EAAAA,CAAU;AACzBlM,UAAAA,MAAAA,EAAAA,CADyB;AAEzB+K,UAAAA,GAAAA,EAAAA,CAFyB;AAGzBoB,UAAAA,EAAAA,EAAI,CAHqB;AAIzBX,UAAAA,MAAAA,EAAAA,CAJyB;AAKzB9M,UAAAA,KAAAA,EAAAA;AALyB,SAAVwN,CAR8BxN;;AAa7CA,YAAAA;AAIAtD,UAAAA,CAAAA,GAAS2Q,CAAAA,GAAa/L,CAAb+L,CAAT3Q;AACA,SALAsD,CAKA,OAAO2C,CAAP,EAAOA;AAAAA,iBAAAA,KACK+K,CAAAA,CAAS/K,CAAT+K,CADL/K;AAGLpI;;AAAAA,QAAAA,CAAAA,CAASmC,CAATnC,CAAAA,IAAoBE,CAAAA,CAAWiC,CAAAA,CAAOiR,IAAlBlT,CAApBF,GACFmC,CAAAA,CAAOiR,IAAPjR,CAAY6Q,CAAZ7Q,EAAuBgR,CAAvBhR,CADEnC,GAGFgT,CAAAA,CAAU7Q,CAAV6Q,CAHEhT;AAGQmC;;AAzBP,KAATsF,CADI,CALwB;AAoC9BhG,IAAAA,IAAAA,EAAM;AACJ0G,MAAAA,EAAAA,EAAI,IADA;AAEJkL,MAAAA,EAAAA,EAAI,QAFA;AAGJhB,MAAAA,MAAAA,EAAQ,CAAC,SAAD;AAHJ;AApCwB,GAAXrQ,CAxBZoQ;AAkETpP,EAAAA,CAAAA,CAAKI,KAALJ,CAAWsQ,MAAXtQ,GAAoB6P,CAApB7P,EACAA,CAAAA,CAAKW,GAALX,CAASZ,IAATY,CACEyE,EAAAA,CAAa;AACX1F,IAAAA,EAAAA,EAAE,CAACgF,CAAD,EAAS3D,CAAT,EAAgBqC,CAAhB,KAEK9D,EAAAA,CAAU8D,CAAV9D,CAAAA,GACE;AACLoF,MAAAA,MAAAA,EAAAA,CADK;AAEL+K,MAAAA,GAAAA,EAAK;AACHE,QAAAA,EAAAA,CAAGvP,CAAHuP,EAAGvP,CAAAA,CADA;;AAEHwP,QAAAA,EAAAA,CAAGxP,CAAHwP,EAAGxP,CAAAA;;AAFA;AAFA,KADFd,GAAyBoF;AAHrB,GAAbU,CADFzE,EAcEyE,EAAAA,CAAS;AACP1F,IAAAA,EAAAA,EAAE,CAAC6J,CAAD,EAACA;AAAK0H,MAAAA,MAAAA,EAACA;AAAN1H,KAAD,EAAgBnG,CAAhB,MACAgB,CAAAA,CAAO;AACL1D,MAAAA,MAAAA,EAAQuQ,CADH;AAELvM,MAAAA,MAAAA,EAAQ6E,CAFH;AAGL5E,MAAAA,KAAAA,EAAO,CAHF;AAIL1B,MAAAA,QAAAA,EAAU2B,EAAAA,CAAYxB,CAAZwB;AAJL,KAAPR,CAAAA,EAMOmF,CAAAA,CAAI7E,MAPX;AADK,GAATU,CAdFzE,CADAA,EA2BAoP,CAAAA,CAAS3F,MAAT2F,GAAmBrL,CAAAA,IAAAA;AAAAA,QACX+K,CAAAA,GAAMD,CAAAA,EADK9K;AAAAA,QAEXL,CAAAA,GAAU;AAACK,MAAAA,MAAAA,EAAAA,CAAD;AAAS+K,MAAAA,GAAAA,EAAAA;AAAT,KAFC/K;;AAEQ+K,QACrBxM,EADqBwM,EACX;AAAA,UAAA,CACP7L,EADO,EACE;AAAA,YACNsN,CAAAA,GAAYjO,EADN;AAEZwM,QAAAA,CAAAA,CAAIA,GAAJA,CACGU,OADHV,CACW,MAAA;AACP3L,UAAAA,EAAAA,CAAYoN,CAAZpN,CAAAA;AAAYoN,SAFhBzB,EAIGI,KAJHJ,CAIS,MAAA,CAAA,CAJTA;AAMFrL;;AAAAA,MAAAA,CAAAA,CAAOnB,EAAAA,CAASuH,IAATvH,CAAc8M,CAAd9M,CAAPmB,EAAgCC,CAAhCD,CAAAA;AAAgCC,KAVToL,MAYvBrL,CAAAA,CAAO2L,CAAP3L,EAAiBC,CAAjBD,CAAAA;;AAAiBC,WAEZoL,CAAAA,CAAIA,GAFQpL;AAERoL,GA3Cb9O;AA2Ca8O,MAGP0B,CAAAA,GAAYpB,CAAAA,CAASoB,QAATpB,GAAoB9E,CAAAA,CAAY,CAAZA,EAAe;AAAC7C,IAAAA,KAAAA,EAAO;AAAR,GAAf6C,CAAAA,CACnCqB,EADmCrB,CAChC8E,CADgC9E,EACtBmG,CAAAA,IAAKA,CAAAA,GAAI,CADanG,EAEnCqB,EAFmCrB,CAEhCiF,CAFgCjF,EAExBmG,CAAAA,IAAKA,CAAAA,GAAI,CAFenG,CAHzBwE;AAAAA,MAOP4B,CAAAA,GAAWtB,CAAAA,CAASsB,OAATtB,GAAmBoB,CAAAA,CAASnR,GAATmR,CAAa;AAE/CzR,IAAAA,EAAAA,EAAI4R,CAAAA,IAAUA,CAAAA,GAAS,CAFwB;AAG/ClJ,IAAAA,KAAAA,EAAO;AAHwC,GAAb+I,CAPvB1B;AAUJ,SAGT7N,EAAAA,CAAImO,CAAJnO,EAAc,CACZsO,CADY,EAEZE,CAFY,EAGZlL,CAHY,EAIZoL,CAJY,EAKZC,CALY,EAMZc,CANY,EAOZF,CAPY,EAQZX,CARY,CAAd5O,CAAAA,EAUOmO,CAbE;ACpIJ;;AAAA,SAASyB,CAAT,CAAgBzJ,CAAhB,EAAgBA;AAAAA,MACjB0J,CADiB1J;AAErBwG,EAAAA,EAAAA,CAAgBxG,CAAhBwG,EAAwB,CAACC,CAAD,EAAeC,CAAf,KAAeA;AACrCgD,IAAAA,CAAAA,GAAWjD,CAAXiD,EACA1J,CAAAA,GAAS0G,CADTgD;AACShD,GAFXF,CAAAA;AAEWE,MAAAA;AAEP5N,IAAAA,MAAAA,EAACA,CAFM4N;AAEP5N,IAAAA,MAAAA,EAAS6Q,CAFFjD;AAEP5N,IAAAA,SAAAA,EAAiB8Q;AAFVlD,MAEuB1G,CAFvB0G;AAGNkD,EAAAA,CAAAA,KACHA,CAAAA,GAAY9Q,CAAAA,GACR,CAACiN,CAAD,EAASjN,CAAT,KAAyBA,CADjBA,GAEP6D,CAAAA,IAAgBA,CAHlBiN,CAAAA;;AAGkBjN,MAInBmN,CAJmBnN;AAAAA,MACjBkN,CAAAA,GAAW9B,CAAAA,CAAa/H,CAAb+H,EAAqB2B,CAArB3B,CADMpL;AAAAA,MACe+M;AAChCR,IAAAA,MAAAA,EAACA;AAD+BQ,MACrBtS,EAAAA,CAASyS,CAATzS,CAAAA,CAAmB4B,KAFb2D;AAAAA,MAKjBoN,CAAAA,GAAW,CAAA;AACdpN,IAAAA,MAAAA,EAAAA,CADc;AACN+K,IAAAA,GAAAA,EAAAA;AADM,GAAA,EACNA;AACRU,IAAAA,OAAAA,EAASD,CADDT;AACSiC,IAAAA,MAAAA,EAAAA;AADTjC,GADM,EAGfrM,CAHe,KAGfA;AAAAA,QASI2O,CATJ3O;AAAAA,QAEMwM,CAAAA,GAAKgB,EAAAA,CAAU;AACnBlM,MAAAA,MAAAA,EAAAA,CADmB;AAEnB+K,MAAAA,GAAAA,EAAAA,CAFmB;AAGnBoB,MAAAA,EAAAA,EAAI,CAHe;AAInBX,MAAAA,MAAAA,EAAAA,CAJmB;AAKnB9M,MAAAA,KAAAA,EAAAA;AALmB,KAAVwN,CAFXxN;;AAOEA,QAAAA;AAIA2O,MAAAA,CAAAA,GAAiBJ,CAAAA,CAAUjN,CAAViN,EAAkBvO,CAAAA,CAAMlB,CAAxByP,CAAjBI;AACA,KALA3O,CAKA,OAAO2C,CAAP,EAAOA;AAAAA,aACA6J,CAAAA,CAAG7J,CAAH6J,CADA7J;AAGT3B;;AAAAA,IAAAA,CAAAA,CAAO;AACL1D,MAAAA,MAAAA,EAAQgR,CADH;AAELhN,MAAAA,MAAAA,EAAQ;AACNA,QAAAA,MAAAA,EAAQqN,CADF;AAENtC,QAAAA,GAAAA,EAAK;AACHE,UAAAA,EAAAA,EAAIiB,EAAAA,CAAU;AACZlM,YAAAA,MAAAA,EAAAA,CADY;AAEZ+K,YAAAA,GAAAA,EAAAA,CAFY;AAGZoB,YAAAA,EAAAA,EAAI,CAHQ;AAIZX,YAAAA,MAAAA,EAAAA,CAJY;AAKZ9M,YAAAA,KAAAA,EAAAA;AALY,WAAVwN,CADD;AAQHhB,UAAAA,EAAAA,EAAAA;AARG;AAFC,OAFH;AAeL5M,MAAAA,IAAAA,EAAMI,CAAAA,CAAMJ,IAfP;AAgBL2B,MAAAA,KAAAA,EAAO;AAhBF,KAAPP,CAAAA;AAgBS,GAvCYM;;AAuCZ,MAGP7D,CAHO,EAGC;AAAA,QACNqL,CADM;AAENxF,IAAAA,CAAAA,CAAS7F,CAAT6F,CAAAA,IACFwF,CAAAA,GAAQrL,CAARqL,EACAtK,EAAAA,CAAIf,CAAJe,EAAY,CAACgQ,CAAD,CAAZhQ,CAFE8E,KAIFwF,CAAAA,GAAQmC,CAAAA,CAAQxN,CAARwN,CAARnC,EACAtK,EAAAA,CAAIgQ,CAAJhQ,EAAc,CAACsK,CAAD,CAAdtK,CALE8E;AAKawF,QAEX8F,CAAAA,GAAe5M,EAAAA,CAAS;AAC5BxE,MAAAA,IAAAA,EAAMH,CADsB;AAE5BH,MAAAA,KAAAA,EAAO6M,EAAAA,CAAcjB,CAAdiB,CAFqB;AAG5B3M,MAAAA,EAAAA,ER/De;AQ4Da,KAAT4E,CAFJ8G;AAOjB2F,IAAAA,CAAAA,GAAc,CAEZzM,EAAAA,CAAS;AAAC1F,MAAAA,EAAAA,EAAIoO,CAAAA,IAAKA;AAAV,KAAT1I,CAFY,EAIZ4M,CAJY,EAMZ5M,EAAAA,CAAa;AAAC1F,MAAAA,EAAAA,EAAIoS;AAAL,KAAb1M,CANY,CAAdyM,EAQA5R,EAAAA,CAAS+R,CAAT/R,EAAuBgR,CAAAA,CAAO5Q,GAA9BJ,CARA4R;AAQ8BxR,GAzBrB,MA2BTwR,CAAAA,GAAc,CAACzM,EAAAA,CAAS;AAAC1F,IAAAA,EAAAA,EAAIoS;AAAL,GAAT1M,CAAD,CAAdyM;;AAA6BC,SAE/BlQ,EAAAA,CAAI8P,CAAJ9P,EAAY,CAACgQ,CAAD,CAAZhQ,CAAAA,EACAqP,CAAAA,CAAOlQ,KAAPkQ,CAAaS,MAAbT,GAAsBS,CADtB9P,EAEAqP,CAAAA,CAAO7R,IAAP6R,CAAYjB,MAAZiB,CAAmBlR,IAAnBkR,CR1FoB,QQ0FpBA,CAFArP,EAGAqP,CAAAA,CAAO3P,GAAP2P,CAAWtJ,MAAXsJ,CAAkB,CAAlBA,EAAqB,CAArBA,EAAqB,GAAMY,CAA3BZ,CAHArP,EAIA0G,EAAAA,CAAgBoJ,CAAhBpJ,EAAwBsJ,CAAxBtJ,ER5FoB,QQ4FpBA,CAJA1G,EAKOgQ,CAPwBE;AClF1B;;AAAA,SAASG,CAAT,CAASA,GAAa/H,CAAtB,EAAsBA;AAAAA,MAAAA,CAAAA,CACrB5J,CADqB4J,EACdgI,CADchI,CAAAA,EACJiI,CADIjI,IACQkI,EAAAA,CAAoBlI,CAApBkI,CADRlI;AAAAA,MAErBpK,CAAAA,GAAqC,EAFhBoK;AAEgB,SAC3C7C,CAAAA,CAAM6K,CAAN7K,EAAe,CAAC3H,CAAD,EAAK+G,CAAL,KAAKA;AAAAA,QACZuD,CAAAA,GAASlK,CAAAA,CAAO2G,CAAP3G,CAAAA,GAAc6J,CAAAA,CAAYlD,CAAZkD,EAAiB;AAC5CtK,MAAAA,MAAAA,EAAQC,EAAAA,CAAUgB,CAAVhB,CADoC;AAE5CyI,MAAAA,MAAAA,EAAQoK;AAFoC,KAAjBxI,CADXlD;AAKlBnG,IAAAA,CAAAA,CAAMgM,EAANhM,CAAS0J,CAAT1J,EAAgBZ,CAAhBY,GACAgI,EAAAA,CAAgBhI,CAAhBgI,EAAuB0B,CAAvB1B,CADAhI;AACuB0J,GANzB3C,CAAAA,EAQOvH,CAToC;ACoCtC;;AAAA,SAAS6S,CAAT,CAAsBtI,CAAtB,EAAyCC,CAAzC,EAAyCA;AAAAA,MACxCsI,CAAAA,GAAuB,IAAIlP,GAAJ,EADiB4G;AAAAA,MAExCgE,CAAAA,GAA0B,IAAI5K,GAAJ,EAFc4G;AAAAA,MAGxCuI,CAAAA,GAAsC,IAAInP,GAAJ,EAHE4G;AAAAA,MAIxCwI,CAAAA,GAA0B,IAAIpP,GAAJ,EAJc4G;AAAAA,MAMxC3J,CAAAA,GAAOhB,CAAAA,CAAW;AACtBqB,IAAAA,MAAAA,EAAQ;AAACb,MAAAA,IAAAA,EVhDS;AUgDV,KADc;AAEtBe,IAAAA,QAAAA,EAAU;AAFY,GAAXvB,CANiC2K;AAAAA,MAWxCxK,CAAAA,GAAc;AAClBiT,IAAAA,OAAAA,EAAS;AACPH,MAAAA,OAAAA,EAAAA,CADO;AAEPtE,MAAAA,MAAAA,EAAAA,CAFO;AAGPuE,MAAAA,OAAAA,EAAAA,CAHO;AAIPC,MAAAA,MAAAA,EAAAA;AAJO,KADS;AAOlBvI,IAAAA,QAAAA,EAAU5J;AAPQ,GAX0B2J;AAqB9C3J,EAAAA,CAAAA,CAAKvB,IAALuB,GAAY+H,EAAAA,CV9DQ,QU8DRA,EAAiB5I,CAAjB4I,EAAyB4B,CAAzB5B,EAAsC2B,CAAtC3B,CAAZ/H;AAAkD0J,MAAAA,CAC3CL,CAD2CK,EACpCqH,CADoCrH,EAC5B/J,CAD4B+J,EACrB2I,CADqB3I,IACX,CACrC,SADqC,EAErC,UAFqC,EAGrC,SAHqC,EAIrC,UAJqC,EAKrCrK,GALqC,CAKjC0J,EALiC,CADWW;AAQlDvK,EAAAA,CAAAA,CAAO0I,KAAP1I,GAAe;AACbkK,IAAAA,KAAAA,EAAAA,CADa;AAEb0H,IAAAA,MAAAA,EAAAA,CAFa;AAGbpR,IAAAA,KAAAA,EAAAA,CAHa;AAIb0S,IAAAA,MAAAA,EAAAA;AAJa,GAAflT,EAMAA,CAAAA,CAAOmT,aAAPnT,GAAuBuS,EAAAA,CAAWrI,CAAXqI,EAAkBS,CAAlBT,EAA0BvS,CAA1BuS,CANvBvS,EAOAA,CAAAA,CAAOoT,cAAPpT,GAAwBuS,EAAAA,CAAWX,CAAXW,EAAmBQ,CAAnBR,EAA4BvS,CAA5BuS,CAPxBvS,EAQAA,CAAAA,CAAOqT,aAAPrT,GAAuBuS,EAAAA,CAAW/R,CAAX+R,EAAkB/D,CAAlB+D,EAA0BvS,CAA1BuS,CARvBvS,EASAA,CAAAA,CAAOsT,cAAPtT,GAAwBuS,EAAAA,CAAWW,CAAXX,EAAmBO,CAAnBP,EAA4BvS,CAA5BuS,CATxBvS,EAWAA,CAAAA,CAAO6J,WAAP7J,GAAqBA,CAAAA,CAAOkK,KAAPlK,GAAe,CAACuK,CAAD,EAAoBtC,CAApB,KAClCiC,CAAAA,CACEL,CAAAA,CAAYU,CAAZV,EAA0B;AACxBtK,IAAAA,MAAAA,EAAQS,CADgB;AAExBiI,IAAAA,MAAAA,EAAAA;AAFwB,GAA1B4B,CADFK,CAZFlK,EAkBAA,CAAAA,CAAOgQ,YAAPhQ,GAAsBA,CAAAA,CAAO4R,MAAP5R,GAAgB,CAACuK,CAAD,EAAoBtC,CAApB,KACpC2J,CAAAA,CACE5B,CAAAA,CAAazF,CAAbyF,EAA2B;AACzBzQ,IAAAA,MAAAA,EAAQS,CADiB;AAEzBiI,IAAAA,MAAAA,EAAAA;AAFyB,GAA3B+H,CADF4B,CAnBF5R,EAyBAA,CAAAA,CAAO6S,YAAP7S,GAAsBA,CAAAA,CAAOkT,MAAPlT,GAAgB,CAACuK,CAAD,EAAoBtC,CAApB,KACpC4K,CAAAA,CAAa;AACXnT,IAAAA,IAAAA,EAAM6K,CADK;AAEXhL,IAAAA,MAAAA,EAAQS,CAFG;AAGXiI,IAAAA,MAAAA,EAAAA;AAHW,GAAb4K,CA1BF7S,EA+BAA,CAAAA,CAAOmL,WAAPnL,GAAqBA,CAAAA,CAAOQ,KAAPR,GAAe,CAACoM,CAAD,EAAanE,CAAb,KAClCzH,CAAAA,CACE2K,CAAAA,CAAYiB,CAAZjB,EAAmB;AACjB5L,IAAAA,MAAAA,EAAQS,CADS;AAEjBiI,IAAAA,MAAAA,EAAAA;AAFiB,GAAnBkD,CADF3K,CAhCFR;AAmCMiI,MAGA1I,CAAAA,GAASC,EAAAA,CAAUQ,CAAVR,CAHTyI;AAGmBjI,SACrBT,CAAAA,KACFgI,CAAAA,CAAMvH,CAAAA,CAAO0I,KAAbnB,EAAoB,CAACzG,CAAD,EAAiB6F,CAAjB,KAAiBA;AACnC4M,IAAAA,EAAAA,CAAQ;AAACzS,MAAAA,IAAAA,EAAAA,CAAD;AAAOJ,MAAAA,EAAAA,EAAInB,CAAAA,CAAOmJ,KAAPnJ,CAAaoH,CAAbpH;AAAX,KAARgU,CAAAA;AAAgC5M,GADlCY,CAAAA,EAGAhI,CAAAA,CAAOmJ,KAAPnJ,CAAa2T,MAAb3T,CAAoBS,CAApBT,CAJEA,CAAAA,EAMGS,CAPkBA;ACvGpB;;AAAA,SAASwT,CAAT,CAA2BC,CAA3B,EAA2BA;AAChCzV,EAAAA,CAAAA,CAAayV,CAAbzV,CAAAA;AAAayV,MACPC,CAAAA,GACJhK,CAAAA,IAAoB+J,CAApB/J,GAAiC+J,CAAAA,CAAW/J,CAAX+J,CAAAA,EAAjC/J,GAAkE+J,CAFvDA;AAGRC,EAAAA,CAAAA,CAAepK,SAAfoK,IACHzV,CAAAA,CAAW,sCAAXA,CADGyV;AACQ,MACPxJ,CAAAA,GAAQL,CAAAA,EADD;AAAA,MAEP8J,CAAAA,GAAWC,EAAAA,CAAMC,EAAND,EAAiB1J,CAAjB0J,EAAiB1J,KAAOpE,CAAxB8N,CAFJ;AAE4B9N,SACzC4N,CAAAA,CAAepK,SAAfoK,CAAyB;AACvB/R,IAAAA,IAAAA,EAAMuI,CADiB;AAEvB/D,IAAAA,KAAAA,EAAOwN,CAFgB;AAGvBG,IAAAA,QAAAA,EAAUH;AAHa,GAAzBD,GAKOxJ,CANkCpE;ACTpC;;AAAA,SAAS3D,CAAT,CACL6Q,CADK,EAEL/K,CAFK,EAELA;AAAAA,MAEMjI,CAAAA,GAAS6J,CAAAA,CAAY5B,CAAAA,IAAUzB,CAAAA,CAAewM,CAAfxM,EAAuB,OAAvBA,CAAtBqD,CAFf5B;AAE4D,SAC5D3J,CAAAA,CAAc0U,CAAd1U,EAAsB,OAAtBA,EAA+B,gBAA/BA,CAAAA,EACAiV,EAAAA,CAAQ;AACNzS,IAAAA,IAAAA,EAAMkS,CADA;AAENtS,IAAAA,EAAAA,EAAIV,CAFE;AAGNV,IAAAA,IAAAA,EAAM;AAAC0G,MAAAA,EAAAA,EAAI;AAAL;AAHA,GAARuN,CADAjV,EAMO0B,CAPqD;ACuBvD;;AAAA,SAASiU,CAAT,CAASA,GAAU7J,CAAnB,EAAmBA;AAAAA,MACpBxJ,CADoBwJ;AAAAA,MAEpB1K,CAFoB0K;AAAAA,MAIpBrL,CAJoBqL;AAAAA,MAKpB+J,CALoB/J;AAAAA,MAKpB+J,CAAAA,CAFEpT,CAEFoT,EAFUD,CAEVC,EAFiBvU,CAEjBuU,CAAAA,EAFsB9B,CAEtB8B,IAFkC7B,EAAAA,CAAoBlI,CAApBkI,CAHdlI;AAGkCA,OAI5CtE,CAJ4CsE,KAItD8J,CAJsD9J,IAI/BvM,CAAAA,CAASkD,CAATlD,CAJ+BuM,IAhB5D,CAA8BnC,CAAAA,IAAAA;AAAAA,QACxB+L,CAAAA,GAAwB,CADA/L;AACA,WAC5BH,CAAAA,CAAQiM,EAARjM,EAA4B0H,CAAAA,IAAAA;AACtBA,MAAAA,CAAAA,IAASvH,CAATuH,KACmB,QAAjBvH,CAAAA,CAAOuH,CAAPvH,CAAiB,IACnBhK,CAAAA,CAAY,WAAUuR,CAAAA,oBAAtBvR,CADmB,EAGrB+V,CAAAA,GAAwB,CAJtBxE;AAIsB,KAL5B1H,CAAAA,EAQOkM,CATqB;AASrBA,GAVT,EAoBsEjT,CApBtE,CAgB4DqJ,KAKxD8J,CAAAA,GAAQnT,CAAAA,CAAOmT,KAAfA,EACAtU,CAAAA,GAAKmB,CAAAA,CAAOnB,EADZsU,EAEAC,CAAAA,GAASpT,CAAAA,CAAOoT,MAFhBD,EAIAtT,CAAAA,GAASG,CAAAA,CAAOH,MAJhBsT,EAKAxU,CAAAA,GAAOqB,CAAAA,CAAOrB,IALdwU,EAMAnV,CAAAA,GAAMgC,CAAAA,CAAOhC,GANbmV,EAOAnT,CAAAA,GAASA,CAAAA,CAAOA,MAZwCqJ;AAYxCrJ,MAEdqT,CAAAA,GAAgB,CAFFrT;AAEE,OACL+E,CADK,KAChB/E,CADgB,KAElBzC,CAAAA,CAAc4V,CAAd5V,EAAqB,QAArBA,EAA+B,OAA/BA,CAAAA,EACIC,KAAAA,CAAMC,OAAND,CAAc2V,CAAd3V,MACF2V,CAAAA,GAAQ/R,CAAAA,CAAM+R,CAAN/R,CADN5D,CADJD,EAIAyC,CAAAA,GAASmT,CAJT5V,EAKA8V,CAAAA,GAAgB,CAPE,GAShBA,CAAAA,IAAAA,CAAkBxN,CAAAA,CAAQ7F,CAAR6F,CAAlBwN,KACFrT,CAAAA,GAASwN,CAAAA,CAAQxN,CAARwN,CADP6F,CATgB,EAUDrT,KAEL+E,CAFK/E,KAEfmT,CAFenT,KAIjBmT,CAAAA,GAAQnT,CAJSA,CAVC,EAgBpBzC,CAAAA,CAAc4V,CAAd5V,EAAqB,QAArBA,EAA+B,OAA/BA,CAhBoB,EAiBpBoB,CAAAA,GAAO2S,CAAAA,IAAY3S,CAAZ2S,IAAoBtR,CAAAA,CAAOuF,SAjBd;AAiBcA,MAC5BzH,CAAAA,GAAWD,EAAAA,EADiB0H;AAAAA,MAE5B+N,CAAAA,GAAAA,CAAAA,CAAazT,CAFe0F;AAG7B1F,EAAAA,CAAAA,KACCgG,CAAAA,CAAS7F,CAAT6F,CAAAA,IAAoBA,CAAAA,CAASsN,CAATtN,CAApBA,GAIFhG,CAAAA,GAASuK,CAAAA,CAHYvL,CAAAA,GACjBA,CAAAA,CAAGgG,EAAAA,CAAQyH,EAAAA,CAActM,CAAdsM,CAARzH,CAAHhG,EAAmCgG,EAAAA,CAAQyH,EAAAA,CAAc6G,CAAd7G,CAARzH,CAAnChG,CADiBA,GAEjBgG,EAAAA,CAAQyH,EAAAA,CAActM,CAAdsM,CAARzH,CACKuF,EAA0B;AAACzL,IAAAA,IAAAA,EAAAA,CAAD;AAAOX,IAAAA,GAAAA,EAAAA;AAAP,GAA1BoM,CAJPvE,IAMFhG,CAAAA,GAASiJ,CAAAA,CAAYnK,CAAZmK,CAATjJ,EACI/B,CAAAA,IACFQ,EAAAA,CAASuB,CAATvB,CAAAA,CAAiBmC,GAAjBnC,CAAqBY,IAArBZ,CAA0BR,CAAAA,CAAS0O,MAAnClO,CARAuH,CADDhG,CAAAA;AASoC2M,MAInC+G,CAAAA,GACJD,CAAAA,IAAYzN,CAAAA,CAAQhG,CAARgG,CAAZyN,IAA+BhV,EAAAA,CAASuB,CAATvB,CAAAA,CAAiBC,IAAjBD,CAAsBsK,cALd4D;;AAKc5D,MACnD/C,CAAAA,CAAS7F,CAAT6F,CADmD+C,EACjC;AAAA,QACd4K,CAAAA,GAAYlH,EAAAA,CAActM,CAAdsM,CADE;AAEpBvL,IAAAA,EAAAA,CAAIf,CAAJe,EAAY,CACViI,EAAAA,CAAemK,CAAfnK,EAAsBnJ,CAAtBmJ,EAA8B;AAC5B9I,MAAAA,KAAAA,EAAO;AAACrB,QAAAA,EAAAA,EAAAA,CAAD;AAAK0U,QAAAA,cAAAA,EAAAA;AAAL,OADqB;AAE5BzT,MAAAA,IAAAA,EAAM,CACJhC,CAAAA,IAAYA,CAAAA,CAAS0O,MADjB,EACiBA,CAEpB4G,CAFoB5G,IAEVjI,EAAAA,CAAa;AAAC/B,QAAAA,QAAAA,EbzFZ;AayFW,OAAb+B,CAHP,EAIJA,EAAAA,CAAS;AACP9E,QAAAA,KAAAA,EAAO+T,CADA;AAEP7T,QAAAA,EAAAA,EAAId,CAAAA,GbnFK,GamFLA,GbzFK;AauFF,OAAT0F,CAJI,EAQJ1F,CAAAA,IAAM0F,EAAAA,CAAa;AAAC1F,QAAAA,EAAAA,EAAIuO;AAAL,OAAb7I,CARF,EASJzG,CAAAA,IAAYwV,CAAZxV,IAAwBA,CAAAA,CAASqM,MAT7B,CAFsB;AAa5B5L,MAAAA,IAAAA,EAAM;AAAC0G,QAAAA,EAAAA,Eb1FO,Qa0FR;AAAaiO,QAAAA,MAAAA,EAAQtT;AAArB;AAbsB,KAA9BoJ,CADU,CAAZjI,CAAAA,EAiBIjD,CAAAA,KAEC4I,EAAAA,CAAS5I,CAAAA,CAAS8M,KAAlBlE,EAAyB8M,CAAzB9M,CAAAA,IACAA,EAAAA,CAAS5I,CAAAA,CAASyP,OAAlB7G,EAA2B8M,CAA3B9M,CADAA,IAGD5I,CAAAA,CAASyP,OAATzP,CAAiBoB,IAAjBpB,CAAsB0V,CAAtB1V,CALAA,CAjBJiD;AAsB0ByS,GAzB2B5K,MA4BhD;AAAA,QACC6K,CAAAA,GAAYjJ,EAAAA,CAAe,CAAfA,CADb;AAAA,QAECkJ,CAAAA,GAAclJ,EAAAA,EAFf;AAAA,QAGCmJ,CAAAA,GAAanJ,EAAAA,EAHd;AAID1M,IAAAA,CAAAA,IACFA,CAAAA,CAAS8M,KAAT9M,CAAeoB,IAAfpB,CAAoB2V,CAApB3V,EAA+B4V,CAA/B5V,EAA4C6V,CAA5C7V,CADEA,EAGJgB,CAAAA,CAAW;AACTN,MAAAA,MAAAA,EAAQwB,CADC;AAETF,MAAAA,IAAAA,EAAM,CACJyE,EAAAA,CAAY;AAAC9E,QAAAA,KAAAA,EAAOiU;AAAR,OAAZnP,CADI,EAEJA,EAAAA,CAAS;AACPxE,QAAAA,IAAAA,EbnHW,OakHJ;AAEPN,QAAAA,KAAAA,EAAO,CAFA;AAGPI,QAAAA,MAAAA,EAAQ4T;AAHD,OAATlP,CAFI,CAFG;AAUTpE,MAAAA,MAAAA,EAAQ;AACNK,QAAAA,MAAAA,EAAQ,CAACR,CAAD,EAASH,CAAT,EAAiBsT,CAAjB,CADF;AAEN5S,QAAAA,KAAAA,EAAOV;AAFD,OAVC;AAcTtB,MAAAA,IAAAA,EAAM;AAAC0G,QAAAA,EAAAA,Eb1HS,Qa0HV;AAAaiO,QAAAA,MAAAA,EAAQ;AAArB,OAdG;AAeT7S,MAAAA,QAAAA,EAAU;AAfD,KAAXvB,CAHIhB,EAoBJiD,EAAAA,CAAIf,CAAJe,EAAY,CACViI,EAAAA,CAAemK,CAAfnK,EAAsBnJ,CAAtBmJ,EAA8B;AAC5B9I,MAAAA,KAAAA,EAAO;AACLrB,QAAAA,EAAAA,EAAAA,CADK;AAEL0U,QAAAA,cAAAA,EAAAA;AAFK,OADqB;AAK5BzT,MAAAA,IAAAA,EAAM,CACJhC,CAAAA,IAAYA,CAAAA,CAAS0O,MADjB,EAEJjI,EAAAA,CAAY;AAAC9E,QAAAA,KAAAA,EAAOkU;AAAR,OAAZpP,CAFI,EAGJA,EAAAA,CAAS;AAAC9E,QAAAA,KAAAA,EAAOgU;AAAR,OAATlP,CAHI,EAIJA,EAAAA,CAAY;AAAC1F,QAAAA,EAAAA,EAAI4U,CAAAA,IAAaA;AAAlB,OAAZlP,CAJI,EAI0BkP,CAE7BL,CAF6BK,IAEnBlP,EAAAA,CAAa;AAAC/B,QAAAA,QAAAA,EbhJZ;AagJW,OAAb+B,CANP,EAOJA,EAAAA,CAAS;AAAC9E,QAAAA,KAAAA,EAAOiU;AAAR,OAATnP,CAPI,EAQJA,EAAAA,CAAS;AACP9E,QAAAA,KAAAA,EAAOkU,CADA;AAEPhU,QAAAA,EAAAA,Eb3IS;AayIF,OAAT4E,CARI,EAYJ1F,CAAAA,IAAM0F,EAAAA,CAAa;AAAC1F,QAAAA,EAAAA,EAAIwO;AAAL,OAAb9I,CAZF,EAaJzG,CAAAA,IAAYwV,CAAZxV,IAAwBA,CAAAA,CAASqM,MAb7B,CALsB;AAoB5B5L,MAAAA,IAAAA,EAAM;AAAC0G,QAAAA,EAAAA,EblJO,QakJR;AAAaiO,QAAAA,MAAAA,EAAQ;AAArB;AApBsB,KAA9BlK,CADU,CAAZjI,CApBIjD;AAyC2B;;AAAA,SAI1B+B,CAJ0B;ACjJ5B;;AAAA,SAAS+T,CAAT,CAASA,GAASvK,CAAlB,EAAkBA;AAAAA,MACjB9K,CAAAA,GAA4B;AAAC0G,IAAAA,EAAAA,EAAI;AAAL,GADXoE;AAAAA,MAEnBnD,CAAAA,GAAU,OAFSmD;AAAAA,MAET,CAAA,CACRrJ,CADQ,EACAkH,CADA,CAAA,EACSoK,CADT,IACqBC,EAAAA,CAAoBlI,CAApBkI,CAHZlI;AAInBiI,EAAAA,CAAAA,KACF/S,CAAAA,CAAK2I,MAAL3I,GAAc+S,CAAd/S,EACI+S,CAAAA,CAAS3S,IAAT2S,KAAepL,CAAAA,GAAUoL,CAAAA,CAAS3S,IAAlC2S,CAFFA,CAAAA,EAICpK,CAAAA,KACHA,CAAAA,GAASlH,CAATkH,EACAlH,CAAAA,GAASkH,CAAAA,CAAOlH,MAFbkH,CAJDoK;AAMctR,MAAAA;AAAAA,IAAAA,MAAAA,EAEb8J,CAFa9J;AAEdoT,IAAAA,MAAAA,EAASA,CAFKpT;AAEdoT,IAAAA,KAAAA,EAAiBD,CAFHnT;AAEdoT,IAAAA,IAAAA,EAAwBzU,CAAAA,GAAOuH;AAFjBlG,MAE4BkH,CAF5BlH;AAAAA,MAGZH,CAAAA,GAASqH,CAAAA,CAAOrH,MAAPqH,IAAiB4B,CAAAA,CAAYnK,CAAZmK,EAAkBvK,CAAAA,CAAK2I,MAAvB4B,CAHd9I;AAAAA,MAIZ6T,CAAAA,GAAehO,CAAAA,CAAQiE,CAARjE,CAJH7F;AAAAA,MAKdqT,CAAAA,GAAgB,CALFrT;AAKE,SAAA,KACL+E,CADK,KAChB/E,CADgB,KAElBzC,CAAAA,CAAc4V,CAAd5V,EAAqB,OAArBA,EAA8B,OAA9BA,CAAAA,EACIC,KAAAA,CAAMC,OAAND,CAAc2V,CAAd3V,MACF2V,CAAAA,GAAQ/R,CAAAA,CAAM+R,CAAN/R,CADN5D,CADJD,EAIAyC,CAAAA,GAASmT,CAJT5V,EAKA8V,CAAAA,GAAgB,CAPE,GAShBA,CAAAA,IAAAA,CAAkBxN,CAAAA,CAAQ7F,CAAR6F,CAAlBwN,KAAmCrT,CAAAA,GAASwN,CAAAA,CAAQxN,CAARwN,CAA5C6F,CATgB,EAUhBF,CAAAA,KACF5V,CAAAA,CAAc4V,CAAd5V,EAAqB,OAArBA,EAA8B,OAA9BA,CAAAA,EACAyC,CAAAA,GAASkT,CAAAA,CAAO;AACdlT,IAAAA,MAAAA,EAAAA,CADc;AAEdmT,IAAAA,KAAAA,EAAAA,CAFc;AAGdC,IAAAA,MAAAA,EAAAA,CAHc;AAIdvU,IAAAA,EAAAA,EAAIgV,CAAAA,GAAe,IAAfA,GAAsB,CAAC7T,CAAD,EAAcmT,CAAd,MAAcA;AAAiBnT,MAAAA,MAAAA,EAAAA,CAAjBmT;AAAyBA,MAAAA,KAAAA,EAAAA;AAAzBA,KAAd;AAJZ,GAAPD,CAFPC,CAVgB,EAmBpB5V,CAAAA,CAAcsC,CAAdtC,EAAsB,OAAtBA,EAA+B,QAA/BA,CAnBoB,EAoBhBsW,CAAAA,GACFX,CAAAA,CAAO;AACLlT,IAAAA,MAAAA,EAAQ8J,CADH;AAELqJ,IAAAA,KAAAA,EAAOnT,CAFF;AAGLH,IAAAA,MAAAA,EAAQf,CAAAA,CAAW;AACjBgB,MAAAA,IAAAA,EAAM,CACJyE,EAAAA,CAAY;AACV1F,QAAAA,EAAAA,EAAI,CAAA;AAAE+U,UAAAA,KAAAA,EAAAA;AAAF,SAAA,KAAaA;AADP,OAAZrP,CADI,EAIJA,EAAAA,CAAa;AACX1F,QAAAA,EAAAA,EAAI,CAAA;AAAEU,UAAAA,IAAAA,EAAAA;AAAF,SAAA,KAAYA;AADL,OAAbgF,CAJI,CADW;AASjBtE,MAAAA,KAAAA,EAAOJ,CATU;AAUjBtB,MAAAA,IAAAA,EAAAA,CAViB;AAWjB4B,MAAAA,MAAAA,EAAQ;AACNK,QAAAA,MAAAA,EAAQ,CAACR,CAAD,EAAS8J,CAAT,EAAiBjK,CAAjB,EAAiBA,GAAW,GAAG0G,MAAH,CAAU4M,CAAAA,IAAgB,EAA1B,CAA5B,CADF;AAEN5S,QAAAA,KAAAA,EAAOV;AAFD,OAXS;AAejBQ,MAAAA,QAAAA,EAAU;AAfO,KAAXvB,CAHH;AAoBLD,IAAAA,EAAAA,EAAI,CAAC+U,CAAD,EAAarU,CAAb,MAAaA;AAAgBqU,MAAAA,KAAAA,EAAAA,CAAhBrU;AAAuBA,MAAAA,IAAAA,EAAAA;AAAvBA,KAAb,CApBC;AAqBL6T,IAAAA,MAAAA,EAAAA,CArBK;AAsBLzU,IAAAA,IAAAA,EAAAA;AAtBK,GAAPuU,CADEW,IA0BG7W,CAAAA,CAAW8M,CAAX9M,CAAAA,IAAoBE,CAAAA,CAAW,qCAAXA,CAApBF,EACLgM,EAAAA,CAAehJ,CAAfgJ,EAAuBnJ,CAAvBmJ,EAA+B;AAC7B9I,IAAAA,KAAAA,EAAO;AAACrB,MAAAA,EAAAA,EAAIiL;AAAL,KADsB;AAE7BhK,IAAAA,IAAAA,EAAMqT,CAAAA,GACF,CACE5O,EAAAA,CAAY;AACV1F,MAAAA,EAAAA,EAAI,CAAA;AAAEmB,QAAAA,MAAAA,EAAAA,CAAF;AAAUmT,QAAAA,KAAAA,EAAAA;AAAV,OAAA,EAAUA;AAAStU,QAAAA,EAAAA,EAAAA;AAATsU,OAAV,KAA2BtU,CAAAA,CAAGmB,CAAHnB,EAAWsU,CAAXtU;AADrB,KAAZ0F,CADF,EAIEA,EAAAA,CAAa;AACX1F,MAAAA,EAAAA,EAAI,CAAA;AAAEmB,QAAAA,MAAAA,EAAAA;AAAF,OAAA,KAAcA;AADP,KAAbuE,CAJF,CADE4O,GASF,CAAC5O,EAAAA,CAAY;AAAC1F,MAAAA,EAAAA,EAAIoK;AAAL,KAAZ1E,CAAD,CAXyB;AAY7BhG,IAAAA,IAAAA,EAAAA;AAZ6B,GAA/ByK,CA3BE6K,CApBgB,EA8DbhU,CA9Da;ACtBf;;AAAA,SAASiU,CAAT,CAAiBrN,CAAjB,EAA2B4D,CAA3B,EAA8CnD,CAA9C,EAA8CA;AAAAA,MAC/CrB,CAAAA,CAASY,CAATZ,CAD+CqB,EACtCT,OACJA,CADIA;;AACJA,MAELZ,CAAAA,CAAQY,CAARZ,CAFKY,EAES;AAAA,QAEZxH,CAFY;AAAA,QACVkT,CAAAA,GAAS1T,EAAAA,CAAUgI,CAAVhI,CADC;AACSgI,WAErBZ,CAAAA,CAASY,CAATZ,CAAAA,KACF5G,CAAAA,GAASmL,CAAAA,CAAYC,CAAZD,EAA0B;AACjC5L,MAAAA,MAAAA,EAAQ2T,CADyB;AAEjCxT,MAAAA,IAAAA,EAAM8H,CAAAA,CAAIlB,SAFuB;AAGjCwO,MAAAA,CAAAA,EAAG7M;AAH8B,KAA1BkD,CAAAA,CAINqB,EAJMrB,CAIH3D,CAJG2D,EAIE,CAAC6C,CAAD,EAAIxL,CAAJ,KAAUA,CAJZ2I,CADPvE,GAOAA,CAAAA,CAAUY,CAAVZ,CAAAA,KACF5G,CAAAA,GAASmL,CAAAA,CAAYC,CAAZD,EAA0B;AACjC5L,MAAAA,MAAAA,EAAQ2T,CADyB;AAEjCxT,MAAAA,IAAAA,EAAM8H,CAAAA,CAAIlB,SAFuB;AAGjCwO,MAAAA,CAAAA,EAAG7M;AAH8B,KAA1BkD,CAAAA,CAINqB,EAJMrB,CAIH3D,CAAAA,CAAI8I,IAJDnF,EAIO,CAAC6C,CAAD,EAACA;AAAShO,MAAAA,MAAAA,EAAAA;AAATgO,KAAD,KAA2BhO,CAJlCmL,CADPvE,CAPAA,EAcAsM,CAAAA,IAAQA,CAAAA,CAAOxK,KAAPwK,CAAa1S,KAAb0S,CAAmBlT,CAAnBkT,CAdRtM,EAeG5G,CAjBkBwH;AAiBlBxH;;AAAAA,MAEHA,CAAAA,GAA8BzB,KAAAA,CAAMC,OAAND,CAAciJ,CAAdjJ,IAAqB,EAArBA,GAA0B,EAFrDyB;AAEqD,SAC9DuH,CAAAA,CAAMC,CAAND,EAAW,CAACzJ,CAAD,EAAQ6I,CAAR,KAAQA;AACjB3G,IAAAA,CAAAA,CAAO2G,CAAP3G,CAAAA,GAAc4G,CAAAA,CAAS9I,CAAT8I,CAAAA,GAAkB9I,CAAlB8I,GAA0BuE,CAAAA,CAAYrN,CAAZqN,EAAmB;AAACzL,MAAAA,IAAAA,EAAMiH;AAAP,KAAnBwE,CAAxCnL;AAAkE2G,GADpEY,CAAAA,EAGOvH,CAJuD;ACIzD;;AAAA,SAASiV,CAAT,CAASA,GAAS7K,CAAlB,EAAkBA;AAAAA,MACnB8K,CADmB9K;AAAAA,MACnB8K,CAAAA,CACEnU,CADFmU,EACUC,CADVD,CAAAA,EACkB7C,CADlB6C,IAC8B5C,EAAAA,CAAoBlI,CAApBkI,CAFXlI;AAAAA,MAGjBgL,CAAAA,GAAAA,CAAcD,CAHG/K;AAInBgL,EAAAA,CAAAA,KACFF,CAAAA,GAAUnU,CAAAA,CAAOsU,KAAjBH,EACAC,CAAAA,GAAQpU,CAAAA,CAAOoU,KADfD,EAEAnU,CAAAA,GAASA,CAAAA,CAAOA,MAHdqU,CAAAA;AAGcrU,MAEZuU,CAAAA,GAAc1O,CAAAA,CAASuO,CAATvO,CAFF7F;AAAAA,MAGZwU,CAAAA,GAAAA,CAAmB3O,CAAAA,CAAQuO,CAARvO,CAAnB2O,IAAqCxX,CAAAA,CAAWoX,CAAXpX,CAHzBgD;AAAAA,MAIZyU,CAAAA,GAAAA,CAAgBF,CAAhBE,IAAgBF,CAAgBC,CAAhCC,IAAmD3X,CAAAA,CAASsX,CAATtX,CAJvCkD;AAKbmU,EAAAA,CAAAA,KAAUA,CAAAA,GAAU,EAApBA,CAAAA,EACAE,CAAAA,KACEI,CAAAA,IAAcvX,CAAAA,CAAW,2BAAXA,CAAduX,EACLjO,CAAAA,CAAM4N,CAAN5N,EAAa,CAACyG,CAAD,EAAIrH,CAAJ,KAAIA;AAEfuO,IAAAA,CAAAA,CAAQvO,CAARuO,CAAAA,GAAerL,CAAAA,CAAYwI,CAAZxI,CAAfqL;AAA2B7C,GAF7B9K,CADKiO,EAKLN,CAAAA,CAAQO,EAARP,GAAarL,CAAAA,CAAYwI,CAAZxI,CANVuL,CADAF;AAOsB7C,MAUvByD,CAVuBzD;AAAAA,MAGrBxT,CAAAA,GAAWD,EAAAA,EAHUyT;AAAAA,MAIrB9Q,CAAAA,GAAS,IAAIqC,GAAJ,CACZ,GAAkB0D,MAAlB,CAAyBvG,CAAzB,EAAiC2U,MAAAA,CAAOC,MAAPD,CAAcR,CAAdQ,CAAjC,CADY,CAJYrD;AAAAA,MAOrBuD,CAAAA,GAAYF,MAAAA,CAAOG,IAAPH,CAChBJ,CAAAA,IAAeC,CAAfD,GAAiCJ,CAAjCI,GAA2CH,CAD3BO,CAPSrD;AAQkB8C,MAGzCG,CAAAA,IAAeC,CAH0BJ,EAIvCG,CAAAA,IAAa/T,CAAAA,CAAOmE,GAAPnE,CAAW4T,CAAX5T,CAAb+T,EACJQ,CAAAA,GAAc,CACZR,CAAAA,IAAehQ,EAAAA,CAAa;AAAC/B,IAAAA,QAAAA,EAAU;AAAX,GAAb+B,CADH,EAEZgQ,CAAAA,IACEhQ,EAAAA,CAAS;AACP9E,IAAAA,KAAAA,EAAO6M,EAAAA,CAAc8H,CAAd9H,CADA;AAEP3M,IAAAA,EAAAA,EAAI;AAFG,GAAT4E,CAHU,EAOZA,EAAAA,CAAY;AACV1F,IAAAA,EAAAA,CAAGU,CAAHV,EAASoV,CAATpV,EAAuB0D,CAAvB1D,EAAuB0D;AAAAA,UACfxF,CAAAA,GAAQiY,MAAAA,CAAOT,CAAAA,GAAchS,CAAAA,CAAMlB,CAApBkT,GAAwBH,CAAAA,CAAM7U,CAAN6U,CAA/BY,CADOzS;AAErByR,MAAAA,EAAAA,CACEC,CADFD,EAEEtN,EAAAA,CAASmO,CAATnO,EAAoB3J,CAApB2J,CAAAA,GAA6B3J,CAA7B2J,GAAqC,IAFvCsN,EAGEzU,CAHFyU,EAIEzR,CAJFyR,CAAAA;AAIEzR;;AAPM,GAAZgC,CAPY,CADVgQ,CAJuCH,KAwBtC,IAAIK,CAAJ,EAAkB;AAAA,QACjBQ,CAAAA,GAAazK,EAAAA,CAAe,EAAfA,CADI;AAEvByK,IAAAA,CAAAA,CAAW3V,IAAX2V,GAAkB,OAAlBA;AAAkB,QAcdE,CAdc;AAAA,QACZ5I,CAAAA,GAAiB0I,CAAAA,CAAW1I,MAAX0I,GAAoB,EADzB;AAAA,QAEZC,CAAAA,GAAe,CACnB3Q,EAAAA,CAAS;AACP9E,MAAAA,KAAAA,EAAOwV,CADA;AAEPtV,MAAAA,EAAAA,EhB9Ea;AgB4EN,KAAT4E,CADmB,EAKnBA,EAAAA,CAAa;AACX1F,MAAAA,EAAAA,CAAG6J,CAAH7J,EAAG6J;AAAK9C,QAAAA,GAAAA,EAACA;AAAN8C,OAAH7J,EAAS+G;AAAMvE,QAAAA,CAAAA,EAACA;AAAPuE,OAAT/G,EAAgBwC;AACdA,QAAAA,CAAAA,CAAEuE,CAAFvE,CAAAA,GAASqH,CAATrH;AAASqH;;AAFA,KAAbnE,CALmB,CAFH;AAAA,QAaZiH,CAAAA,GAAQ,EAbI;AAelBhF,IAAAA,CAAAA,CAAM4N,CAAN5N,EAAa,CAAC4O,CAAD,EAAiBxP,CAAjB,KAAiBA;AAAAA,UACxBC,CAAAA,CAAQuP,CAARvP,CADwBD,EACJ;AACtBuP,QAAAA,CAAAA,GAAc,CAAdA,EACA3J,CAAAA,CAAMtM,IAANsM,CAAW5F,CAAX4F,CADA2J,EAEA3U,CAAAA,CAAOmE,GAAPnE,CAAW4U,CAAX5U,CAFA2U;AAEWC,YACLC,CAAAA,GAAUrM,EAAAA,CAAeoM,CAAfpM,EAA0B,EAA1BA,EAA8B;AAC5ClJ,UAAAA,IAAAA,EAAMoV,CADsC;AAE5ChV,UAAAA,KAAAA,EAAO;AAAC0F,YAAAA,GAAAA,EAAAA;AAAD;AAFqC,SAA9BoD,CADLoM;;AAGDxP,YAENC,CAAAA,CAASuP,CAATvP,CAFMD,EAEe;AACvBqP,UAAAA,CAAAA,CAAWnQ,OAAXmQ,CAAmBrP,CAAnBqP,IAA0BG,CAAAA,CAAUnK,QAAVmK,EAA1BH;AAAoChK,cAC9BkC,CAAAA,GAAWb,EAAAA,CAAc8I,CAAd9I,CADmBrB;AAEpCsB,UAAAA,CAAAA,CAAOrN,IAAPqN,CAAY;AACVjN,YAAAA,IAAAA,EAAM,OADI;AAEVmP,YAAAA,KAAAA,EAAO7I,CAFG;AAGV7F,YAAAA,IAAAA,EAAMoN;AAHI,WAAZZ,GAKIzO,CAAAA,KACG4I,EAAAA,CAAS5I,CAAAA,CAAS8M,KAAlBlE,EAAyByG,CAAzBzG,CAAAA,IACH2O,CAAAA,CAAQ5U,GAAR4U,CAAY5I,OAAZ4I,CAAoBvX,CAAAA,CAAS0O,MAA7B6I,CAFAvX,CALJyO;AAOiCC;AAAAA;AAAAA,KAnBvChG,CAAAA,EAyBI2O,CAAAA,IAAgBrX,CAAhBqX,IACFrX,CAAAA,CAAS8M,KAAT9M,CAAeoB,IAAfpB,CAAoBmX,CAApBnX,CA1BF0I,EA4BAuO,CAAAA,GAAc,CACZI,CAAAA,IAAgB5Q,EAAAA,CAAa;AAAC/B,MAAAA,QAAAA,EAAU;AAAX,KAAb+B,CADJ,EAEZ4Q,CAAAA,IACE5Q,EAAAA,CAAS;AACP9E,MAAAA,KAAAA,EAAOwV,CADA;AAEPtV,MAAAA,EAAAA,EAAI;AAFG,KAAT4E,CAHU,EAOZA,EAAAA,CAAY;AACV1F,MAAAA,EAAAA,CAAGU,CAAHV,EAASoV,CAATpV,EAAuB0D,CAAvB1D,EAAuB0D;AAAAA,aAChB,IAAI7E,CAAAA,GAAI,CADQ6E,EACL7E,CAAAA,GAAImX,CAAAA,CAAUlX,MADT4E,EACiB7E,CAAAA,EADjB6E,EACsB;AAAA,cACnC+S,CAAAA,GAAWT,CAAAA,CAAUnX,CAAVmX,CADwB;AACdnX,cACTgJ,EAAAA,CAAS8E,CAAT9E,EAAgB4O,CAAhB5O,CAAAA,GACdnE,CAAAA,CAAMlB,CAANkB,CAAQ+S,CAAR/S,CADcmE,GAEd0N,CAAAA,CAAMkB,CAANlB,CAAAA,CAAgB7U,CAAhB6U,CAHuB1W,EAGP6B,OAAAA,KAElByU,EAAAA,CAAWC,CAAXD,EAAyBsB,CAAzBtB,EAAmCzU,CAAnCyU,EAAyCzR,CAAzCyR,CAFkBzU;AAMtByU;;AAAAA,QAAAA,EAAAA,CAAWC,CAAXD,EAAyB,IAAzBA,EAA+BzU,CAA/ByU,EAAqCzR,CAArCyR,CAAAA;AAAqCzR;;AAZ7B,KAAZgC,CAPY,CA5BdiC;AA+C2CjE,GAhEtC,MAqELrF,CAAAA,CAAW,6CAAXA,CAAAA;AAAW,MAEb4B,CAAAA,CAAW;AACTP,IAAAA,IAAAA,EAAM;AACJ4Q,MAAAA,MAAAA,EAAQwF,MAAAA,CAAOG,IAAPH,CAAYR,CAAZQ,CADJ;AAEJ1P,MAAAA,EAAAA,EAAI;AAFA,KADG;AAKTzG,IAAAA,MAAAA,EAAQwB,CALC;AAMTE,IAAAA,KAAAA,EAAOiU,CANE;AAOTrU,IAAAA,IAAAA,EAAMiV,CAPG;AAQT5U,IAAAA,MAAAA,EAAQ;AACNb,MAAAA,IAAAA,EAAM,WADA;AAENkB,MAAAA,MAAAA,EAAQhD,KAAAA,CAAMuC,IAANvC,CAAWgD,CAAXhD;AAFF,KARC;AAYT6C,IAAAA,QAAAA,EAAU;AAZD,GAAXvB,CAAAA,EAYY,CAEPuV,CAhBQ,EAgBI,OAAOF,CAAP;AClJZ;;AAAA,SAASoB,CAAT,CAAiBpD,CAAjB,EAAiBA;AAAgByC,EAAAA,MAAAA,EAACA;AAAjBzC,CAAjB,EAAkCyC;AAAAA,MACjCY,CAAAA,GAAU1Y,CAAAA,CAASqV,CAATrV,CAAAA,IAAqBqV,CAAAA,CAAesD,OADbb;AAElC/O,EAAAA,CAAAA,CAAUsM,CAAVtM,CAAAA,IAAsB2P,CAAtB3P,IACH3I,CAAAA,CAAW,qDAAXA,CADG2I,EAGA/I,CAAAA,CAAS8X,CAAT9X,CAAAA,IACHI,CAAAA,CAAW,qCAAXA,CAJG2I;AAIQ,MAGT+P,CAHS;AAAA,MAITC,CAJS;AAAA,MAEPH,CAAAA,GAAmBC,CAAAA,CAAgBf,CAAhBe,CAFZ;AAE4Bf,MAGrCY,CAHqCZ,EAIvCgB,CAAAA,GAAe,EAAfA,EACAC,CAAAA,GAAmB,EADnBD,EAEApP,CAAAA,CAAMkP,CAANlP,EAAwB,CAACsP,CAAD,EAAM9X,CAAN,KAAMA;AAAAA,QAEtB8B,CAAAA,GAAOqS,CAAAA,CAAO4D,MAAP5D,CAAcnU,CAAdmU,CAFenU;AAGxB8B,IAAAA,CAAAA,KACF8V,CAAAA,CAAa1W,IAAb0W,CAAkB9V,CAAlB8V,GACAC,CAAAA,CAAiB3W,IAAjB2W,CAAsBC,CAAtBD,CADAD,EAEEzD,CAAAA,CAAe6D,aAAf7D,CAA6BxN,GAA7BwN,CAAiCrS,CAAAA,CAAKvB,IAALuB,CAAUmW,MAAVnW,CAAiBJ,EAAlDyS,CAHArS,CAAAA;AAGkDJ,GANxD8G,CAFAoP,CAJuChB,KAelC;AAAA,QACCsB,CAAAA,GAgBV,CAAA,CAAA;AAAoBE,MAAAA,cAAAA,EAClBA,CADF;AAAoBA,MAAAA,MAAAA,EAElBxB,CAFF;AAAoBwB,MAAAA,cAAAA,EAGlBE;AAHF,KAAA,KAGEA;AAAAA,UAMMV,CAAAA,GAAuB,EAN7BU;AAAAA,UAOMT,CAAAA,GAA+B,EAPrCS;AAAAA,UAQMC,CAAAA,GAAU,EARhBD;AAAAA,UASME,CAAAA,GAAiB,IAAI3T,GAAJ,EATvByT;AAAAA,UAUMG,CAAAA,GAAgB9B,MAAAA,CAAO+B,mBAAP/B,CAA2BC,CAA3BD,CAVtB2B;AAUiD1B,aACjD7N,CAAAA,CAAQqP,CAARrP,EAAwBjH,CAAAA,IAAAA;AAAAA,YAAAA;AAChBN,UAAAA,GAAAA,EAACA;AADeM,YACRA,CADQA;AAAAA,YACRA;AACRmF,UAAAA,EAAAA,EAACA,CADOnF;AACRmF,UAAAA,IAAAA,EAAK9G,CADG2B;AACRmF,UAAAA,GAAAA,EAAWjH;AADH8B,YACUA,CAAAA,CAAKvB,IAFPuB;;AAEOvB,YACzBJ,CAAAA,KAASyB,CAATzB,IACEH,CADFG,IACSuI,EAAAA,CAAS+P,CAAT/P,EAAwB1I,CAAxB0I,CAFgBnI,EAEc;AAAA,cAAA;AACjC8M,YAAAA,KAAAA,EAACA;AADgC,cACvBvL,CAAAA,CAAKI,KADkB;AAEvCmL,UAAAA,CAAAA,CAAMvG,OAANuG,GAAgBuJ,CAAAA,CAAO5W,CAAP4W,CAAhBvJ,EACAmL,CAAAA,CAAe7R,GAAf6R,CAAmBnL,CAAnBmL,CADAnL;AACmBA;;AAAAA,YAGnBiL,CAAAA,IAAyB,YAAPrR,CAHCoG,EAGe;AAAA,cAC9BsL,CAAAA,GAAQ7W,CAAAA,CAAKK,MAALL,CAAYU,MAAZV,CAAmB,CAAnBA,CADsB;AAEhC6W,UAAAA,CAAAA,CAAMpY,IAANoY,CAAWxY,IAAXwY,KAAoB/W,CAApB+W,KACFf,CAAAA,CAAa1W,IAAb0W,CAAkB9V,CAAlB8V,GACAC,CAAAA,CAAiB3W,IAAjB2W,CAAsBc,CAAAA,CAAMzW,KAANyW,CAAYtL,KAAlCwK,CAFEc;AAKNnQ;;AAAAA,QAAAA,CAAAA,CAAMhH,CAANgH,EAAW,CAAC8G,CAAD,EAAM5N,CAAN,KAAMA;AACf6W,UAAAA,CAAAA,CAAQ7W,CAAR6W,CAAAA,GAAcjJ,CAAdiJ;AAAcjJ,SADhB9G,CAAAA;AACgB8G,OAlBlBvG,CAAAA,EAuBAA,CAAAA,CADe8P,CAAAA,CADED,CAAAA,CAAeL,CAAfK,CACFC,CACf9P,EAAgBrH,CAAAA,IAAAA;AAAAA,SASC4N,CAAAA,IAAAA;AAAAA,cACXgB,CAAAA,GAAU,CADChB;AACD,cACVA,CAAAA,CAAIf,MAAJe,IAAIf,CAAWiK,CAAAA,CAAe9R,GAAf8R,CAAmBlJ,CAAnBkJ,CAAflJ,IACFvG,CAAAA,CAAQuG,CAAAA,CAAIf,MAAZxF,EAAoBgQ,CAAAA,IAAAA;AAAAA,oBACVA,CAAAA,CAAIzX,IADMyX;AACNzX,mBACL4B,CADK5B;AAGRgO,gBAAAA,CAAAA,CAAIxI,OAAJwI,GAAcyJ,CAAAA,CAAIlY,EAAJkY,CADDA,CAAAA,CAAIhX,IAAJgX,CACajS,OAAZiS,CAAdzJ;AAA0BxI;;AAAAA,mBAGvB,OAHuBA;AAGvB;AAAA,sBACG/E,CAAAA,GAAOgX,CAAAA,CAAIhX,IADd;AAEEuO,kBAAAA,CAAAA,KACHA,CAAAA,GAAU,CAAVA,EAEEhB,CAAAA,CAAIxI,OAAJwI,GADE9P,KAAAA,CAAMC,OAAND,CAAc8P,CAAAA,CAAIxI,OAAlBtH,IACY,CAAA,GAAI8P,CAAAA,CAAIxI,OAAR,CADZtH,GAGY,EAAA,GAAI8P,CAAAA,CAAIxI;AAAR,mBALbwJ,CAAAA,EAQLhB,CAAAA,CAAIxI,OAAJwI,CAAYyJ,CAAAA,CAAItI,KAAhBnB,IAAyBvN,CAAAA,CAAK+E,OARzBwJ;AAQyBxJ;AAAAA;AAjBhBiS;AAiBgBjS,WAjBpCiC,CADEuG,EAkBkCxI,CAQjCwI,CAAAA,CAAI3C,KA3BK,EA2BE;AAAA,cACV5N,CAAAA,GAAQuQ,CAAAA,CAAIxI,OADF;AAEhBiC,UAAAA,CAAAA,CAAQuG,CAAAA,CAAI3C,KAAZ5D,EAAmBgQ,CAAAA,IAAAA;AAAAA,gBACXpX,CAAAA,GAAKoX,CAAAA,CAAIpX,EADEoX;;AACFpX,oBAEPoX,CAAAA,CAAIzX,IAFGK;AAEHL,mBACL,MADKA;AAERK,gBAAAA,CAAAA,CAAGmF,OAAHnF,GAAa5C,CAAb4C;AAAa5C;;AAAAA,mBAEVmE,CAFUnE;AAGb4C,gBAAAA,CAAAA,CAAGmF,OAAHnF,GAAaoX,CAAAA,CAAIlY,EAAJkY,CAAOha,CAAPga,CAAbpX;AAPWA;AAOS5C,WAR1BgK,CAAAA;AAtCA+P,SADcpX,EACN6W,CAAAA,CAAQ7W,CAAR6W,CADM7W;AACEA,OADlBqH,CAvBAA,EA2BO;AACL6O,QAAAA,YAAAA,EAAAA,CADK;AAELC,QAAAA,gBAAAA,EAAAA;AAFK,OA5B0CjB;AA7B5BuB,KAgBvB,EAhBkC;AAC5BC,MAAAA,cAAAA,EAAgBC,CAAAA,CAAUlE,CAAVkE,CADY;AAE5BzB,MAAAA,MAAAA,EAAQc,CAFoB;AAG5BY,MAAAA,cAAAA,EAAgB;AAHY,KAgBlC,CAjBS;;AAMLV,IAAAA,CAAAA,GAAeM,CAAAA,CAAWN,YAA1BA,EACAC,CAAAA,GAAmBK,CAAAA,CAAWL,gBAAXK,CAA4B/W,GAA5B+W,CAAgC,CAAA;AAAEpR,MAAAA,OAAAA,EAAAA;AAAF,KAAA,KAAeA,CAA/CoR,CADnBN;AAIFrS;AAAAA,EAAAA,CAAAA,CAAO;AACL1D,IAAAA,MAAAA,EAAQ+V,CADH;AAEL/R,IAAAA,MAAAA,EAAQgS,CAFH;AAGLzT,IAAAA,QAAAA,EAAUoT,CAAAA,GAAUrD,CAAVqD,GAAmB;AAHxB,GAAPjS,CAAAA;AAkGF;;AAAA,SAASqT,CAAT,CAAwBL,CAAxB,EAAwBA;AAAAA,MAChBS,CAAAA,GAAQrC,MAAAA,CAAOC,MAAPD,CAAc4B,CAAd5B,CADQ4B;AAAAA,MAEhBU,CAAAA,GAAW,EAFKV;AAEL,SACjBxP,CAAAA,CAAQiQ,CAARjQ,EAAe,CAAA;AAAErH,IAAAA,EAAAA,EAAAA;AAAF,GAAA,KAAEA;AACfuX,IAAAA,CAAAA,CAASvX,CAATuX,CAAAA,GAAe,EAAfA;AAAe,GADjBlQ,CAAAA,EAIAA,CAAAA,CAAQiQ,CAARjQ,EAAe,CAAA;AAAErH,IAAAA,EAAAA,EAAAA,CAAF;AAAM6M,IAAAA,MAAAA,EAAAA,CAAN;AAAc5B,IAAAA,KAAAA,EAAAA;AAAd,GAAA,KAAcA;AAC3B4B,IAAAA,CAAAA,IAAUxF,CAAAA,CAAQwF,CAARxF,EAAgBgQ,CAAAA,IAAAA;AACxBE,MAAAA,CAAAA,CAASF,CAAAA,CAAIhX,IAAJgX,CAASrX,EAAlBuX,CAAAA,CAAsB/X,IAAtB+X,CAA2BvX,CAA3BuX;AAA2BvX,KADnBqH,CAAVwF,EAGA5B,CAAAA,IAAS5D,CAAAA,CAAQ4D,CAAR5D,EAAegQ,CAAAA,IAAAA;AACtBE,MAAAA,CAAAA,CAASvX,CAATuX,CAAAA,CAAa/X,IAAb+X,CAAkBF,CAAAA,CAAIpX,EAAJoX,CAAOrX,EAAzBuX;AAAyBvX,KADlBqH,CAHTwF;AAI2B7M,GAL7BqH,CAJAA,EAYOkQ,CAbU;AAmBZ;;AAAA,SAASC,CAAT,CAASA;AACdC,EAAAA,MAAAA,EAACA,CADaD;AACdC,EAAAA,aAAAA,EAASnB;AADKkB,CAAT,EACIlB;AACToB,EAAAA,MAAAA,EACEA,CAAAA,GAAS,EAFFpB;AACToB,EAAAA,WAAAA,EAEEC;AAHOrB,IAIgD,EALpD,EAKoD;AAAA,MAEnD/W,CAAAA,GAAS,EAF0C;AAE1C,SACf8H,CAAAA,CAAQoQ,CAARpQ,EAAgB,CAAA;AAAExI,IAAAA,IAAAA,EAAAA,CAAF;AAAQ2B,IAAAA,KAAAA,EAAAA,CAAR;AAAeV,IAAAA,GAAAA,EAAAA;AAAf,GAAA,KAAeA;AAAAA,QACzBjB,CAAAA,CAAKJ,IAALI,KAAcqB,CADWJ,EACJ;AAAA,QAAA;AACnBxB,MAAAA,GAAAA,EAACA;AADkB,QACXO,CADW;AAEpBP,IAAAA,CAAAA,KAAAA,CACDqZ,CADCrZ,IACDqZ,CAAe9Y,CAAAA,CAAKgQ,SADnBvQ,IAEEgY,CAAAA,CAActR,GAAdsR,CAAkBzX,CAAAA,CAAK0X,MAAL1X,CAAYmB,EAA9BsW,CAFFhY,CAAAA,KAILiB,CAAAA,CAAOjB,CAAPiB,CAAAA,GAAcO,CAAAA,CAAIU,CAAAA,CAAMmL,KAANnL,CAAYR,EAAhBF,CAAAA,CAAoBsF,OAJ7B9G;AAI6B8G,GAPpCiC,CAAAA,EASAA,CAAAA,CAAQqQ,CAARrQ,EAAgB,CAAA;AAAE/I,IAAAA,GAAAA,EAAAA;AAAF,GAAA,KAAEA;AACZA,IAAAA,CAAAA,IAAAA,OAAYiB,CAAAA,CAAOjB,CAAPiB,CAAZjB;AAAmBA,GADzB+I,CATAA,EAYO9H,CAbQ;AAiBV;;AAAA,SAASqY,CAAT,CAAmBnZ,CAAnB,EAAmBA;AACnBiE,EAAAA,EAAAA,IACHlF,CAAAA,CAAW,qDAAXA,CADGkF;AACQ,MAEPmV,CAAAA,GAAgBnV,EAFT;AAAA,MAGPoV,CAAAA,GAAYpV,EAAAA,CAASuH,IAATvH,CAAcjE,CAAdiE,CAHL;AAGmBjE,SACzB0H,CAAAA,CAAU1H,CAAV0H,CAAAA,GACFhC,CAAAA,IAAAA;AAAAA,QACO+K,CAAAA,GAAMD,CAAAA,EADb9K;AAECN,IAAAA,CAAAA,CAAO;AACL1D,MAAAA,MAAAA,EAAQ2X,CADH;AAEL3T,MAAAA,MAAAA,EAAQ;AACNA,QAAAA,MAAAA,EAAAA,CADM;AAEN+K,QAAAA,GAAAA,EAAAA;AAFM,OAFH;AAMLxM,MAAAA,QAAAA,EAAUmV;AANL,KAAPhU,CAAAA;AAMYgU,GATX1R,GAYFhC,CAAAA,KACCN,CAAAA,CAAO;AAAC1D,IAAAA,MAAAA,EAAQ2X,CAAT;AAAoB3T,IAAAA,MAAAA,EAAAA,CAApB;AAA4BzB,IAAAA,QAAAA,EAAUmV;AAAtC,GAAPhU,CAAAA,EACOM,CAFRA,CAb2B1F;AAmBlC;;AAAA,SAASwX,CAAT,CACEf,CADF,EAEE6C,CAAAA,GAAa,MAAA,CAAA,CAFf,EAEe;AAAA,MAET7C,CAAAA,YAAkB7J,GAFT,EAEc;AAAA,QACnB9L,CAAAA,GAAS,EADU;;AACV,SACV,IAAA,CAAO2G,CAAP,EAAY7I,CAAZ,CADU,IACY6X,CADZ,EAER/O,CAAAA,CAAQD,CAARC,CAAAA,IAAc3I,CAAAA,CAAW,0BAAXA,CAAd2I,EACL4R,CAAAA,CAAW7R,CAAX6R,EAAgB1a,CAAhB0a,CADK5R,EAEL5G,CAAAA,CAAO2G,CAAAA,CAAI5H,GAAXiB,CAAAA,GAAmBlC,CAFd8I;;AAEc9I,WAEdkC,CAFclC;AAEdkC;;AAAAA,SAEF2V,CAFE3V;AAKJ;;AAAA,SAASyY,CAAT,CACLvF,CADK,EACLA;AACAyC,EAAAA,MAAAA,EAACA,CADDzC;AACAyC,EAAAA,QAAAA,EAAS+C;AADTxF,IACqD,EAFhD,EAEgD;AAEhDtM,EAAAA,CAAAA,CAAUsM,CAAVtM,CAAAA,IAAmB3I,CAAAA,CAAW,yCAAXA,CAAnB2I;AAA8B,MAC7B+R,CAAAA,GAAAA,CAAAA,CAAehD,CADc;AAEnCA,EAAAA,CAAAA,GAASe,CAAAA,CACPf,CAAAA,IAAU,EADHe,EAEPxX,CAAAA,IAAAA,CACG0H,CAAAA,CAAS1H,CAAT0H,CADH1H,IAEEjB,CAAAA,CAAW,4CAAXA,CAJKyY,CAATf;;AAIe,MAETiD,CAAAA,GAiNR,CAAoB1Z,CAAAA,IAAAA;AAAAA,aAiJT8b,CAjJS9b,CAiJCA,CAjJDA,EAiJCA;AAAAA,UACX2B,CAAAA,GAAOxB,EAAAA,CAASH,CAATG,CADIH;AAAAA,UAEXkc,CAAAA,GAAQrb,CAAAA,CAAK6H,OAAL7H,CAAac,CAAbd,CAFGb;;AAEU2B,UAAAA,CACZ,CADYA,KACvBua,CADuBva,EACT;AAAA,YACZwa,CAAAA,GAAW,MADC;AAEZnc,QAAAA,CAAAA,KAAS2B,CAAT3B,IAAiBA,CAAAA,CAAKuB,EAALvB,KAAYA,CAAAA,CAAKoH,SAAlCpH,KAA6Cmc,CAAAA,GAAWnc,CAAAA,CAAKoH,SAA7DpH,GACJjB,CAAAA,CAAY,GAAEod,CAAAA,4BAAdpd,CADIiB;AACUmc;;AAAAA,aAETnD,CAAAA,CAAOkD,CAAPlD,CAFSmD;AAEFD;;AAAAA,QAxJVrb,CAAAA,GAAOqX,CAAAA,CAAUlY,CAAVkY,CAwJGgE;AAAAA,QAvJVX,CAAAA,GAAO,IAAI3O,GAAJ,EAuJGsP;AAAAA,QAjJVrE,CAAAA,GAAgB,IAAInT,GAAJ,EAiJNwX;AAAAA,QAhJVT,CAAAA,GAAoBrV,EAAAA,CAAa;AACrC1F,MAAAA,EAAAA,EAAE,CAAC6J,CAAD,EAAMuE,CAAN,EAAS1K,CAAT,MAASA,CAAAA,CAENA,CAAAA,CAAMzC,IAANyC,CAAWhE,IAAXgE,CAAgBgM,SAFVhM,IAGN9D,EAAAA,CAAU8D,CAAV9D,CAAAA,IAAsD,cAAlCA,EAAAA,CAAU8D,CAAV9D,CAAAA,CAAiBqB,IAAjBrB,CAAsBF,IAAtBE,CAA2BwG,EAHzC1C,KAKPyT,CAAAA,CAAcrR,GAAdqR,CAAkBzT,CAAAA,CAAMzC,IAANyC,CAAWhE,IAAXgE,CAAgB0T,MAAhB1T,CAAuB7C,EAAzCsW,CALOzT,EAMFmG,CANP;AADmC,KAAbnE,CAgJV8V;AAAAA,QAtIVjB,CAAAA,GAAsBta,CAAAA,CAAW;AACrCoB,MAAAA,KAAAA,EAjBY;AACZmZ,QAAAA,MAAAA,EAAQ,EADI;AAEZ/I,QAAAA,QAAAA,EAAU,CAFE;AAGZqJ,QAAAA,IAAAA,EAAM;AAHM,OAgByB;AAErC7Z,MAAAA,IAAAA,EAAM,CACJyE,EAAAA,CAAa;AACX1F,QAAAA,EAAAA,CAAGoO,CAAHpO,EAAMqB,CAANrB,EAAa0D,CAAb1D,EAAa0D;AACNA,UAAAA,CAAAA,CAAM/D,MAAN+D,GAIgC,cAAjCA,CAAAA,CAAM/D,MAAN+D,CAAazC,IAAbyC,CAAkBhE,IAAlBgE,CAAuBgF,KAAU,GACnCrH,CAAAA,CAAMoQ,QAANpQ,IAAkB,CADiB,IAGnCA,CAAAA,CAAMoQ,QAANpQ,IAAkB,CAAlBA,EACAA,CAAAA,CAAMyZ,IAANzZ,IAAc,CAJqB,CAJhCqC,GACHrC,CAAAA,CAAMyZ,IAANzZ,IAAc,CADXqC;AACW;;AAHP,OAAbgC,CADI,EAeJA,EAAAA,CAAa;AAAC/B,QAAAA,QAAAA,EjB5eG;AiB4eJ,OAAb+B,CAfI,EAgBJA,EAAAA,CAAS;AACP1F,QAAAA,EAAAA,CAAGoO,CAAHpO,EAAMqB,CAANrB,EAAMqB;AAAAA,cAAAA;AACEoQ,YAAAA,QAAAA,EAACA,CADHpQ;AACEoQ,YAAAA,MAAAA,EAAW+I,CADbnZ;AACEoQ,YAAAA,IAAAA,EAAmBqJ;AADrBzZ,cAC6BA,CAD7BA;AAEAoQ,UAAAA,CAAAA,GAAW,CAAXA,IAAkC,MAAlB+I,CAAAA,CAAO1b,MAAvB2S,IACJzB,OAAAA,CAAQgL,OAARhL,GAAkBqB,IAAlBrB,CAAuB,MAAA;AACjB3O,YAAAA,CAAAA,CAAMyZ,IAANzZ,KAAeyZ,CAAfzZ,IACJ6G,CAAAA,CAAQsS,CAAAA,CAAOvS,MAAPuS,CAAc,CAAdA,EAAiBA,CAAAA,CAAO1b,MAAxB0b,CAARtS,EAA0CjD,CAAAA,IAAAA;AACxCb,cAAAA,EAAAA,CAAYa,CAAAA,CAAMqV,UAAlBlW,CAAAA,EACAa,CAAAA,CAAMgL,EAANhL,CAASA,CAAAA,CAAM/G,KAAf+G,CADAb;AACelG,aAFjBgK,CADI7G;AAGanD,WAJnB8R,CADIyB;AAKevT;;AARd,OAATwH,CAhBI,CAF+B;AAgCrChG,MAAAA,IAAAA,EAAM;AAACJ,QAAAA,IAAAA,EjBrfiB;AiBqflB;AAhC+B,KAAXW,CAsIZub;AAAAA,QApGV/O,CAAAA,GAAU,EAoGA+O;AAAAA,QAnGVtE,CAAAA,GAAS,EAmGCsE;AAAAA,QAlGVlD,CAAAA,GAASnY,CAAAA,CAAKG,GAALH,CAASc,CAAAA,IAAAA;AAAAA,UAAAA;AAChBW,QAAAA,GAAAA,EAACA,CADeX;AAChBW,QAAAA,IAAAA,EAAMG,CADUd;AAChBW,QAAAA,IAAAA,EAAYlC,CADIuB;AAChBW,QAAAA,KAAAA,EAAkBP;AADFJ,UACWA,CADXA;AAAAA,UAEhBb,CAAAA,GAASH,CAAAA,CAAW;AACxBgB,QAAAA,IAAAA,EAAMW,CAAAA,CAAItB,GAAJsB,CAAQ8D,CAAAA,KAAAA;AACZ7E,UAAAA,EAAAA,EAAI6E,CAAAA,CAAK7E,EADG6E;AAEZjF,UAAAA,IAAAA,EAAMiF,CAAAA,CAAKjF,IAFCiF;AAGZhF,UAAAA,IAAAA,EAAM,EAAA,GAAIgF,CAAAA,CAAKhF;AAAT,WAHMgF;AAIZlF,UAAAA,MAAAA,EAAQkF,CAAAA,CAAKlF;AAJDkF,SAAAA,CAAR9D,CADkB;AAOxBR,QAAAA,KAAAA,EAAO,CAAA,GAAIW,CAAJ,CAPiB;AAQxBrC,QAAAA,IAAAA,EAAM;AAAC0X,UAAAA,MAAAA,EAAQnW,CAAT;AAASA,aAASvB;AAAlB,SARkB;AASxB2B,QAAAA,KAAAA,EAAO,EAAA,GAAIA;AAAJ;AATiB,OAAXpB,CAFOgB;AAWTI,aAEbjB,CAAAA,CAAOkB,MAAPlB,GAAgB;AACdK,QAAAA,IAAAA,EAAMQ,CAAAA,CAAKK,MAALL,CAAYR,IADJ;AAEdiB,QAAAA,KAAAA,EAAO,CAAA,GAAIO,EAAAA,CAAShB,CAATgB,CAAJ,CAFO;AAGdN,QAAAA,MAAAA,EAAQ,CAAA,GAAIK,EAAAA,CAAUf,CAAVe,CAAJ;AAHM,OAAhB5B,EAKAqM,CAAAA,CAAQxL,CAAAA,CAAKJ,EAAb4L,CAAAA,GAAmBrM,CALnBA,EAMIV,CAAAA,CAAKP,GAALO,KAAUwX,CAAAA,CAAOxX,CAAAA,CAAKP,GAAZ+X,CAAAA,GAAmB9W,CAA7BV,CANJU,EAOOA,CATMiB;AASNjB,KApBMD,CAkGCqb;AAAAA,QA5EVlY,CAAAA,GAAO,EA4EGkY;AA5EH,WACbtT,CAAAA,CAAQoQ,CAARpQ,EAAgBjH,CAAAA,IAAAA;AAAAA,UAAAA;AACRN,QAAAA,GAAAA,EACJA,CAFYM;AACRN,QAAAA,KAAAA,EAEJU,CAHYJ;AAIZvB,QAAAA,IAAAA,EAAAA;AAAM4Q,UAAAA,MAAAA,EAACA,CAAP5Q;AAAM4Q,UAAAA,EAAAA,EAASlK,CAAf1G;AAAM4Q,UAAAA,IAAAA,EAAahR;AAAnBI;AAJYuB,UAKVA,CALUA;;AAKVA,cACJ0G,CAAAA,CAAMhH,CAANgH,EAAW,CAAC8G,CAAD,EAAM5N,CAAN,KAAMA;AAAAA,YACXoa,CAAAA,GAASJ,CAAAA,CAAK3N,GAAL2N,CAASpM,CAAToM,CADEha;AAEVoa,QAAAA,CAAAA,KACHA,CAAAA,GAAS;AACPpa,UAAAA,EAAAA,EAAI4N,CAAAA,CAAI5N,EADD;AAEPoF,UAAAA,OAAAA,EAASwI,CAAAA,CAAIxI;AAFN,SAATgV,EAIAJ,CAAAA,CAAK7M,GAAL6M,CAASpM,CAAToM,EAAcI,CAAdJ,CALGI,CAAAA,EAOL3X,CAAAA,CAAKzC,CAALyC,CAAAA,GAAW3C,CAAAA,CAAIE,CAAJF,CAAAA,GAAUsa,CAPhBA;AAOgBA,OATvBtT,CAAAA,EAWI2I,CAAAA,IACFpI,CAAAA,CAAQoI,CAARpI,EAAiBgT,CAAAA,IAAAA;AAAAA,YACTC,CAAAA,GAAY9Z,CAAAA,CAAM6Z,CAAN7Z,CADH6Z;AAEf7Z,QAAAA,CAAAA,CAAM6Z,CAAN7Z,CAAAA,GAAmB1C,KAAAA,CAAMC,OAAND,CAAcwc,CAAdxc,IACfwc,CAAAA,CAAU7a,GAAV6a,CAAcC,CAAdD,CADexc,GAEfyc,CAAAA,CAAUD,CAAVC,CAFJ/Z;AAEc8Z,OAJhBjT,CAZFP,EAmBAiT,CAAAA,CAAmB3Z,CAAnB2Z,EAAyB,CAAC3Z,CAAD,EAAOpC,CAAP,EAAUwc,CAAV,KAAUA;AACjCA,QAAAA,CAAAA,CAASxc,CAATwc,CAAAA,GAAcD,CAAAA,CAAUna,CAAVma,CAAdC;AAAwBpa,OAD1B2Z,CAnBAjT,EAsBgBvB,CAAAA,IAAM9G,CAvBlB2B;AAuBkB3B,aAEfyB,CAFezB;AAGlB2B,UAAAA,CAAAA,CAAKvB,IAALuB,CAAUqa,OAAVra,GAgDR,CAAmBA,CAAAA,KACV;AACLgI,YAAAA,IAAAA,EAAMlI,CADD;AAELqL,YAAAA,QAAAA,EAAU,MAAMnL,CAAAA,CAAKN,GAALM,CAASA,CAAAA,CAAKI,KAALJ,CAAWuL,KAAXvL,CAAiBJ,EAA1BI,EAA8BgF,OAFzC;AAGL4F,YAAAA,OAAAA,EAAS;AACPjC,cAAAA,KAAAA,EAAOmB,CAAAA,CAAKC,EAALD,EAAgB9J,CAAhB8J;AADA,aAHJ;AAMLF,YAAAA,QAAAA,EAAU5J,CANL;AAOLK,YAAAA,MAAAA,EAAQL,CAAAA,CAxDgBsa;AAiDnB,WADUta,CAAnB,EAhDsCA,CAgDtC,CAhDQA,EACIA,CAAAA,CAAKvB,IAALuB,CAAU9B,GAAV8B,IAAeA,CAAAA,CAAKW,GAALX,CAASZ,IAATY,CAAc8Z,CAAd9Z,CADnBA;AACiC8Z;;AAAAA,aAI9B3Y,CAJ8B2Y;AAKjC9Z,UAAAA,CAAAA,CAAKc,IAALd,CAAUZ,IAAVY,CAAesZ,CAAftZ;AAAesZ;;AAAAA,aAEZ,IAFYA;AAGflZ,UAAAA,CAAAA,CAAMoP,OAANpP,CAAcU,IAAdV,CAAmBhB,IAAnBgB,CAAwBkZ,CAAxBlZ;AAnCAJ;AAmCwBsZ,KAxC9BrS,CAAAA,EAgDO;AACL0O,MAAAA,OAAAA,EAAStX,CADJ;AAEL6X,MAAAA,aAAAA,EAAAA,CAFK;AAGL1K,MAAAA,OAAAA,EAAAA,CAHK;AAILyK,MAAAA,MAAAA,EAAAA,CAJK;AAKLoB,MAAAA,MAAAA,EAAAA,CALK;AAMLxN,MAAAA,IAAAA,EAAMsQ,CAND;AAOLza,MAAAA,GAAAA,EAAK2C,CAPA;AAQL8I,MAAAA,QAAAA,EAAWxL,CAAAA,IAAewa,CAAAA,CAAUxa,CAAVwa,CAAAA,CAAiB1b,IAAjB0b,CAAsBE,OAAtBF,CAA8BhP,QAA9BgP,EARrB;AASLvQ,MAAAA,QAAAA,EAAU5K,CAAAA,CAAW;AACnBqB,QAAAA,MAAAA,EAAQ;AACNb,UAAAA,IAAAA,EjBllBc,QiBilBR;AAENiB,UAAAA,KAAAA,EAAO,CAAC6Y,CAAD,EAACA,GAAwBjC,CAAzB;AAFD,SADW;AAKnB5Y,QAAAA,IAAAA,EAAM;AAACJ,UAAAA,IAAAA,EAAM;AAAP,SALa;AAMnB+B,QAAAA,KAAAA,EAAO;AAACkZ,UAAAA,mBAAAA,EAAAA;AAAD;AANY,OAAXta;AATL,KAjDM;AA9REgZ,GAiNjB,EAjN4B3F,CAiN5B,CAnNiB;;AAEWA,MACtByF,CAAAA,IAAAA,CAAAA,MAAAA;AAAAA,QAoBII,CAAAA,GAAa3B,CAAAA,CAAUlE,CAAVkE,CApBjBuB;AAAAA,QAqBIK,CAAAA,GAAgB,EArBpBL;AAAAA,QAsBIrB,CAAAA,GAAU,EAtBdqB;AAAAA,QAuBIpB,CAAAA,GAAiB,IAAI3T,GAAJ,EAvBrB+U;AAAAA,QAwBIM,CAAAA,GAAoB,IAAIrV,GAAJ,EAxBxB+U;AAAAA,QAyBInB,CAAAA,GAAgB9B,MAAAA,CAAO+B,mBAAP/B,CAA2BC,CAA3BD,CAzBpBiD;AA0BF7Q,IAAAA,CAAAA,CAAQiR,CAARjR,EAAoB,CAAA;AAAEvH,MAAAA,GAAAA,EAAAA,CAAF;AAAOjB,MAAAA,IAAAA,EAAAA;AAAP,KAAA,KAAOA;AAAAA,UAAAA;AACnBqK,QAAAA,cAAAA,EAACA;AADkBrK,UACAA,CADAA;AAEzBiI,MAAAA,CAAAA,CAAMhH,CAANgH,EAAW,CAAC8G,CAAD,EAAM5N,CAAN,KAAMA;AACfuY,QAAAA,CAAAA,CAAcvY,CAAduY,CAAAA,GAAoB3K,CAApB2K,EACIrP,CAAAA,IACFsP,CAAAA,CAAkBvT,GAAlBuT,CAAsBxY,CAAtBwY,CAFFD;AAEwBvY,OAH1B8G,CAAAA;AAG0B9G,KAL5BqH,CAAAA,EASAA,CAAAA,CAAQ8Q,CAAAA,CAAOV,MAAfpQ,EAAuBjH,CAAAA,IAAAA;AAAAA,UAAAA;AACfN,QAAAA,GAAAA,EAACA;AADcM,UACPA,CADOA;AAAAA,UACPA;AACR3B,QAAAA,IAAAA,EAACA,CADO2B;AACR3B,QAAAA,GAAAA,EAAOH;AADC8B,UACMA,CAAAA,CAAKvB,IAFJuB;;AAEIvB,UACrBJ,CAAAA,KAASyB,CAATzB,IACEH,CADFG,IACSuI,EAAAA,CAAS+P,CAAT/P,EAAwB1I,CAAxB0I,CAFYnI,EAEkB;AAAA,YAAA;AACjC8M,UAAAA,KAAAA,EAACA;AADgC,YACvBvL,CAAAA,CAAKI,KADkB;AAEvCV,QAAAA,CAAAA,CAAI6L,CAAAA,CAAM3L,EAAVF,CAAAA,CAAcsF,OAAdtF,GAAwBoV,CAAAA,CAAO5W,CAAP4W,CAAxBpV,EACAgX,CAAAA,CAAe7R,GAAf6R,CAAmBnL,CAAnBmL,CADAhX,EAEAqY,CAAAA,CAAO7B,aAAP6B,CAAqBlT,GAArBkT,CAAyB/X,CAAAA,CAAKvB,IAALuB,CAAUmW,MAAVnW,CAAiBJ,EAA1CmY,CAFArY;AAKJgH;;AAAAA,MAAAA,CAAAA,CAAMhH,CAANgH,EAAW,CAAC8G,CAAD,EAAM5N,CAAN,KAAMA;AACf6W,QAAAA,CAAAA,CAAQ7W,CAAR6W,CAAAA,GAAcjJ,CAAdiJ;AAAcjJ,OADhB9G,CAAAA;AACgB8G,KAZlBvG,CATAA,EA0BAA,CAAAA,CADe8P,CAAAA,CADED,CAAAA,CAAeqB,CAAfrB,CACFC,EAAmBqB,CAAnBrB,CACf9P,EAAgBrH,CAAAA,IAAAA;AAAAA,OAAAA,CAIC4N,CAJD5N,EAIgB8T,CAJhB9T,KAIgB8T;AAAAA,YAC1BlF,CAAAA,GAAU,CADgBkF;AAChB,YACVA,CAAAA,IAAaA,CAAAA,CAAUjH,MAAvBiH,IAAuBjH,CAAWiK,CAAAA,CAAe9R,GAAf8R,CAAmBlJ,CAAnBkJ,CAAlChD,IACFzM,CAAAA,CAAQyM,CAAAA,CAAUjH,MAAlBxF,EAA0BgQ,CAAAA,IAAAA;AAAAA,kBAChBA,CAAAA,CAAIzX,IADYyX;AACZzX,iBACL4B,CADK5B;AAGRgO,cAAAA,CAAAA,CAAIxI,OAAJwI,GAAcyJ,CAAAA,CAAIlY,EAAJkY,CADDR,CAAAA,CAAQQ,CAAAA,CAAIhX,IAAJgX,CAASrX,EAAjB6W,CAAAA,CACazR,OAAZiS,CAAdzJ;AAA0BxI;;AAAAA,iBAGvB,OAHuBA;AAGvB;AAAA,oBACG/E,CAAAA,GAAOwW,CAAAA,CAAQQ,CAAAA,CAAIhX,IAAJgX,CAASrX,EAAjB6W,CADV;AAEEjI,gBAAAA,CAAAA,KACHA,CAAAA,GAAU,CAAVA,EAEEhB,CAAAA,CAAIxI,OAAJwI,GADE9P,KAAAA,CAAMC,OAAND,CAAc8P,CAAAA,CAAIxI,OAAlBtH,IACY,CAAA,GAAI8P,CAAAA,CAAIxI,OAAR,CADZtH,GAGY,EAAA,GAAI8P,CAAAA,CAAIxI;AAAR,iBALbwJ,CAAAA,EAQLhB,CAAAA,CAAIxI,OAAJwI,CAAYyJ,CAAAA,CAAItI,KAAhBnB,IAAyBvN,CAAAA,CAAK+E,OARzBwJ;AAQyBxJ;AAAAA;AAjBViS;AAiBUjS,SAjBpCiC,CADEyM,EAkBkC1O,CAQjC0O,CARiC1O,IAQjC0O,CAAcA,CAAAA,CAAU7I,KA3Bf,EA2BsB;AAAA,YAC9B5N,CAAAA,GAAQuQ,CAAAA,CAAIxI,OADkB;AAEpCiC,QAAAA,CAAAA,CAAQyM,CAAAA,CAAU7I,KAAlB5D,EAAyBgQ,CAAAA,IAAAA;AAAAA,cACjBpX,CAAAA,GAAK4W,CAAAA,CAAQQ,CAAAA,CAAIpX,EAAJoX,CAAOrX,EAAf6W,CADYQ;;AACGrX,kBAElBqX,CAAAA,CAAIzX,IAFcI;AAEdJ,iBACL,MADKA;AAERK,cAAAA,CAAAA,CAAGmF,OAAHnF,GAAa5C,CAAb4C;AAAa5C;;AAAAA,iBAEVmE,CAFUnE;AAGb4C,cAAAA,CAAAA,CAAGmF,OAAHnF,GAAaoX,CAAAA,CAAIlY,EAAJkY,CAAOha,CAAPga,CAAbpX;AAPsBD;AAOF3C,SAR1BgK,CAAAA;AAjCA+P,OADcpX,EACN6W,CAAAA,CAAQ7W,CAAR6W,CADM7W,EACOuY,CAAAA,CAAcvY,CAAduY,CADPvY;AACqBA,KADrCqH,CA1BAA;AAzBAoP,GADEyB,GAAAA,EAGAD,CAJsBxF,EAIZ;AACZwF,IAAAA,CAAAA,GAAWhC,CAAAA,CACTgC,CADShC,EAETxX,CAAAA,IAAAA,CACG0H,CAAAA,CAAU1H,CAAV0H,CADH1H,IAEEjB,CAAAA,CAAY,+CAAZA,CAJOyY,CAAXgC;AAIgB,QAEVI,CAAAA,GAAcpD,MAAAA,CAAOG,IAAPH,CAAYgD,CAAZhD,CAFJ;AAGhB5N,IAAAA,CAAAA,CAAQ8Q,CAAAA,CAAOV,MAAfpQ,EAAuB,CAAA;AAAE7G,MAAAA,KAAAA,EAAAA,CAAF;AAAS3B,MAAAA,IAAAA,EAAAA;AAAT,KAAA,KAASA;AAC1BA,MAAAA,CAAAA,CAAKP,GAALO,IAAYmI,EAAAA,CAASqR,CAATrR,EAAsBnI,CAAAA,CAAKP,GAA3B0I,CAAZnI,KACF2B,CAAAA,CAAMkQ,MAANlQ,CAAaA,KAAbA,CAAmB0P,UAAnB1P,GAAgC,MAAMyX,CAAAA,CAASpZ,CAAAA,CAAKP,GAAd2Z,CADpCpZ;AACkDP,KAFxD+I,CAAAA;AAEwD/I;;AAAAA,SAInD6Z,CAJmD7Z;AAyF5D;;AAAA,SAAS6Y,CAAT,CAAkBsB,CAAlB,EAAsDf,CAAtD,EAAsDA;AAAAA,WA+B3CmB,CA/B2CnB,CA+BrBtX,CA/BqBsX,EA+BrBtX;AAC7BwY,IAAAA,CAAAA,CAAKxY,CAALwY,CAAAA,GAAa,CAAbA;AAAa,QACPM,CAAAA,GAAYR,CAAAA,CAAMtY,CAANsY,CADL;;AACWtY,SACnB,IAAIpC,CAAAA,GAAI,CADWoC,EACRpC,CAAAA,GAAIkb,CAAAA,CAAUjb,MADNmC,EACcpC,CAAAA,EADdoC,EACmB;AAAA,UACnC+Y,CAAAA,GAAID,CAAAA,CAAUlb,CAAVkb,CAD+B;AAErCN,MAAAA,CAAAA,CAAKO,CAALP,CAAAA,IAICD,CAAAA,CAAQQ,CAARR,CAJDC,IAKFC,CAAAA,CAAsBM,CAAtBN,CALED;AAQNA;;AAAAA,IAAAA,CAAAA,CAAKxY,CAALwY,CAAAA,GAAa,CAAbA,EACAD,CAAAA,CAAQvY,CAARuY,CAAAA,GAAgB,CADhBC,EAEArZ,CAAAA,CAAOC,IAAPD,CAAYa,CAAZb,CAFAqZ;AAEYxY;;AAAAA,MA7CRsY,CAAAA,GAAQ,EA6CAtY;;AA7CA,OACT,IAAMJ,CADG,IACGyY,CADH,EAEZC,CAAAA,CAAM1Y,CAAN0Y,CAAAA,GAAY,CAAA,GAAI,IAAIvV,GAAJ,CAAQsV,CAAAA,CAASzY,CAATyY,CAAR,CAAJ,CAAZC;;AAAiC1Y,MAE7BT,CAAAA,GAAS,EAFoBS;AAAAA,MAG7B2Y,CAAAA,GAAU,EAHmB3Y;AAAAA,MAI7B4Y,CAAAA,GAAO,EAJsB5Y;;AAItB,OACR,IAAMI,CADE,IACMsY,CADN,EAENC,CAAAA,CAAQvY,CAARuY,CAAAA,IAAkBC,CAAAA,CAAKxY,CAALwY,CAAlBD,IACHE,CAAAA,CAAsBzY,CAAtByY,CADGF;;AACmBvY,MAG1Bb,CAAAA,CAAOuZ,OAAPvZ,IACImY,CAAAA,IAAUA,CAAAA,CAAOpV,IAAPoV,GAAc,CAJFtX,EAIK;AAAA,QAGzBY,CAHyB;AAAA,QACvB+X,CAAAA,GAAY,EADW;AAAA,QAEvBC,CAAAA,GAAU,CAAA,GAAItB,CAAJ,CAFa;;AAETA,WAEZ1W,CAAAA,GAAOgY,CAAAA,CAAQC,KAARD,EAFKtB,GAGlBqB,CAAAA,CAAUvZ,IAAVuZ,CAAe/X,CAAf+X,GACA1R,CAAAA,CAAQqR,CAAAA,CAAM1X,CAAN0X,CAARrR,EAAqB9G,CAAAA,IAAAA;AACfyG,MAAAA,EAAAA,CAAS+R,CAAT/R,EAAoBzG,CAApByG,CAAAA,IAA8BA,EAAAA,CAASgS,CAAThS,EAAkBzG,CAAlByG,CAA9BA,IACJgS,CAAAA,CAAQxZ,IAARwZ,CAAazY,CAAbyY,CADIhS;AACSzG,KAFf8G,CADA0R;;AAMF1R,IAAAA,CAAAA,CAAQ0R,CAAR1R,EAAmBrG,CAAAA,IAAAA;AACjBiG,MAAAA,EAAAA,CAAW1H,CAAX0H,EAAmBjG,CAAnBiG,CAAAA;AAAmBjG,KADrBqG,CAAAA;AACqBrG;;AAAAA,SAGhBzB,CAHgByB;AAwBlB;;AAAA,SAASoY,CAAT,CACLC,CADK,EACLA;AACA7Y,EAAAA,KAAAA,EAACA,CADD6Y;AACQlV,EAAAA,MAAAA,EAAQmV;AADhBD,CADK,EAEWC;AAAAA,MAAAA,CAEXnT,CAAAA,CAAQkT,CAARlT,CAFWmT,EAGd,OAAOnK,OAAAA,CAAQoK,MAARpK,CAAeqK,KAAAA,CAAM,+BAANA,CAAfrK,CAAP;AAA4B,MACxB/K,CAAAA,GAAQ6K,CAAAA,EADgB;AAG9B7K,EAAAA,CAAAA,CAAMqV,UAANrV,GAAmB1B,EAAnB0B;AAAmB1B,MAAAA;AACbgX,IAAAA,mBAAAA,EAACA;AADYhX,MACWlC,CAAAA,CAAMwJ,QAANxJ,CAAeA,KAD1BkC;AAEnBgX,EAAAA,CAAAA,CAAoBlZ,KAApBkZ,CAA0BC,MAA1BD,CAAiCla,IAAjCka,CAAsCtV,CAAtCsV;AAAsCtV,MAGhCwV,CAAAA,GAAc,CAFCpZ,CAAAA,CAAMyJ,IAANzJ,CAAW6Y,CAAX7Y,CAED,CAHkB4D;AAAAA,MAIhCyV,CAAAA,GAAe,EAJiBzV;AAIjB,SACjB+B,CAAAA,CAAUkT,CAAVlT,CAAAA,GACF0T,CAAAA,CAAara,IAAbqa,CAAkB;AAChB1V,IAAAA,MAAAA,EAAQmV,CADQ;AAEhBpK,IAAAA,GAAAA,EAAK;AACHE,MAAAA,EAAAA,CAAG/R,CAAH+R,EAAG/R;AAED+G,QAAAA,CAAAA,CAAM/G,KAAN+G,GAAc;AAAC0L,UAAAA,MAAAA,EAAQ,MAAT;AAAiBzS,UAAAA,KAAAA,EAAAA;AAAjB,SAAd+G;AAA+B/G,OAH9B;;AAKHgS,MAAAA,EAAAA,CAAGhS,CAAHgS,EAAGhS;AAED+G,QAAAA,CAAAA,CAAM/G,KAAN+G,GAAc;AAAC0L,UAAAA,MAAAA,EAAQ,MAAT;AAAiBzS,UAAAA,KAAAA,EAAAA;AAAjB,SAAd+G;AAA+B/G;;AAP9B;AAFW,GAAlBwc,CADE1T,GAeF0T,CAAAA,CAAara,IAAbqa,CAAkBP,CAAlBO,CAfE1T,EAiBJyT,CAAAA,CAAYpa,IAAZoa,CAAiBF,CAAjBE,CAjBIzT,EAkBJ0T,CAAAA,CAAara,IAAbqa,CAAkB,IAAlBA,CAlBI1T,EAmBJtC,CAAAA,CAAO;AACL1D,IAAAA,MAAAA,EAAQyZ,CADH;AAELzV,IAAAA,MAAAA,EAAQ0V,CAFH;AAGLnX,IAAAA,QAAAA,EAAUlC;AAHL,GAAPqD,CAnBIsC,EAwBG/B,CAAAA,CAAM8K,GAzBQ;AA4BvB;;AAAA,SAASyH,CAAT,CAAmBlY,CAAnB,EAAmBA;AAAAA,MACXa,CAAAA,GAAO,EADIb;AACJ,SAAA,SACFqb,CADE,CACO1Z,CADP,EACOA;AACd4G,IAAAA,EAAAA,CAAS1H,CAAT0H,EAAe5G,CAAf4G,CAAAA,KACJ1H,CAAAA,CAAKE,IAALF,CAAUc,CAAVd,GACAya,CAAAA,CAAmB3Z,CAAnB2Z,EAAyBD,CAAzBC,CAFI/S;AAEqB8S,GAJd,CAKVlb,EAAAA,CAASH,CAATG,CALU,GAMNU,CANM;AAsLf;;AAAA,SAASya,CAAT,CACE3Z,CADF,EAEE1B,CAFF,EAEEA;AAAAA,MAEMD,CAAAA,GAAO2B,CAAAA,CAAKvB,IAALuB,CAAU3B,IAFvBC;AAGa,aAATD,CAAS,IjBhnBa,0BiBgnBHA,CAAV,KACb4I,CAAAA,CAAQjH,CAAAA,CAAKc,IAAbmG,EAAmB3I,CAAnB2I,CAAAA,EACAA,CAAAA,CAAQlG,EAAAA,CAAUf,CAAVe,CAARkG,EAAyB3I,CAAzB2I,CADAA,EAEAA,CAAAA,CAAQjG,EAAAA,CAAShB,CAATgB,CAARiG,EAAwB3I,CAAxB2I,CAHa;AC1nBR;;AAAA,IAAM4B,CAAAA,GACQ,eAAA,OAAX4R,MAAW,IAAeA,MAAAA,CAAO7H,UAAtB,IAAqC,cADnD;AAAA,IlBAM9S,CAAAA,GAAQ,OkBAd;AAAA,IlBEMqB,CAAAA,GAAS,QkBFf;AAAA,IlBMMC,CAAAA,GAAM,KkBNZ;AAAA,ICIM/C,CAAAA,GAAQsI,CAAAA,IAAAA,CAClBzJ,CAAAA,CAAWyJ,CAAXzJ,CAAAA,IAAmBF,CAAAA,CAAS2J,CAAT3J,CADD2J,KACmB,UAAUA,CDL3C;;ACOP,MAAMZ,CAAAA,GAAMvG,CAAAA,IAAgBmH,CAAAA,IAAatI,CAAAA,CAAKsI,CAALtI,CAAAA,IAAasI,CAAAA,CAAIqB,IAAJrB,KAAanH,CAAnE;;AAEO,IAAMG,CAAAA,GAAQoG,CAAAA,CAAGjG,CAAHiG,CAAd;AAAA,IACMsD,CAAAA,GAAQtD,CAAAA,CnBTA,OmBSAA,CADd;AAAA,IAEMgL,CAAAA,GAAShL,CAAAA,CAAG5E,CAAH4E,CAFf;AAAA,IAGMsM,CAAAA,GAAStM,CAAAA,CnBTA,QmBSAA,CAHf;AnBNe,IAAA,CAAA,GAAA;AAAA,EAAA,SAAA,EAAA,IAAA;AAAA,EAAA,IAAA,EAAA,CAAA;AAAA,EAAA,KAAA,EAAA,CAAA;AAAA,EAAA,KAAA,EAAA,CAAA;AAAA,EAAA,MAAA,EAAA,CAAA;AAAA,EAAA,MAAA,EAAA;AAAA,CAAA;;AoBHf,IAAM3I,CAAAA,GAAcsd,CAAAA,IAAAA;AAAAA,QACnBtB,KAAAA,CAAMsB,CAANtB,CADmBsB;AACbA,CADP;AAAA,IvBIM1d,CAAAA,GAAYC,CAAAA,IACN,YAAA,OAAVA,CAAU,IAAsB,SAAVA,CuBLxB;AAAA,IvBMMC,CAAAA,GAAcD,CAAAA,IAAgC,cAAA,OAAVA,CuBN1C;AAAA,IvBQME,CAAAA,GAAgBF,CAAAA,IAAAA;AACtBD,EAAAA,CAAAA,CAASC,CAATD,CAAAA,IAAoBE,CAAAA,CAAWD,CAAXC,CAApBF,IACHI,CAAAA,CAAW,oCAAXA,CADGJ;AACQ,CuBVR;;ACAP,MAAM2d,CAAAA,GAAU,MAAA;AAAA,MACV/a,CAAAA,GAAK,CADK;AACL,SACF,MAAA,CAAA,EAASA,CAAT,EAAasG,QAAb,CAAsB,EAAtB,CADE;AACoB,CAF/B;;AAKO,IAAMkC,CAAAA,GAAauS,CAAAA,EAAnB;AAAA,IACMC,CAAAA,GAAaD,CAAAA,EADnB;AAAA,IAEM9Z,CAAAA,GAAa8Z,CAAAA,EAFnB;AAAA,ICLM7Q,CAAAA,GAAO,CAAC/K,CAAD,EAAegB,CAAf,KAA+BhB,CAAAA,CAAG+K,IAAH/K,CAAQ,IAARA,EAAcgB,CAAdhB,CDK5C;AAAA,ICJMgU,EAAAA,GAAQ,CAAChU,CAAD,EAAegB,CAAf,EAA4B8a,CAA5B,KACnB9b,CAAAA,CAAG+K,IAAH/K,CAAQ,IAARA,EAAcgB,CAAdhB,EAAsB8b,CAAtB9b,CDGK;;AEAP,MAAMkY,EAAAA,GAAM,CAACzX,CAAD,EAAYD,CAAZ,EAA6BE,CAA7B,MAA6BA;AACvCG,EAAAA,EAAAA,EAAIgb,CAAAA,EADmCnb;AAEvCD,EAAAA,IAAAA,EAAAA,CAFuCC;AAGvCA,EAAAA,IAAAA,EAAAA,CAHuCA;AAIvCF,EAAAA,MAAAA,EAAAA;AAJuCE,CAA7B,CAAZ;;AAOA,IAAIqb,EAAAA,GAAgB,CAApB;AAAA,IAEaC,EAAAA,GAAiE,CAAA;AAC5ErY,EAAAA,QAAAA,EAAAA,CAAAA,GvBPqB;AuBMuD,CAAA,KAG5EuU,EAAAA,CvBTqB,SuBSrBA,EAAa,CAAbA,EAAoB;AAClBvS,EAAAA,SAAAA,EAAAA,EAAaoW,EADK;AAElBpY,EAAAA,QAAAA,EAAAA;AAFkB,CAApBuU,CALF;AAAA,IASa+D,EAAAA,GAKD,CAAA;AAAE/a,EAAAA,IAAAA,EAAAA,CAAAA,GAAOH,CAAT;AAAgBH,EAAAA,KAAAA,EAAAA,CAAhB;AAAuBI,EAAAA,MAAAA,EAAAA,CAAvB;AAA+BF,EAAAA,EAAAA,EAAAA,CAAAA,GAAKE,CAAAA,GAASD,CAATC,GvBnB3B;AuBmBT,CAAA,KACVkX,EAAAA,CAAI,KAAJA,EAAWhX,CAAAA,KAASH,CAApBmX,EAA2B;AAAChX,EAAAA,IAAAA,EAAAA,CAAD;AAAON,EAAAA,KAAAA,EAAAA,CAAP;AAAcE,EAAAA,EAAAA,EAAAA,CAAd;AAAkBE,EAAAA,MAAAA,EAAAA;AAAlB,CAA3BkX,CAfF;AAAA,IAgBagE,EAAAA,GAGT;AACF/Q,EAAAA,OAAAA,EAAS,MAAM+M,EAAAA,CAAI,OAAJA,EAAa,CAAbA,EAAoB;AAACzX,IAAAA,IAAAA,EAAM;AAAP,GAApByX,CADb;AAEFhK,EAAAA,OAAAA,EAAS,CAAA;AAAEtN,IAAAA,KAAAA,EAAAA;AAAF,GAAA,KAAasX,EAAAA,CAAI,OAAJA,EAAa,CAAbA,EAAmB;AAACzX,IAAAA,IAAAA,EAAM,SAAP;AAAkBG,IAAAA,KAAAA,EAAAA;AAAlB,GAAnBsX;AAFpB,CAnBJ;AAAA,IAuBaiE,EAAAA,GAEGnI,EAAAA,CAAMkE,EAANlE,EAAW,SAAXA,EAAsB,CAAtBA,CAzBhB;AAAA,IA0Ba/I,EAAAA,GAEE+I,EAAAA,CAAMkE,EAANlE,EvB5BO,QuB4BPA,EAAmB,CAAnBA,CA5Bf;AAAA,IA6BaoI,EAAAA,GAEDpI,EAAAA,CAAMkE,EAANlE,EAAW,KAAXA,EAAkB,CAAlBA,CA/BZ;AAAA,IAgCa7F,EAAAA,GAA2C,CAAA;AAAEvN,EAAAA,KAAAA,EAAAA;AAAF,CAAA,KACtDqb,EAAAA,CAAI;AAAC/a,EAAAA,IAAAA,EvBtCc,OuBsCf;AAAcF,EAAAA,MAAAA,EAAQJ;AAAtB,CAAJqb,CAjCF;;AAiC4Brb,IAAAA,EAAAA,GAAAA;AAAAA,EAAAA,SAAAA,EAAAA,IAAAA;AAAAA,EAAAA,OAAAA,EAAAA,EAAAA;AAAAA,EAAAA,GAAAA,EAAAA,EAAAA;AAAAA,EAAAA,KAAAA,EAAAA,EAAAA;AAAAA,EAAAA,OAAAA,EAAAA,EAAAA;AAAAA,EAAAA,MAAAA,EAAAA,EAAAA;AAAAA,EAAAA,GAAAA,EAAAA,EAAAA;AAAAA,EAAAA,MAAAA,EAAAA;AAAAA,CAAAA;;AC1CrB,IAAM+K,EAAAA,GAAkB1F,CAAAA,KAAAA;AAC7BpF,EAAAA,EAAAA,EAAIgb,CAAAA,EADyB5V;AAE7BA,EAAAA,OAAAA,EAAAA;AAF6BA,CAAAA,CAAxB;AAAA,IAIMD,EAAAA,GAAU,CAAA;AAAEC,EAAAA,OAAAA,EAAAA;AAAF,CAAA,KAA0CA,CAJ1D;AAAA,ICHMuI,EAAAA,GAAgB,CAAC9K,CAAD,EAACA;AAAa1D,EAAAA,EAAAA,EAAAA;AAAb0D,CAAD,EAAc1D;AAAWwC,EAAAA,CAAAA,EAAAA;AAAXxC,CAAd,KAAqCA,CAAAA,CAAG0D,CAAH1D,EAAUwC,CAAVxC,CDG3D;AAAA,ICFMuO,EAAAA,GAAgB,CAAC7K,CAAD,EAACA;AAAa1D,EAAAA,EAAAA,EAAAA;AAAb0D,CAAD,EAAc1D;AAAWwC,EAAAA,CAAAA,EAAAA;AAAXxC,CAAd,KAAqCA,CAAAA,CAAGwC,CAAHxC,EAAM0D,CAAN1D,CDE3D;AAAA,ICDMoK,EAAAA,GAAY,CAAC1G,CAAD,EAACA;AAAa1D,EAAAA,EAAAA,EAAAA;AAAb0D,CAAD,KAAmC1D,CAAAA,CAAG0D,CAAH1D,CDCrD;AAAA,IEDMP,EAAAA,GAAY8Z,CAAAA,IAAqBA,CAAAA,CAAM1O,QAAN0O,IAAkBA,CFCzD;AAAA,IEAMvX,EAAAA,GAAaf,CAAAA,IAAeA,CAAAA,CAAKK,MAALL,CAAYU,MFA9C;AAAA,IECMM,EAAAA,GAAYhB,CAAAA,IAAeA,CAAAA,CAAKK,MAALL,CAAYS,KFD7C;AAAA,IEEM+L,EAAAA,GAAiB7M,CAAAA,IAAyBA,CAAAA,CAAMuL,QFFtD;AAAA,IEGM7D,EAAAA,GAAa+T,CAAAA,IAAcA,CAAAA,CAAKhU,MFHtC;AAAA,IEIMM,EAAAA,GAAmB0T,CAAAA,IAAcA,CAAAA,CAAKnH,CFJ5C;AAAA,IEKM/S,EAAAA,GAAYuB,CAAAA,IAAeA,CAAAA,CAAMxF,KFLvC;AAAA,IEMM+O,EAAAA,GAAkBrM,CAAAA,IAAeA,CAAAA,CAAMqL,WFN7C;AAAA,IEOMrM,EAAAA,GAAaN,CAAAA,IAAcA,CAAAA,CAAKK,MFPtC;AAAA,IEQMuF,EAAAA,GAAe+R,CAAAA,IAAaA,CAAAA,CAAI1T,QFRtC;AAAA,IGCMrB,EAAAA,GAAM,CAACoa,CAAD,EAAsB5a,CAAtB,KAAsBA;AAAAA,MACjCoW,CAAAA,GAAQrY,EAAAA,CAAS6c,CAAT7c,CADyBiC;;AAChB4a,OAClB,IAAIzd,CAAAA,GAAI,CADUyd,EACPzd,CAAAA,GAAI6C,CAAAA,CAAM5C,MADHwd,EACWzd,CAAAA,EADXyd,EACgB;AAAA,QAC/BC,CAAAA,GAAO9c,EAAAA,CAASiC,CAAAA,CAAM7C,CAAN6C,CAATjC,CADwB;A3BHnB,iB2BKdqY,CAAAA,CAAMxW,MAANwW,CAAarX,I3BLC,K2BKgB8b,CAAAA,CAAKjb,MAALib,CAAY9b,IAAZ8b,G3BHb,WAFH,G2BMlBva,EAAAA,CAAUua,CAAVva,CAAAA,CAAgB3B,IAAhB2B,CAAqB8V,CAArB9V,C3BNkB,E2BOlBC,EAAAA,CAAS6V,CAAT7V,CAAAA,CAAgB5B,IAAhB4B,CAAqBsa,CAArBta,C3BPkB;A2BOGsa;AAAAA,CHPlB;AAAA,I1BQIxd,EAAAA,GAAkC,I0BRtC;AAAA,I1BUMC,EAAAA,GAAe,MAAMD,EAAAA,IAAeA,EAAAA,CAAYE,Q0BVtD;AAAA,I1BWMC,EAAAA,GAAeC,CAAAA,KACtBA,CAAAA,IAAOJ,EAAPI,IAAsBJ,EAAAA,CAAYK,OAAlCD,KACFA,CAAAA,GAAO,GAAEJ,EAAAA,CAAYK,OAAAA,IAAWD,CAAAA,EAD9BA,GAEGA,CAHmBA,C0BXrB;AAAA,I1BgCMU,EAAAA,GAAc,CAAA;AACzBV,EAAAA,GAAAA,EAAAA,CADyB;AAEzBW,EAAAA,IAAAA,EAAAA,CAFyB;AAGzBC,EAAAA,GAAAA,EAAAA,CAHyB;AAIzBxB,EAAAA,MAAAA,EAAAA,CAJyB;AAKzByB,EAAAA,EAAAA,EAAAA;AALyB,CAAA,KAqBlBX,CAAAA,CARSY,CAAAA,CAAW;AACzBP,EAAAA,IAAAA,EAAM;AACJN,IAAAA,OAAAA,EAASF,EAAAA,CAAYC,CAAZD,CADL;AAEJY,IAAAA,IAAAA,EAAAA,CAFI;AAGJC,IAAAA,GAAAA,EAAAA,CAHI;AAIJxB,IAAAA,MAAAA,EAAAA;AAJI;AADmB,CAAX0B,CAQTZ,EAAoBW,CAApBX,C0BrDF;;AzBIP,MAAMa,EAAAA,GAAc,CAClBC,CAAAA,GAAgD,EAD9B,KAC8B;AAAA,MAE1CC,CAAAA,GAAS,EAFiC;AAEjC,MACXzB,KAAAA,CAAMC,OAAND,CAAcwB,CAAdxB,CADW,EACGwB,KACX,IAAItB,CAAAA,GAAI,CADGsB,EACAtB,CAAAA,GAAIsB,CAAAA,CAAKrB,MADTqB,EACiBtB,CAAAA,EADjBsB,EAEVxB,KAAAA,CAAMC,OAAND,CAAcwB,CAAAA,CAAKtB,CAALsB,CAAdxB,IAAwByB,CAAAA,CAAOC,IAAPD,CAAOC,GAASF,CAAAA,CAAKtB,CAALsB,CAAhBC,CAAxBzB,GACCyB,CAAAA,CAAOC,IAAPD,CAAYD,CAAAA,CAAKtB,CAALsB,CAAZC,CADDzB,CAHO,KAObyB,CAAAA,CAAOC,IAAPD,CAAYD,CAAZC;AAAYD,SAEPC,CAAAA,CAAOE,GAAPF,CAAWX,EAAXW,CAFOD;AAEIV,CAZpB;;AAcO,IAAMc,EAAAA,GAAW,CAAA;AACrBC,EAAAA,MAAAA,EAAAA,CADqB;AACbC,EAAAA,IAAAA,EAAAA,CADa;AACPC,EAAAA,IAAAA,EAAAA;AADO,CAAA,EAEtBC,CAFsB,KAEtBA;AAAAA,MAEIC,CAFJD;AAGIH,EAAAA,CAAAA,KACFI,CAAAA,GAAQF,CAAAA,CAAKE,KAAbA,EACAD,CAAAA,CAAIC,CAAAA,CAAMC,EAAVF,CAAAA,GAAgBC,CAFdJ,CAAAA,EAIS,UAATC,CAAS,IAASC,CAAAA,CAAKI,EAALJ,KAAYK,CAArB,KACXH,CAAAA,GAAQF,CAAAA,CAAKM,MAAbJ,EACAD,CAAAA,CAAIC,CAAAA,CAAMC,EAAVF,CAAAA,GAAgBC,CAFL,CAJTJ;AAMcI,CAXb;AAAA,IEwCH0B,EAAAA,GAAyB,IFxCtB;;AE0CP,MAAMC,EAAAA,GAAQ,CAACC,CAAD,EAAsBC,CAAtB,KAAsBA;AAAAA,MAAAA,CAC7BD,CAD6BC,EAC1B,OAAOA,CAAP;AAAOA,MAAAA,CACVA,CADUA,EACP,OAAOD,CAAP;AAAOA,MAEXE,CAFWF;AAAAA,MAGTG,CAAAA,GAAaH,CAAAA,CAAEI,CAAFJ,CAAI/B,IAAJ+B,KAAaC,CAAAA,CAAEG,CAAFH,CAAIhC,IAHrB+B;AAGqB/B,SAAAA,CAMjCkC,CAAAA,IAAcH,CAAAA,CAAEI,CAAFJ,CAAI3B,EAAJ2B,GAASC,CAAAA,CAAEG,CAAFH,CAAI5B,EAA3B8B,IAA2B9B,CAE1B8B,CAF0B9B,IDtET,cCwEH2B,CAAAA,CAAEI,CAAFJ,CAAI/B,IARcA,MAUlCiC,CAAAA,GAAMF,CAANE,EACAF,CAAAA,GAAIC,CADJC,EAEAD,CAAAA,GAAIC,CAZ8BjC,GAcpCiC,CAAAA,GAAMH,EAAAA,CAAMC,CAAAA,CAAEK,CAARN,EAAWE,CAAXF,CAd8B9B,EAepC+B,CAAAA,CAAEK,CAAFL,GAAMA,CAAAA,CAAEM,CAf4BrC,EAgBpC+B,CAAAA,CAAEM,CAAFN,GAAME,CAhB8BjC,EAkB7B+B,CAlB6B/B;AAkB7B+B,CAvBT;AAAA,MA2BMO,EAAAA,GAAuB,EA3B7B;;AA4BA,IAAIC,EAAAA,GAAK,CAAT;;AACA,OAAOA,EAAAA,GAAK,CAAZ,GAKED,EAAAA,CAAM1C,IAAN0C,CAAW;AAACE,EAAAA,KAAAA,EAAO,IAAR;AAAcC,EAAAA,IAAAA,EAAM,IAApB;AAA0BC,EAAAA,IAAAA,EAAM;AAAhC,CAAXJ,GACAC,EAAAA,IAAM,CADND;;AAIF,MAAMK,EAAAA,GAAY,MAAA;AAAA,OACX,IAAIvE,CAAAA,GAAI,CADG,EACAA,CAAAA,GAAI,CADJ,EACOA,CAAAA,EADP,EACY;AAAA,QACpBsB,CAAAA,GAAO4C,EAAAA,CAAMlE,CAANkE,CADa;;AACPlE,QACfsB,CAAAA,CAAKgD,IAALhD,GAAY,CADGtB,EACA;AAAA,UAKP,MAANA,CAAM,IAAW,MAANA,CALE,EAKO;AACtBsB,QAAAA,CAAAA,CAAKgD,IAALhD,IAAa,CAAbA;AAAa,YACPjC,CAAAA,GAAQoE,EAAAA,CAAMM,CADP;AACOA,eACpBN,EAAAA,GAAOC,EAAAA,CAAMD,EAAAA,CAAMQ,CAAZP,EAAeD,EAAAA,CAAMO,CAArBN,CAAPD,EACOpE,CAFa0E;AAIJ;;AAAA,YAAdzC,CAAAA,CAAKgD,IAAS,KAChBhD,CAAAA,CAAK+C,IAAL/C,GAAY,IADI;AACJ,UAER0B,CAAAA,GAAO1B,CAAAA,CAAK8C,KAFJ;AAEIA,aAClB9C,CAAAA,CAAK8C,KAAL9C,GAAa0B,CAAAA,CAAMgB,CAAnB1C,EACAA,CAAAA,CAAKgD,IAALhD,IAAa,CADbA,EAEO0B,CAAAA,CAAMe,CAHKK;AAGLL;AAAAA;AAAAA,CApBnB;AAAA,MAwBMS,EAAAA,GAAoB,CACxB5C,CADwB,EAExB6C,CAFwB,EAGxBrC,CAHwB,EAIxBtB,CAJwB,EAKxBzB,CALwB,EAMxBqF,CANwB,KAQxBC,EAAAA,CACE,CADFA,EAEE;AACEhB,EAAAA,CAAAA,EAAG,IADL;AAEEC,EAAAA,CAAAA,EAAG,IAFL;AAGExB,EAAAA,IAAAA,EAAAA,CAHF;AAIEtB,EAAAA,MAAAA,EAAAA,CAJF;AAKEzB,EAAAA,KAAAA,EAAAA,CALF;AAMEoF,EAAAA,IAAAA,EAAAA,CANF;AAOEC,EAAAA,QAAAA,EAAAA;AAPF,CAFFC,EAWE/C,CAXF+C,CAhCF;AAAA,MA6CMA,EAAAA,GAAW,CAACC,CAAD,EAAcC,CAAd,EAA4BjD,CAA5B,EAA+CI,CAAAA,GAAK,CAApD,KAAoD;AAAA,MAC7D8C,CAAAA,GAAWC,EAAAA,CAAYnD,CAAZmD,CADkD;AAAA,MAE7DC,CAAAA,GAAsBd,EAAAA,CAAMY,CAANZ,CAFuC;AAAA,MAG7DlB,CAAAA,GAAkB;AACtBe,IAAAA,CAAAA,EAAG;AACDa,MAAAA,GAAAA,EAAAA,CADC;AAEDC,MAAAA,KAAAA,EAAAA,CAFC;AAGDjD,MAAAA,IAAAA,EAAAA,CAHC;AAIDI,MAAAA,EAAAA,EAAAA;AAJC,KADmB;AAQtBiC,IAAAA,CAAAA,EAAG,CARmB;AAUtBD,IAAAA,CAAAA,EAAG;AAVmB,GAH2C;AAmBlD,QAAbc,CAAa,IAAkB,MAAbA,CAAL,GACfrB,EAAAA,GAAOC,EAAAA,CAAMD,EAANC,EAAYV,CAAZU,CADQ,IAGK,MAAhBsB,CAAAA,CAAOV,IAAS,GAClBU,CAAAA,CAAOZ,KAAPY,GAAehC,CADG,GAGlBgC,CAAAA,CAAOX,IAAPW,CAAahB,CAAbgB,GAAiBhC,CAHC,EAKpBgC,CAAAA,CAAOX,IAAPW,GAAchC,CARC,GAUjBgC,CAAAA,CAAOV,IAAPU,IAAe,CAVE;AAUF,CA1EjB;AAAA,MA6EMD,EAAAA,GAAeE,CAAAA,IAAAA;AAAAA,UACXA,CADWA;AACXA,SACD,OADCA;AACD,aACI,CADJ;;AACI,SACJ,MADI;AACJ,aACI,CADJ;;AACI,SD/KU,SC+KV;AD/KU,aCiLV,CDjLU;;ACiLV,SDrLU,SCqLV;ADrLU,aCuLV,CDvLU;;ACuLV,SACJ1B,CADI;AACJA,aACI,CADJA;;AACI;AAAA,aAAA,CAEC,CAFD;AAXQ0B;AAaP,CA1Fd;AAAA,MA8FMC,EAAAA,GAAW,IAAIC,GAAJ,EA9FjB;;AAgGA,IAGWT,EAHX;AAAA,IAAIU,EAAAA,GAAS,CAAb;AAAA,IACWC,EAAAA,GAAU,CADrB;AAAA,IAEWC,EAAAA,GAAmB,IAF9B;AAAA,IAIaC,EAAAA,GAAeC,CAAAA,IAAAA;AAC1Bd,EAAAA,EAAAA,GAAWc,CAAXd;AAAWc,CALb;AAAA,IAOaC,EAAAA,GAAkBC,CAAAA,IAAAA;AAC7BJ,EAAAA,EAAAA,GAAcI,CAAdJ;AAAcI,CARhB;;AAWA,MAAMC,EAAAA,GAAgB,CAAClB,CAAD,EAAYzC,CAAZ,KAAYA;AAAAA,MAC5ByC,CAD4BzC,EACtB;AAAA,WACDyC,CAAAA,IAAAA,CAASA,CAAAA,CAAK3C,GAAL2C,CAASzC,CAATyC,CADR,GAENA,CAAAA,GAAO1D,EAAAA,CAAU0D,CAAV1D,CAAP0D;;AAAiBA,QAEfA,CAFeA,EAET,OAAOA,CAAP;AAAOA;;AAAAA,SAEZ,IAFYA;AAEZ,CAPT;AAAA,MASMmB,EAAAA,GAAa,CAACnB,CAAD,EAAYrC,CAAZ,EAAwBJ,CAAxB,KAAwBA,CACtB2D,EAAAA,CAAclB,CAAdkB,EAAoB3D,CAApB2D,CAAAA,IACevD,CAFOJ,EAEDF,GAFCE,CAEGA,CAFHA,CAT3C;AAAA,MA2LMsF,EAAAA,GAAS,CAACZ,CAAD,EAACA;AAAevF,EAAAA,EAAAA,EAAAA;AAAfuF,CAAD,EAA0B7B,CAA1B,KAA0BA;AAAAA,MAAAA;AAAAA,WAE9B1D,CAAAA,CAAGmC,EAAAA,CAASuB,CAATvB,CAAHnC,EAAoBuF,CAAAA,CAAMlE,KAA1BrB,EAAiC0D,CAAjC1D,CAF8B0D;AAGrC,GAHqCA,CAGrC,OAAO2C,CAAP,EAAOA;AACPC,IAAAA,OAAAA,CAAQC,KAARD,CAAcD,CAAdC,GACAf,CAAAA,CAAMC,IAAND,GAAa,CADbe;AACa;AAAA,CAhMjB;;AC5MO,IAAME,EAAAA,GAAW,CAAClH,CAAD,EAAYmH,CAAZ,KAA4B,KAAKnH,CAAAA,CAAKoH,SAAV,GAAsBD,CAAnE;AAAA,IAEME,EAAAA,GAAU,CAACrH,CAAD,EAAYQ,CAAZ,KACb,QAARA,CAAQ,GAAO0G,EAAAA,CAASlH,CAATkH,EAAe,MAAfA,CAAP,GAAgC1G,CAHnC;AAAA,I0BDM+O,EAAAA,GAAkB,CAC7B2N,CAD6B,EAE7Bxc,CAF6B,KAE7BA;AAEA5B,EAAAA,CAAAA,CAAaoe,CAAbpe,CAAAA,EACIuK,EAAAA,CAAgB6T,CAAhB7T,CAAAA,IACF3I,CAAAA,CAAGsI,EAAAA,CAAUkU,CAAVlU,CAAHtI,EAAyB2I,EAAAA,CAAgB6T,CAAhB7T,CAAzB3I,CAFF5B;AAE2Coe,C1BLtC;AAAA,I0BSM9J,EAAAA,GAAuBlI,CAAAA,IAAAA;AAAAA,MAC9BiI,CAD8BjI;AAC9BiI,SACJ5D,EAAAA,CAAgBrE,CAAAA,CAAK,CAALA,CAAhBqE,EAAyB,CAACkD,CAAD,EAAW1J,CAAX,KAAWA;AAClCoK,IAAAA,CAAAA,GAAWV,CAAXU,EACAjI,CAAAA,GAAOnC,CADPoK;AACOpK,GAFTwG,CAAAA,EAIO,CAACrE,CAAD,EAAOiI,CAAP,CALHA;AAKUA,C1BfT;AAAA,ICKM5K,EAAAA,GAAW,CAAC1H,CAAD,EAAc0B,CAAd,KAA4B1B,CAAAA,CAAK0H,QAAL1H,CAAc0B,CAAd1B,CDL7C;AAAA,ICOM2H,EAAAA,GAAa,CAAC3H,CAAD,EAAc0B,CAAd,KAAcA;AAAAA,MAChCkG,CAAAA,GAAM5H,CAAAA,CAAK6H,OAAL7H,CAAa0B,CAAb1B,CAD0B0B;AACbA,GACZ,CADYA,KACrBkG,CADqBlG,IAEvB1B,CAAAA,CAAK8H,MAAL9H,CAAY4H,CAAZ5H,EAAiB,CAAjBA,CAFuB0B;AAEN,CDVd;;A2BEP,MAAM4a,EAAAA,GAAiB,CAACC,CAAD,EAAoBC,CAApB,KAAoBA;AACzC7U,EAAAA,EAAAA,CAAW4U,CAAAA,CAAY3a,IAAvB+F,EAA6B6U,CAA7B7U,CAAAA,EACAA,EAAAA,CAAW9F,EAAAA,CAAU0a,CAAV1a,CAAX8F,EAAmC6U,CAAnC7U,CADAA,EAEAA,EAAAA,CAAW7F,EAAAA,CAASya,CAATza,CAAX6F,EAAkC6U,CAAlC7U,CAFAA;AAEkC6U,CAHpC;AAAA,MAKMC,EAAAA,GAAsB,CAC1BD,CAD0B,EAE1BE,CAF0B,EAG1BC,CAH0B,KAG1BA;AAAAA,MAMIJ,CANJI;AAEAH,EAAAA,CAAAA,CAAW5a,IAAX4a,CAAgB7d,MAAhB6d,GAAyB,CAAzBA,EACAA,CAAAA,CAAW/a,GAAX+a,CAAe7d,MAAf6d,GAAwB,CADxBA,EAGAA,CAAAA,CAAWtb,KAAXsb,GAAmB,IAHnBA;AAGmB,MAEfxc,CAAAA,GAAO8B,EAAAA,CAAS0a,CAAT1a,CAFQ;;AAEC0a,SACZD,CAAAA,GAAcvc,CAAAA,CAAK4c,GAAL5c,EADFwc,GAElBF,EAAAA,CAAeC,CAAfD,EAA4BE,CAA5BF,CAAAA,EAA4BE,CAE1BE,CAAAA,IACCC,CAAAA,IAAAA,CAAiBH,CAAAA,CAAWjd,IAAXid,CAAgBtI,MADlCwI,I7BpBmB,gB6BsBnBH,CAAAA,CAAYpb,MAAZob,CAAmBjc,IAJOkc,KAM1BC,EAAAA,CACEF,CADFE,EAEEC,CAFFD,EAG0B,SAAxBF,CAAAA,CAAYhd,IAAZgd,CAAiBtW,EAAO,IAAQ0W,CAHlCF,CANFH;;AASoCK,OAItC3c,CAAAA,GAAO6B,EAAAA,CAAU2a,CAAV3a,CAJ+B8a,EAK9BJ,CAAAA,GAAcvc,CAAAA,CAAK4c,GAAL5c,EALgB2c,GAMpCL,EAAAA,CAAeC,CAAfD,EAA4BE,CAA5BF,CAAAA,EACIK,CAAAA,I7BlCiB,gB6BkCDJ,CAAAA,CAAYpb,MAAZob,CAAmBjc,IAAnCqc,IACFF,EAAAA,CACEF,CADFE,EAEEC,CAFFD,EAG0B,SAAxBF,CAAAA,CAAYhd,IAAZgd,CAAiBtW,EAAO,IAAQ0W,CAHlCF,CAFFH;AAKoCK,CArCxC;AAAA,MA0CME,EAAAA,GAAY1c,CAAAA,IAAaA,CAAAA,CAAI2c,KAAJ3c,EA1C/B;;AA0CmC2c,IACtBhJ,EAAAA,GAAY,CACvBpJ,CADuB,EACvBA;AAEEgS,EAAAA,IAAAA,EAAAA;AAFFhS,IAKI,EANmB,KAMnB;AAAA,MAEAiS,CAAAA,GAAe,CAFf;AAEe,MAEfjS,CAAAA,CAASkI,QAATlI,IAAmBA,CAAAA,CAASkI,QAATlI,CAAkB9E,MAAlB8E,CAAyBA,CAAzBA,CAAnBA,EACA7D,CAAAA,CAAS6D,CAAT7D,CAHe,EAIjBgW,EAAAA,CAAS/P,EAAAA,CAAepC,CAAfoC,CAAT+P,CAAAA,CAJiB,KAKZ,IAAIhW,CAAAA,CAAU6D,CAAV7D,CAAJ,EAAyB;AAC9B8V,IAAAA,CAAAA,GAAe,CAAfA;AAAe,QAETzJ,CAAAA,GAAUxI,CAAAA,CAASwI,OAFV;AAGf2J,IAAAA,EAAAA,CAAS3J,CAAAA,CAAQD,MAAjB4J,CAAAA,EACAA,EAAAA,CAAS3J,CAAAA,CAAQF,OAAjB6J,CADAA,EAEAA,EAAAA,CAAS3J,CAAAA,CAAQzE,MAAjBoO,CAFAA,EAGAA,EAAAA,CAAS3J,CAAAA,CAAQH,OAAjB8J,CAHAA;AAKFJ;AAAAA,EAAAA,EAAAA,CAAoBnd,EAAAA,CAASoL,CAATpL,CAApBmd,EAA6B/R,CAAAA,CAAagS,CAA1CD,EAAgDE,CAAhDF,CAAAA;AAAgDE,CAvBfG;AAAAA,IC5CtBhP,EAAAA,GAAsBhN,CAAAA,IAAAA;AAAAA,MAC3Bb,CAAAA,GAAS4T,EAAAA,CAAMC,EAAND,EAAiB/S,CAAjB+S,EAAiB/S,KAAMiF,CAAvB8N,CADkB/S;AACKiF,SACtC9F,CAAAA,CAAO8c,WAAP9c,GAAqBA,CAArBA,EACOA,CAF+B8F;AAE/B9F,CDyC0B6c;AAAAA,IE1CtB9S,EAAAA,GAAiB,CAC5BxK,CAD4B,EAE5ByB,CAF4B,EAE5BA;AAEEH,EAAAA,IAAAA,EAAAA,CAFFG;AAGEC,EAAAA,KAAAA,EAAAA,CAHFD;AAIE1B,EAAAA,IAAAA,EAAAA;AAJF0B,CAF4B,KAa5BnB,CAAAA,CAAW;AACTgB,EAAAA,IAAAA,EAAAA,CADS;AAETtB,EAAAA,MAAAA,EAAAA,CAFS;AAGTyB,EAAAA,KAAAA,EAAAA,CAHS;AAITC,EAAAA,KAAAA,EAAAA,CAJS;AAKT3B,EAAAA,IAAAA,EAAAA,CALS;AAMT4B,EAAAA,MAAAA,EAAQ;AACNK,IAAAA,MAAAA,EAAQ,CAAChC,CAAD,EAASyB,CAAT,CADF;AAENM,IAAAA,KAAAA,EAAON;AAFD,GANC;AAUTI,EAAAA,QAAAA,EAAU;AAVD,CAAXvB,CF6BiCgd;AAAAA,IEjBtBtJ,EAAAA,GAAW0I,CAAAA,IAAAA;AAAAA,MAKlBhU,CALkBgU;AAMtBxN,EAAAA,EAAAA,CAAgBwN,CAAhBxN,EAAsB,CAACC,CAAD,EAAeC,CAAf,KAAeA;AACnC1G,IAAAA,CAAAA,GAASyG,CAATzG,EACAgU,CAAAA,GAAOtN,CADP1G;AACO0G,GAFTF,CAAAA;AAESE,MAAAA;AAEH7N,IAAAA,IAAAA,EAACA,CAFE6N;AAEH7N,IAAAA,EAAAA,EAAOJ,CAFJiO;AAEH7N,IAAAA,IAAAA,EAAWxB,CAAAA,GAAO;AAAC0G,MAAAA,EAAAA,EAAI;AAAL;AAFf2I,MAEkCsN,CAFlCtN;AAEkCsN,SAC3C3d,CAAAA,CAAcwC,CAAdxC,EAAoB,SAApBA,EAA+B,QAA/BA,CAAAA,EACAA,CAAAA,CAAcoC,CAAdpC,EAAkB,SAAlBA,EAA6B,MAA7BA,CADAA,EAEI2J,CAAAA,KAAQ3I,CAAAA,CAAK2I,MAAL3I,GAAc2I,CAAtBA,CAFJ3J,EAGOuP,EAAAA,CACLhO,CAAAA,CAAW;AACTN,IAAAA,MAAAA,EAAQuB,CADC;AAETE,IAAAA,KAAAA,EAAON,CAFE;AAGTpB,IAAAA,IAAAA,EAAAA,CAHS;AAIT4B,IAAAA,MAAAA,EAAQ,EAJC;AAKTE,IAAAA,QAAAA,EAAU;AALD,GAAXvB,CADKgO,CAJoCoO;AAU7B,CFHmBY;AAAAA,IGtCtBjS,EAAAA,GAAY,CACvB1L,CADuB,EAEvBiJ,CAFuB,KAEvBA;AAAAA,MAEKpK,CAAAA,CAAWoK,CAAXpK,CAAAA,IAAqBE,CAAAA,CAAW,sCAAXA,CAArBF,EACDoF,EAHJgF,EAGc;AAAA,QACN4U,CAAAA,GAAa5Z,EAAAA,CAASkJ,OAATlJ,CAAiB9D,EAAAA,CAASH,CAATG,CAAAA,CAAeoB,EAAhC0C,CADP;AAER4Z,IAAAA,CAAAA,KAAY7d,CAAAA,GAAO6d,CAAnBA,CAAAA;AAAmBA;;AAAAA,SAElBlP,EAAAA,CACLhO,CAAAA,CAAW;AACToB,IAAAA,KAAAA,EAAO;AAACrB,MAAAA,EAAAA,EAAIuI;AAAL,KADE;AAETtH,IAAAA,IAAAA,EAAM,CAACyE,EAAAA,CAAS;AAAC1F,MAAAA,EAAAA,EAAIoK;AAAL,KAAT1E,CAAD,CAFG;AAGT/F,IAAAA,MAAAA,EAAQL,CAHC;AAITI,IAAAA,IAAAA,EAAM;AAAC0G,MAAAA,EAAAA,EAAI;AAAL,KAJG;AAKT9E,IAAAA,MAAAA,EAAQ;AACNK,MAAAA,MAAAA,EAAQrC;AADF,KALC;AAQTkC,IAAAA,QAAAA,EAAU;AARD,GAAXvB,CADKgO,CAFkBkP;AAWX,CHoBmBF;;AzBhBnC,MAAM9U,EAAAA,GAAkB,CAACC,CAAD,EAAYC,CAAZ,MAClBpK,CAAAA,CAASmK,CAATnK,CAAAA,KACFkK,EAAAA,CAAgBG,EAAAA,CAAUF,CAAVE,CAAhBH,EAAiCE,CAAjCF,CAAAA,EACiB,QAAbC,CAAAA,CAAKtI,IAAQ,KACX7B,CAAAA,CAASmK,CAAAA,CAAKtI,IAAd7B,CAAAA,GAAqBkK,EAAAA,CAAgBC,CAAAA,CAAKtI,IAArBqI,EAA2BE,CAA3BF,CAArBlK,GACKE,CAAAA,CAAWiK,CAAAA,CAAKtI,IAAhB3B,CAAAA,GAAuBkK,CAAAA,CAAOE,OAAPF,GAAiBD,CAAAA,CAAKtI,IAA7C3B,GACJkK,CAAAA,CAAOvI,IAAPuI,GAAcD,CAAAA,CAAKtI,IAHT,CADjBqI,EAMIC,CAAAA,CAAKrI,GAALqI,KAAUC,CAAAA,CAAOtI,GAAPsI,GAAaD,CAAAA,CAAKrI,GAA5BqI,CANJD,EAMgCpI,CAC5BqI,CAAAA,CAAKjJ,GAALiJ,IAAyB,SAAbA,CAAAA,CAAKjJ,GADWY,MACGsI,CAAAA,CAAOlJ,GAAPkJ,GAAaD,CAAAA,CAAKjJ,GADrBY,CANhCoI,EAQIC,CAAAA,CAAKG,OAALH,KAAcC,CAAAA,CAAOE,OAAPF,GAAiBD,CAAAA,CAAKG,OAApCH,CARJD,EASIC,CAAAA,CAAKI,YAALJ,KAAmBC,CAAAA,CAAOG,YAAPH,GAAsBD,CAAAA,CAAKI,YAA9CJ,CATJD,EAUIvI,EAAAA,CAAUwI,CAAVxI,CAAAA,KAAiByI,CAAAA,CAAO1I,MAAP0I,GAAgBzI,EAAAA,CAAUwI,CAAVxI,CAAjCA,CAVJuI,EAWI,YAAYC,CAAZ,KAAkBC,CAAAA,CAAOI,MAAPJ,GAAgBD,CAAAA,CAAKK,MAAvC,CAXJN,EAYIC,CAAAA,CAAKM,KAALN,KAAYC,CAAAA,CAAOK,KAAPL,GAAeD,CAAAA,CAAKM,KAAhCN,CAZJD,EAaAA,EAAAA,CAAgBQ,EAAAA,CAAgBP,CAAhBO,CAAhBR,EAAuCE,CAAvCF,CAdElK,GAgBGoK,CAjBe,CAAxB;;AAoBO,IAQHU,EARG;AAAA,IAAMH,EAAAA,GAAkB,CAC7BzH,CAD6B,EAE7BH,CAF6B,EAG7B6H,CAAAA,GJtDmB,OImDU,KJnDV;AIwDfjJ,EAAAA,EAAAA,CAAUuB,CAAVvB,CAAAA,IAAmBA,EAAAA,CAAUuB,CAAVvB,CAAAA,CAAkBkJ,KAAlBlJ,CAAwBiJ,CAAxBjJ,EAAkCoB,CAAlCpB,CAAnBA;AAAqDoB,CALpD;AAAA,IASMgI,EAAAA,GAAW,CACtBC,CADsB,EAEtB3J,CAFsB,EAGtB4J,CAHsB,EAItBC,CAJsB,KAItBA;AAAAA,MAEMd,CAAAA,GAASF,EAAAA,CACb;AACErI,IAAAA,IAAAA,EAAMqJ,CADR;AAEEd,IAAAA,MAAAA,EAAQa;AAFV,GADaf,EAKb,EALaA,CAFfgB;AAAAA,MASMC,CAAAA,GJvEc,aIuEHH,CATjBE;AAAAA,MAUMtI,CAAAA,GAAKwI,CAAAA,EAVXF;AAAAA,MAUWE;AACP1J,IAAAA,MAAAA,EAACA,CAAAA,GAAS,IADH0J;AACP1J,IAAAA,GAAAA,EAAgBR,CAAAA,GAAM,IADfkK;AACP1J,IAAAA,MAAAA,EAA4B8I,CAAAA,GAAS,CAD9BY;AACP1J,IAAAA,KAAAA,EAA2C+I,CAAAA,GAAQ;AAD5CW,MACoDhB,CAX/Dc;AAAAA,MAYMrJ,CAAAA,GAAO4I,CAAAA,IAAgBL,CAAAA,CAAOvI,IAAvB4I,KAAgCU,CAAAA,GAAW,EAAXA,GAAgBvI,CAAhD6H,CAZbS;AAAAA,MAaMlC,CAAAA,GAAgBK,CAAAA,CAAWxH,CAAXwH,EAAiB3H,CAAjB2H,CAbtB6B;AAAAA,MAeMzJ,CAAAA,GAA4B;AAChCJ,IAAAA,IAAAA,EAAMA,CAAAA,CAAK2J,IAAL3J,GAAY2J,CADc;AAEhCnJ,IAAAA,IAAAA,EAAMR,CAAAA,CAAKoH,SAALpH,GAAiBQ,CAFS;AAGhCX,IAAAA,GAAAA,EAAKG,CAAAA,CAAKH,GAALG,GAAWJ,EAAAA,CAAYC,CAAZD,CAHgB;AAIhCwJ,IAAAA,KAAAA,EAAAA,CAJgC;AAKhCY,IAAAA,MAAAA,EAAQhK,CAAAA,CAAKuB,EAALvB,GAAUuB;AALc,GAflCsI;;AAoBoBtI,MAEpBvB,CAAAA,CAAKK,MAALL,GAAcK,CAAdL,EACAA,CAAAA,CAAK2H,aAAL3H,GAAqB2H,CADrB3H,EAEAA,CAAAA,CAAKiK,aAALjK,GAAqB+I,CAFrB/I,EAGAA,CAAAA,CAAKkK,IAALlK,GAAaU,CAAAA,IAAiBA,CAAAA,CAAGV,CAAHU,CAH9BV,EAIAA,CAAAA,CAAKmK,OAALnK,GAAe,MAAM2H,CAAAA,CAAcC,QAJnC5H,EAImC4H,CAC9BkC,CAPevI,EAOL;AACbvB,IAAAA,CAAAA,CAAKoK,SAALpK,GAAkBqK,CAAAA,KAChBvL,CAAAA,CAAauL,CAAbvL,CAAAA,EACOkB,CAAAA,CAAKsK,KAALtK,CACLnB,CAAAA,CAAWwL,CAAXxL,CAAAA,GACIwL,CADJxL,GAEK0L,CAAAA,IAAAA;AACKF,MAAAA,CAAAA,CAAS5H,IAAT4H,IACFA,CAAAA,CAAS5H,IAAT4H,CAAcE,CAAdF,CADEA;AACYE,KALjBvK,CAFSqK,CAAlBrK,EAYAA,CAAAA,CAAKwK,CAALxK,CAAAA,GAAyB,MAAMA,CAZ/BA;AAY+BA,QACzBL,CAAAA,GAAWD,EAAAA,EADcM;AAE3BL,IAAAA,CAAAA,KAAUS,CAAAA,CAAKqK,cAALrK,GAAsBT,CAAhCA,CAAAA;AAAgCA;;AAAAA,SAEtC8J,EAAAA,GAAWN,CAAXM,EACOrJ,CAH+BT;AAG/BS,CA1DF;AAAA,IA4DMsK,EAAAA,GAAoBtB,CAAAA,IAAkBuB,CAAAA,CAAY;AAACvB,EAAAA,KAAAA,EAAAA;AAAD,CAAZuB,CA5D5C;;AA8DP,MAAMC,EAAAA,GAAoB,CAAChJ,CAAD,EAAYJ,CAAZ,EAAqBsF,CAArB,EAA8BpG,CAA9B,KACxBmK,EAAAA,CAAejJ,CAAfiJ,EAAqBrJ,CAArBqJ,EAAyB;AACvB9I,EAAAA,KAAAA,EAAO;AAACrB,IAAAA,EAAAA,EAAAA;AAAD,GADgB;AAEvBiB,EAAAA,IAAAA,EAAM,CAACyE,EAAAA,CAAa;AAAC1F,IAAAA,EAAAA,EAAIoK;AAAL,GAAb1E,CAAD,CAFiB;AAGvBhG,EAAAA,IAAAA,EAAM;AAAC0G,IAAAA,EAAAA,EAAAA;AAAD;AAHiB,CAAzB+D,CADF;AAAA,MAOME,EAAAA,GAAwB,CAACC,CAAD,EAAalE,CAAb,EAAyBpG,CAAzB,EAAkCiB,CAAlC,KAAkCA;AAAAA,MAC1DoH,CAD0DpH;AAE1DhD,EAAAA,CAAAA,CAAS+B,CAAT/B,CAAAA,KACFoK,CAAAA,GAASrI,CAATqI,EACArI,CAAAA,GAAKA,CAAAA,CAAGA,EAFN/B;AAEM+B,MAEJuK,CAAAA,GAASN,CAAAA,CAAYzD,EAAAA,CAAS8D,CAAT9D,EAAgB,OAAhBA,CAAZyD,EAAsC5B,CAAtC4B,CAFLjK;AAE2CqI,SACrD8B,EAAAA,CAAeG,CAAfH,EAAsBI,CAAtBJ,EAA8B;AAC5B9I,IAAAA,KAAAA,EAAO;AAACrB,MAAAA,EAAAA,EAAAA;AAAD,KADqB;AAE5BiB,IAAAA,IAAAA,EAAAA,CAF4B;AAG5BvB,IAAAA,IAAAA,EAAM;AAAC0G,MAAAA,EAAAA,EAAAA;AAAD;AAHsB,GAA9B+D,CAAAA,EAKOI,CAN8ClC;AAM9CkC,CAnBT;AAAA,MAuQMiD,EAAAA,GAAc,CAClBtM,CADkB,EAElBN,CAFkB,EAGlBwF,CAHkB,EAIlBiI,CAJkB,EAKlBrO,CALkB,EAMlBwI,CANkB,KAMlBA;AAAAA,MAEM8F,CAAAA,GAAWb,EAAAA,CAAc7M,CAAd6M,CAFjBjF;AAAAA,MAGMvH,CAAAA,GAAO,CACXyE,EAAAA,CAAS;AAAC9E,IAAAA,KAAAA,EAAO0N,CAAR;AAAkBxN,IAAAA,EAAAA,EJtXV;AIsXR,GAAT4E,CADW,EAEXA,EAAAA,CAAa;AACX1F,IAAAA,EAAAA,EAAIqO,CAAAA,GAAaE,EAAbF,GAA6BG;AADtB,GAAb9I,CAFW,EAKXA,EAAAA,CAAWyF,OAAXzF,EALW,EAMXA,EAAAA,CAAWwI,OAAXxI,CAAmB;AAAC9E,IAAAA,KAAAA,EAAO0N;AAAR,GAAnB5I,CANW,EAOX8C,CAAAA,IACE9C,EAAAA,CAAY;AACV1F,IAAAA,EAAAA,EAAI,CAACmO,CAAD,EAASC,CAAT,EAASA;AAAI5L,MAAAA,CAAAA,EAAAA;AAAJ4L,KAAT,KAAoB5F,CAAAA,CAAa2F,CAAb3F,EAAqBhG,CAArBgG;AADd,GAAZ9C,CARS,EAWXA,EAAAA,CAAY;AAAC9E,IAAAA,KAAAA,EAAO0N;AAAR,GAAZ5I,CAXW,CAHb8C;AAAAA,MAgBMvJ,CAAAA,GAAWD,EAAAA,EAhBjBwJ;;AAgBiBxJ,MACbC,CAAAA,KACFgC,CAAAA,CAAK2M,OAAL3M,CAAahC,CAAAA,CAAS0O,MAAtB1M,GACAA,CAAAA,CAAKZ,IAALY,CAAUhC,CAAAA,CAASqM,MAAnBrK,CADAA,EAEI+F,CAAAA,CAAS9F,CAAT8F,CAHF/H,CADaD,EAIK;AAAA,QACZyP,CAAAA,GAAMhB,EAAAA,CAAcvM,CAAduM,CADM;AAEb5F,IAAAA,EAAAA,CAAS5I,CAAAA,CAAS8M,KAAlBlE,EAAyB4G,CAAzB5G,CAAAA,KAIEA,EAAAA,CAAS5I,CAAAA,CAASyP,OAAlB7G,EAA2B4G,CAA3B5G,CAAAA,IACH5I,CAAAA,CAASyP,OAATzP,CAAiBoB,IAAjBpB,CAAsBwP,CAAtBxP,CADG4I,EAGAyG,CAAAA,CAASZ,MAATY,KAAiBA,CAAAA,CAASZ,MAATY,GAAkB,EAAnCA,CAHAzG,EAILyG,CAAAA,CAASZ,MAATY,CAAgBjO,IAAhBiO,CAAqB;AACnB7N,MAAAA,IAAAA,EAAM,SADa;AAEnBsN,MAAAA,EAAAA,EAAIU;AAFe,KAArBH,CARGzG;AAUG4G;;AAAAA,SASLtE,EAAAA,CAAejJ,CAAfiJ,EAAqBvJ,CAArBuJ,EAA4B;AACjC9I,IAAAA,KAAAA,EAAO;AAACrB,MAAAA,EAAAA,EAAAA;AAAD,KAD0B;AAEjCiB,IAAAA,IAAAA,EAAAA,CAFiC;AAGjCvB,IAAAA,IAAAA,EAAM;AAAC0G,MAAAA,EAAAA,EAAAA;AAAD;AAH2B,GAA5B+D,CATKsE;AAYHrI,CAzTX;AAAA,MCrCMgJ,EAAAA,GAAcpP,CAAAA,IAAkBG,CAAAA,IAAgBH,CAAAA,CAAAA,GAAMG,CAANH,CDqCtD;AAAA,MCnCMqP,EAAAA,GAAmB,CACvBzQ,CADuB,EAEvBgJ,CAFuB,EAGvBS,CAHuB,EAIvBrI,CAJuB,KAIvBA;AAAAA,MAEMsP,CAAAA,GAAQ1Q,CAAAA,GAAWuB,CAAAA,IAAcA,CAAAA,CAAK8O,KAAL9O,EAAzBvB,GAAyCgJ,CAAAA,KAAAA,EAAAA,GAAkBA;AAAlBA,GAAAA,CAFvD5H;AAAAA,MAGMwL,CAAAA,GAAoB5M,CAAAA,GAAU,EAAVA,GAAe,EAHzCoB;AAAAA,MAIMf,CAAAA,GAAWD,EAAAA,EAJjBgB;AAAAA,MAKMuP,CAAAA,GAAWD,CAAAA,CAAM9D,CAAN8D,CALjBtP;AAAAA,MAMMwP,CAAAA,GAAW7D,EAAAA,CAAe4D,CAAf5D,CANjB3L;AAAAA,MAOMyP,CAAAA,GAAU9D,EAAAA,CAAe,CAAfA,CAPhB3L;AAQAwP,EAAAA,CAAAA,CAAS/O,IAAT+O,GAAgB5Q,CAAAA,GAAU,MAAVA,GAAmB,OAAnC4Q,EACIvQ,CAAAA,IACFA,CAAAA,CAAS8M,KAAT9M,CAAeoB,IAAfpB,CAAoBuQ,CAApBvQ,EAA8BwQ,CAA9BxQ,CAFFuQ;AAEgCC,MAE1B7O,CAAAA,GAAQ2K,CAAAA,CAAYgE,CAAZhE,EAAsB;AAClCzL,IAAAA,IAAAA,EAAMuI,CAAAA,IAAkBzB,CAAAA,CAAegB,CAAfhB;AADU,GAAtB2E,CAFkBkE;AAKhChQ,EAAAA,EAAAA,CAASmB,CAATnB,CAAAA,CAAgBC,IAAhBD,CAAqBiQ,SAArBjQ,GAAiC,CAAjCA;AAAiC,MAC3BwB,CAAAA,GAAO,CACXyE,EAAAA,CAAWyF,OAAXzF,EADW,EAEXA,EAAAA,CAAS;AACP9E,IAAAA,KAAAA,EAAO4O,CADA;AAEP1O,IAAAA,EAAAA,EL1Fe;AKwFR,GAAT4E,CAFW,EAOXA,EAAAA,CAAY;AACV1F,IAAAA,EAAAA,EAAI,CAAC6J,CAAD,EAACA;AAAM9C,MAAAA,GAAAA,EAAAA;AAAN8C,KAAD,EAAO9C;AAAOvE,MAAAA,CAAAA,EAAAA;AAAPuE,KAAP,KAAqB8C,CAAAA,KAAQrH,CAAAA,CAAEuE,CAAFvE;AADvB,GAAZkD,CAPW,EAUXA,EAAAA,CAAS;AACP9E,IAAAA,KAAAA,EAAO6O,CADA;AAEP3O,IAAAA,EAAAA,EAAI;AAFG,GAAT4E,CAVW,EAcXA,EAAAA,CAAa;AACX1F,IAAAA,EAAAA,CAAG6J,CAAH7J,EAAG6J;AAAKyF,MAAAA,KAAAA,EAACA,CAANzF;AAAKyF,MAAAA,GAAAA,EAAQvI;AAAb8C,KAAH7J,EAAsBW,CAAtBX,EAAsBW;AAChBA,MAAAA,CAAAA,CAAI8B,CAAJ9B,KACFA,CAAAA,CAAI6B,CAAJ7B,GAAQ2O,CAAAA,CAAM3O,CAAAA,CAAI6B,CAAV8M,CADN3O,GAGJA,CAAAA,CAAI6B,CAAJ7B,CAAMoG,CAANpG,IAAakJ,CAHTlJ;AAGSkJ;;AALJ,GAAbnE,CAdW,EAsBXA,EAAAA,CAAS;AACPxE,IAAAA,IAAAA,EL7Ge,GK4GR;AAEPF,IAAAA,MAAAA,EAAQwO;AAFD,GAAT9J,CAtBW,EA0BXA,EAAAA,CAAS;AACPxE,IAAAA,IAAAA,ELrHe,OKoHR;AAEPN,IAAAA,KAAAA,EAAO,CAFA;AAGPI,IAAAA,MAAAA,EAAQyO;AAHD,GAAT/J,CA1BW,EA+BXA,EAAAA,CAAa;AAAC/B,IAAAA,QAAAA,EL1HK;AK0HN,GAAb+B,CA/BW,EAgCXA,EAAAA,CAAS;AACPxE,IAAAA,IAAAA,EL3He,OK0HR;AAEPN,IAAAA,KAAAA,EAAO,CAFA;AAGPI,IAAAA,MAAAA,EAAQyO;AAHD,GAAT/J,CAhCW,EAqCXA,EAAAA,CAAS;AAAC9E,IAAAA,KAAAA,EAAO4O;AAAR,GAAT9J,CArCW,EAsCX1F,CAAAA,IAAM0F,EAAAA,CAAa;AAAC1F,IAAAA,EAAAA,EAAAA;AAAD,GAAb0F,CAtCK,EAuCXA,EAAAA,CAAWwI,OAAXxI,CAAmB;AACjB9E,IAAAA,KAAAA,EAAO6M,EAAAA,CAAc7M,CAAd6M;AADU,GAAnB/H,CAvCW,CADoB;AAAA,MA4C3BgI,CAAAA,GAAiB8B,CAAAA,CAAS9B,MAAT8B,GAAkB,EA5CR;AA4CQ,SACzC7H,CAAAA,CAAMC,CAAND,EAAW,CAACvG,CAAD,EAA0B2F,CAA1B,KAA0BA;AAAAA,QAAAA,CAC9BC,CAAAA,CAAS5F,CAAT4F,CAD8BD,EACrB3F,OAAAA,MACZmO,CAAAA,CAASxI,CAATwI,CAAAA,GAAgB/D,CAAAA,CAAazE,CAAbyE,CAAAA,GAAoBpK,CADxBA,CAAAA;AAIdoK,IAAAA,CAAAA,CAAazE,CAAbyE,CAAAA,GAAoBpK,CAAAA,CAAMoK,YAA1BA,EACA+D,CAAAA,CAASxI,CAATwI,CAAAA,GAAgBnO,CAAAA,CAAMgL,QAANhL,EADhBoK;AACsBY,QAChBmB,CAAAA,GAAWpD,EAAAA,CAAe/I,CAAf+I,EAAsBvJ,CAAtBuJ,EAA6B;AAC5C9I,MAAAA,KAAAA,EAAO;AAAC0F,QAAAA,GAAAA,EAAAA,CAAD;AAAMuI,QAAAA,KAAAA,EAAAA;AAAN,OADqC;AAE5CrO,MAAAA,IAAAA,EAAAA,CAF4C;AAG5CvB,MAAAA,IAAAA,EAAM;AAAC0G,QAAAA,EAAAA,EAAI;AAAL;AAHsC,KAA7B+D,CADKiC;AAAAA,QAMhBuD,CAAAA,GAAWlC,EAAAA,CAAcrM,CAAdqM,CANKrB;AAOtBsB,IAAAA,CAAAA,CAAOrN,IAAPqN,CAAY;AACVjN,MAAAA,IAAAA,EAAM,OADI;AAEVmP,MAAAA,KAAAA,EAAO7I,CAFG;AAGV7F,MAAAA,IAAAA,EAAMyO;AAHI,KAAZjC,GAKIzO,CAAAA,KACG4I,EAAAA,CAAS5I,CAAAA,CAAS8M,KAAlBlE,EAAyB8H,CAAzB9H,CAAAA,IACH0F,CAAAA,CAAS3L,GAAT2L,CAAaK,OAAbL,CAAqBtO,CAAAA,CAAS0O,MAA9BJ,CAFAtO,CALJyO;AAOkCC,GApBpChG,CAAAA,EAyBA/G,CAAAA,CAAMiP,YAANjP,GAAqBgH,CAzBrBD,EA0BA6H,CAAAA,CAAS1D,KAAT0D,GAAiB,CACfxP,CAAAA,GACI;AACES,IAAAA,IAAAA,EAAM4B,CADR;AAEEvB,IAAAA,EAAAA,EAAI2M,EAAAA,CAAc7M,CAAd6M,CAFN;AAGEzN,IAAAA,EAAAA,EAAAA;AAHF,GADJA,GAMI;AACES,IAAAA,IAAAA,EAAM,MADR;AAEEK,IAAAA,EAAAA,EAAI2M,EAAAA,CAAc7M,CAAd6M;AAFN,GAPW,CA1BjB9F,EAsCK1I,CAAAA,KACH2B,CAAAA,CAAM4K,YAAN5K,GAAqBZ,CAAAA,GAChByN,EAAAA,CAAc7M,CAAd6M,CAAAA,CAAqBxH,OAArBwH,GAA+BzN,CAAAA,CAAGuP,CAAHvP,CADfA,GAEjBwL,CAHDvM,CAtCL0I,EA2CO/G,CA5CkC;AA4ClCA,CDxET;;AG8CO,IAAMsQ,EAAAA,GAAY,CAAA;AACvBlM,EAAAA,MAAAA,EAAAA,CADuB;AAEvB+K,EAAAA,GAAAA,EAAAA,CAFuB;AAGvBoB,EAAAA,EAAAA,EAAAA,CAHuB;AAIvBX,EAAAA,MAAAA,EAAAA,CAJuB;AAKvB9M,EAAAA,KAAAA,EAAAA;AALuB,CAAA,KAelBhD,CAAAA,IACLgE,CAAAA,CAAO;AACL1D,EAAAA,MAAAA,EAAQ,CAACwP,CAAD,EAASqB,EAAT,CADH;AAEL7M,EAAAA,MAAAA,EAAQ,CACNmM,CAAAA,GACI;AACER,IAAAA,MAAAA,EAAQ,MADV;AAEE3L,IAAAA,MAAAA,EAAAA,CAFF;AAGE5E,IAAAA,MAAAA,EAAQM;AAHV,GADJyQ,GAMI;AACER,IAAAA,MAAAA,EAAQ,MADV;AAEE3L,IAAAA,MAAAA,EAAAA,CAFF;AAGEuB,IAAAA,KAAAA,EAAO7F;AAHT,GAPE,EAYN;AACEV,IAAAA,EAAAA,EAAImR,CAAAA,GAAKpB,CAAAA,CAAIE,EAATkB,GAAcpB,CAAAA,CAAIG,EADxB;AAEEhS,IAAAA,KAAAA,EAAOwC;AAFT,GAZM,CAFH;AAmBLuE,EAAAA,KAAAA,EAAO,CAnBF;AAoBL3B,EAAAA,IAAAA,EAAMI,CAAAA,CAAMJ,IApBP;AAqBLC,EAAAA,QAAAA,EAAU2B,EAAAA,CAAYxB,CAAZwB;AArBL,CAAPR,CAhBK;AAAA,IAwCMmN,EAAAA,GAAY5R,CAAAA,CAAW;AAClCgB,EAAAA,IAAAA,EAAM,CACJyE,EAAAA,CAAS;AACP1F,IAAAA,EAAAA,CAAAA;AAAGA,MAAAA,EAAAA,EAACA,CAAJA;AAAGA,MAAAA,KAAAA,EAAK9B;AAAR8B,KAAAA,EAAQ9B;AACN8B,MAAAA,CAAAA,CAAG9B,CAAH8B,CAAAA;AAAG9B;;AAFE,GAATwH,CADI,CAD4B;AAQlChG,EAAAA,IAAAA,EAAM;AAAC0G,IAAAA,EAAAA,EAAI,IAAL;AAAWkL,IAAAA,EAAAA,EAAI;AAAf;AAR4B,CAAXrR,CAxClB;;AG9IP,MAAM0S,EAAAA,GAAa,CAACC,CAAD,EAAsBC,CAAtB,EAAqC5R,CAArC,MACjB2R,CAAAA,CAAQlI,MAARkI,GAAiBE,CAAAA,KACfpO,CAAAA,CAAOkO,CAAPlO,EAAgBoO,CAAhBpO,CAAAA,EACOoO,CAFQA,CAAjBF,EAIAnT,EAAAA,CAASmT,CAATnT,CAAAA,CAAkBmC,GAAlBnC,CAAsBY,IAAtBZ,CACEiG,EAAAA,CAAa;AACX1F,EAAAA,EAAAA,EAAE,CAAC6J,CAAD,EAAMuE,CAAN,EAAS1K,CAAT,MACAA,CAAAA,CAAMH,QAANG,GAAiB,IAAjBA,EACOmG,CAFP;AADS,CAAbnE,CADFjG,CAJAmT,EAYAA,CAAAA,CAAQhJ,KAARgJ,CAAclS,CAAAA,IAAAA;AACZwB,EAAAA,EAAAA,CAAIjB,CAAJiB,EAAU,CAACxB,CAAD,CAAVwB,CAAAA,EACA2Q,CAAAA,CAAI/M,GAAJ+M,CAAQnS,CAARmS,CADA3Q,EAEKxB,CAAAA,CAAKqS,QAALrS,KAAeA,CAAAA,CAAKqS,QAALrS,GAAgBmS,CAA/BnS,CAFLwB,EAGKtC,EAAAA,CAAUc,CAAVd,CAAAA,KAAiBc,CAAAA,CAAKf,MAALe,GAAcO,CAA/BrB,CAHLsC;AAGoCjB,CAJtC2R,CAZAA,EAkBA1Q,EAAAA,CAAIjB,CAAJiB,EAAU,CAAC0Q,CAAD,CAAV1Q,CAlBA0Q,EAmBQI,CAAAA,KACNH,CAAAA,CAAI3K,OAAJ2K,CAAYG,CAAZH,GACOD,CAAAA,CAAQhJ,KAARgJ,CAAcI,CAAdJ,CAFDI,CApBS,CAAnB;AAAA,MGAMmB,EAAAA,GAAqB,CAAC,QAAD,EAAW,OAAX,EAAoB,QAApB,CHA3B;AAAA,MMFMgB,EAAAA,GAAa,CACjBC,CADiB,EAEjBxF,CAFiB,EAGjBlP,CAHiB,EAIjBgD,CAJiB,KAIjBA;AAAAA,MAEM1C,CAAAA,GAASoU,CAAAA,CAAaxF,CAAbwF,CAFf1R;AAGI1C,EAAAA,CAAAA,IACF0D,CAAAA,CAAO;AACL1D,IAAAA,MAAAA,EAAAA,CADK;AAELgE,IAAAA,MAAAA,EAAQrG,KAAAA,CAAMC,OAAND,CAAcqC,CAAdrC,IAAwBqC,CAAAA,CAAOV,GAAPU,CAAW,MAAMN,CAAjBM,CAAxBrC,GAAiD+B,CAFpD;AAGLuE,IAAAA,KAAAA,EAAO,CAHF;AAILvB,IAAAA,KAAAA,EAAAA;AAJK,GAAPgB,CADE1D;AAKA0C,CNVN;AAAA,MMUMA,EAAAA,GAAAA,SNVN;;AMUMA,SAAAA,CAAAA,IAAAA,UAAAA,EAAAA,CAAAA,IAAAA,MAAAA,EAAAA,EAAAA,IAAAA,SAAAA,EAAAA,CAAAA,IAAAA,OAAAA,EAAAA,CAAAA,IAAAA,SAAAA,EAAAA,CAAAA,IAAAA,YAAAA,EAAAA,CAAAA,IAAAA,YAAAA,EAAAA,CAAAA,IAAAA,WAAAA,EAAAA,CAAAA,IAAAA,UAAAA,EAAAA,CAAAA,IAAAA,WAAAA,EAAAA,CAAAA,IAAAA,iBAAAA,EAAAA,CAAAA,IAAAA,IAAAA,EAAAA,EAAAA,IAAAA,OAAAA,EAAAA,CAAAA,IAAAA,cAAAA,EAAAA,CAAAA,IAAAA,KAAAA,EAAAA,CAAAA,IAAAA,OAAAA,EAAAA,CAAAA,IAAAA,EAAAA,EAAAA,CAAAA,IAAAA,MAAAA,EAAAA,CAAAA,IAAAA,KAAAA,EAAAA,CAAAA,IAAAA,OAAAA,EAAAA,CAAAA,IAAAA,MAAAA,EAAAA,CAAAA,IAAAA,SAAAA,EAAAA,CAAAA,IAAAA,SAAAA,EAAAA,CAAAA,IAAAA,YAAAA,EAAAA,CAAAA,IAAAA,KAAAA,EAAAA,EAAAA,IAAAA,IAAAA,EAAAA,EAAAA,IAAAA,OAAAA,EAAAA,EAAAA,IAAAA,WAAAA,EAAAA,CAAAA,IAAAA,UAAAA","sourcesContent":["//eslint-disable-next-line\nexport * as is from './validate'\nimport {throwError} from './throw'\n\nexport const isObject = (value: any) =>\n  typeof value === 'object' && value !== null\nexport const isFunction = (value: any) => typeof value === 'function'\n\nexport const assertObject = (value: any) => {\n  if (!isObject(value) && !isFunction(value))\n    throwError('expect first argument be an object') // or function\n}\n\nfunction assertNodeSetItem(value: any, method: string, valueName: string, reason: string) {\n  if ((!isObject(value) && !isFunction(value)) || (!('family' in value) && !('graphite' in value))) {\n    throwError(`${method}: expect ${valueName} to be a unit (store, event or effect)${reason}`)\n  }\n}\nexport function assertNodeSet(value: any, method: string, valueName: string) {\n  if (Array.isArray(value)) {\n    for (let i = 0; i < value.length; i++) {\n      const item = value[i]\n      assertNodeSetItem(item, method, `${i} item of ${valueName}`, '')\n    }\n  } else {\n    assertNodeSetItem(value, method, valueName, ' or array of units')\n  }\n}\n","import {getValue, getGraph, getParent} from './getter'\nimport {own} from './own'\nimport {createNode} from './createNode'\n\ntype RegionStack = {\n  parent: RegionStack | null\n  value: any\n  template: any\n  sidRoot?: string\n}\n\nexport let regionStack: RegionStack | null = null\n\nexport const readTemplate = () => regionStack && regionStack.template\nexport const readSidRoot = (sid?: string | null) => {\n  if (sid && regionStack && regionStack.sidRoot)\n    sid = `${regionStack.sidRoot}ɔ${sid}`\n  return sid\n}\n\nexport function withRegion(unit: any, cb: () => void) {\n  const unitMeta = getGraph(unit).meta\n  regionStack = {\n    parent: regionStack,\n    value: unit,\n    template: unitMeta.template || readTemplate(),\n    sidRoot: unitMeta.sidRoot || (regionStack && regionStack.sidRoot),\n  }\n  try {\n    return cb()\n  } finally {\n    regionStack = getParent(regionStack)\n  }\n}\n\nexport const withFactory = ({\n  sid,\n  name,\n  loc,\n  method,\n  fn,\n}: {\n  sid: string\n  name?: string\n  loc?: any\n  method?: string\n  fn: () => any\n}) => {\n  const sidNode = createNode({\n    meta: {\n      sidRoot: readSidRoot(sid),\n      name,\n      loc,\n      method,\n    },\n  })\n  return withRegion(sidNode, fn)\n}\n","import {Node, NodeUnit, Cmd, StateRef} from './index.h'\nimport {getGraph, getOwners, getLinks, getValue} from './getter'\nimport {nextNodeID} from './id'\nimport {CROSSLINK, STORE} from './tag'\nimport {regionStack} from './region'\nimport {own} from './own'\n\nconst arrifyNodes = (\n  list: NodeUnit | Array<NodeUnit | NodeUnit[]> = [],\n): Node[] => {\n  const result = []\n  if (Array.isArray(list)) {\n    for (let i = 0; i < list.length; i++) {\n      if (Array.isArray(list[i])) result.push(...(list[i] as any))\n      else result.push(list[i])\n    }\n  } else {\n    result.push(list)\n  }\n  return result.map(getGraph)\n}\nexport const addToReg = (\n  {hasRef, type, data}: any,\n  reg: Record<string, StateRef>,\n) => {\n  let store\n  if (hasRef) {\n    store = data.store\n    reg[store.id] = store\n  }\n  if (type === 'mov' && data.to === STORE) {\n    store = data.target\n    reg[store.id] = store\n  }\n}\nexport function createNode({\n  node = [],\n  from,\n  source,\n  parent = from || source,\n  to,\n  target,\n  child = to || target,\n  scope = {},\n  meta = {},\n  family: familyRaw = {type: 'regular'},\n  regional,\n}: {\n  node?: Array<Cmd | false | void | null>\n  from?: NodeUnit | NodeUnit[]\n  source?: NodeUnit | NodeUnit[]\n  parent?: NodeUnit | NodeUnit[]\n  to?: NodeUnit | NodeUnit[]\n  target?: NodeUnit | NodeUnit[]\n  child?: NodeUnit | NodeUnit[]\n  scope?: {[name: string]: any}\n  meta?: {[name: string]: any}\n  family?: {\n    type?: 'regular' | 'crosslink' | 'domain'\n    links?: NodeUnit | NodeUnit[]\n    owners?: NodeUnit | Array<NodeUnit | NodeUnit[]>\n  }\n  regional?: boolean\n} = {}): Node {\n  const sources = arrifyNodes(parent)\n  const links = arrifyNodes(familyRaw.links)\n  const owners = arrifyNodes(familyRaw.owners)\n  const seq: Cmd[] = []\n  const reg: {[id: string]: StateRef} = {}\n  for (let i = 0; i < node.length; i++) {\n    const item = node[i]\n    if (!item) continue\n    seq.push(item)\n    addToReg(item, reg)\n  }\n  const result: Node = {\n    id: nextNodeID(),\n    seq,\n    next: arrifyNodes(child),\n    meta,\n    scope,\n    family: {\n      type: familyRaw.type || CROSSLINK,\n      links,\n      owners,\n    },\n    reg,\n  }\n  for (let i = 0; i < links.length; i++) {\n    getOwners(links[i]).push(result)\n  }\n  for (let i = 0; i < owners.length; i++) {\n    getLinks(owners[i]).push(result)\n  }\n  for (let i = 0; i < sources.length; i++) {\n    sources[i].next.push(result)\n  }\n  if (regional && regionStack) {\n    own(getValue(regionStack), [result])\n  }\n  return result\n}\n","export const STORE = 'store'\nexport const EVENT = 'event'\nexport const EFFECT = 'effect'\nexport const DOMAIN = 'domain'\nexport const SAMPLER = 'sampler'\nexport const CROSSLINK = 'crosslink'\nexport const MAP = 'map'\nexport const STACK = 'stack'\nexport const BARRIER = 'barrier'\nexport const VALUE = 'value'\nexport const FORK_COUNTER = 'forkInFlightCounter'\nexport const SAMPLE = 'sample'\nexport const FILTER = 'filter'\nexport const REG_A = 'a'\n","import {Node, NodeUnit} from './index.h'\nimport {readRef} from './stateRef'\nimport {getForkPage, getGraph, getParent, getValue} from './getter'\nimport {\n  STORE,\n  EFFECT,\n  SAMPLER,\n  STACK,\n  BARRIER,\n  VALUE,\n  FILTER,\n  REG_A,\n} from './tag'\n\n/** Names of priority groups */\ntype PriorityTag = 'child' | 'pure' | 'barrier' | 'sampler' | 'effect'\n\n/**\n * Position in the current branch,\n * including call stack, priority type\n * and index of next step in the executed Node\n */\ntype Layer = {\n  idx: number\n  stack: Stack\n  type: PriorityTag\n  id: number\n}\n\n/** Call stack */\ntype Stack = {\n  value: any\n  a: any\n  b: any\n  parent: Stack | null\n  node: Node\n  page: {[id: string]: any} | null\n  forkPage?: any\n}\n\n/** Queue as linked list or skew heap */\ntype QueueItem = {\n  /** node value */\n  v: Layer\n  /** left node. always null in queue but used in skew heap */\n  l: QueueItem | null\n  /** right node */\n  r: QueueItem | null\n}\ntype QueueBucket = {\n  first: QueueItem | null\n  last: QueueItem | null\n  size: number\n}\n\n/** Dedicated local metadata */\ntype Local = {\n  fail: boolean\n  scope: {[key: string]: any}\n}\n\nlet heap: QueueItem | null = null\n\nconst merge = (a: QueueItem | null, b: QueueItem | null): QueueItem | null => {\n  if (!a) return b\n  if (!b) return a\n\n  let ret\n  const isSameType = a.v.type === b.v.type\n  if (\n    /**\n     * if both nodes has the same PriorityType\n     * and first node is created after second one\n     */\n    (isSameType && a.v.id > b.v.id) ||\n    /** if first node is \"sampler\" and second node is \"barrier\" */\n    (!isSameType && a.v.type === SAMPLER)\n  ) {\n    ret = a\n    a = b\n    b = ret\n  }\n  ret = merge(a.r, b)\n  a.r = a.l\n  a.l = ret\n\n  return a\n}\n\n/** queue buckets for each PriorityType */\nconst queue: QueueBucket[] = []\nlet ix = 0\nwhile (ix < 5) {\n  /**\n   * although \"sampler\" and \"barrier\" are using heap instead of linked list,\n   * their buckets are still useful: they maintains size of heap queue\n   */\n  queue.push({first: null, last: null, size: 0})\n  ix += 1\n}\n\nconst deleteMin = () => {\n  for (let i = 0; i < 5; i++) {\n    const list = queue[i]\n    if (list.size > 0) {\n      /**\n       * second bucket is for \"barrier\" PriorityType (used in combine)\n       * and third bucket is for \"sampler\" PriorityType (used in sample and guard)\n       */\n      if (i === 2 || i === 3) {\n        list.size -= 1\n        const value = heap!.v\n        heap = merge(heap!.l, heap!.r)\n        return value\n      }\n      if (list.size === 1) {\n        list.last = null\n      }\n      const item = list.first\n      list.first = item!.r\n      list.size -= 1\n      return item!.v\n    }\n  }\n}\nconst pushFirstHeapItem = (\n  type: PriorityTag,\n  page: {[id: string]: any} | null,\n  node: Node,\n  parent: Stack | null,\n  value: any,\n  forkPage: any | void,\n) =>\n  pushHeap(\n    0,\n    {\n      a: null,\n      b: null,\n      node,\n      parent,\n      value,\n      page,\n      forkPage,\n    },\n    type,\n  )\nconst pushHeap = (idx: number, stack: Stack, type: PriorityTag, id = 0) => {\n  const priority = getPriority(type)\n  const bucket: QueueBucket = queue[priority]\n  const item: QueueItem = {\n    v: {\n      idx,\n      stack,\n      type,\n      id,\n    },\n    //@ts-ignore\n    l: 0,\n    //@ts-ignore\n    r: 0,\n  }\n  /**\n   * second bucket is for \"barrier\" PriorityType (used in combine)\n   * and third bucket is for \"sampler\" PriorityType (used in sample and guard)\n   */\n  if (priority === 2 || priority === 3) {\n    heap = merge(heap, item)\n  } else {\n    if (bucket.size === 0) {\n      bucket.first = item\n    } else {\n      bucket.last!.r = item\n    }\n    bucket.last = item\n  }\n  bucket.size += 1\n}\n\nconst getPriority = (t: PriorityTag) => {\n  switch (t) {\n    case 'child':\n      return 0\n    case 'pure':\n      return 1\n    case BARRIER:\n      return 2\n    case SAMPLER:\n      return 3\n    case EFFECT:\n      return 4\n    default:\n      return -1\n  }\n}\n\nconst barriers = new Set()\n\nlet isRoot = true\nexport let isWatch = false\nexport let currentPage: any = null\nexport let forkPage: any\nexport const setForkPage = (newForkPage: any) => {\n  forkPage = newForkPage\n}\nexport const setCurrentPage = (newPage: any) => {\n  currentPage = newPage\n}\n\nconst getPageForRef = (page: any, id: string) => {\n  if (page) {\n    while (page && !page.reg[id]) {\n      page = getParent(page)\n    }\n    if (page) return page\n  }\n  return null\n}\nconst getPageRef = (page: any, node: Node, id: string) => {\n  const pageForRef = getPageForRef(page, id)\n  return (pageForRef ? pageForRef : node).reg[id]\n}\n\nexport function launch(config: {\n  target: NodeUnit | NodeUnit[]\n  params?: any\n  defer?: boolean\n  page?: any\n  forkPage?: any\n  stack?: Stack\n}): void\nexport function launch(unit: NodeUnit, payload?: any, upsert?: boolean): void\nexport function launch(unit: any, payload?: any, upsert?: boolean) {\n  let pageForLaunch = currentPage\n  let stackForLaunch = null\n  let forkPageForLaunch = forkPage\n  if (unit.target) {\n    payload = unit.params\n    upsert = unit.defer\n    pageForLaunch = 'page' in unit ? unit.page : pageForLaunch\n    if (unit[STACK]) stackForLaunch = unit[STACK]\n    forkPageForLaunch = getForkPage(unit) || forkPageForLaunch\n    unit = unit.target\n  }\n  if (forkPageForLaunch && forkPage && forkPageForLaunch !== forkPage) {\n    forkPage = null\n  }\n  if (Array.isArray(unit)) {\n    for (let i = 0; i < unit.length; i++) {\n      pushFirstHeapItem(\n        'pure',\n        pageForLaunch,\n        getGraph(unit[i]),\n        stackForLaunch,\n        payload[i],\n        forkPageForLaunch,\n      )\n    }\n  } else {\n    pushFirstHeapItem(\n      'pure',\n      pageForLaunch,\n      getGraph(unit),\n      stackForLaunch,\n      payload,\n      forkPageForLaunch,\n    )\n  }\n  if (upsert && !isRoot) return\n  /** main execution code */\n  const lastStartedState = {isRoot, currentPage, forkPage, isWatch}\n  isRoot = false\n  let stop\n  let skip\n  let node\n  let value\n  let page\n  let reg\n  kernelLoop: while ((value = deleteMin())) {\n    const {idx, stack, type} = value\n    node = stack.node\n    currentPage = page = stack.page\n    forkPage = getForkPage(stack)\n    reg = (page ? page : node).reg\n    const local: Local = {\n      fail: false,\n      scope: node.scope,\n    }\n    stop = skip = false\n    for (let stepn = idx; stepn < node.seq.length && !stop; stepn++) {\n      const step = node.seq[stepn]\n      const data = step.data\n      switch (step.type) {\n        case BARRIER: {\n          let id = data.barrierID\n          if (page) {\n            id = `${page.fullID}_${id}`\n          }\n          const priority = data.priority\n          if (stepn !== idx || type !== priority) {\n            if (!barriers.has(id)) {\n              barriers.add(id)\n              pushHeap(stepn, stack, priority, id)\n            }\n            continue kernelLoop\n          }\n          barriers.delete(id)\n          break\n        }\n        case 'mov': {\n          let value\n          //prettier-ignore\n          switch (data.from) {\n            case STACK: value = getValue(stack); break\n            case REG_A: /** fall-through case */\n            case 'b':\n              value = stack[data.from]\n              break\n            case VALUE: value = data.store; break\n            case STORE:\n              if (!reg[data.store.id]) {\n                // if (!page.parent) {\n                stack.page = page = getPageForRef(page, data.store.id)\n                reg = page ? page.reg : node.reg\n                // }\n              }\n              // value = getPageRef(page, node, data.store.id).current\n              value = readRef(reg[data.store.id])\n              break\n          }\n          //prettier-ignore\n          switch (data.to) {\n            case STACK: stack.value = value; break\n            case REG_A: /** fall-through case */\n            case 'b':\n              stack[data.to] = value\n              break\n            case STORE:\n              getPageRef(page, node, data.target.id).current = value\n              break\n          }\n          break\n        }\n        case 'check':\n          switch (data.type) {\n            case 'defined':\n              skip = getValue(stack) === undefined\n              break\n            case 'changed':\n              skip =\n                getValue(stack) ===\n                readRef(getPageRef(page, node, data.store.id))\n              break\n          }\n          break\n        case FILTER:\n          /**\n           * handled edge case: if step.fn will throw,\n           * tryRun will return null\n           * thereby forcing that branch to stop\n           */\n          skip = !tryRun(local, data, stack)\n          break\n        case 'run':\n          /** exec 'compute' step when stepn === idx */\n          if (stepn !== idx || type !== EFFECT) {\n            pushHeap(stepn, stack, EFFECT)\n            continue kernelLoop\n          }\n        case 'compute':\n          isWatch = node.meta.op === 'watch'\n          stack.value = tryRun(local, data, stack)\n          isWatch = lastStartedState.isWatch\n          break\n      }\n      stop = local.fail || skip\n    }\n    if (!stop) {\n      for (let stepn = 0; stepn < node.next.length; stepn++) {\n        pushFirstHeapItem(\n          'child',\n          page,\n          node.next[stepn],\n          stack,\n          getValue(stack),\n          getForkPage(stack),\n        )\n      }\n    }\n  }\n  isRoot = lastStartedState.isRoot\n  currentPage = lastStartedState.currentPage\n  forkPage = getForkPage(lastStartedState)\n}\n\n/** try catch for external functions */\nconst tryRun = (local: Local, {fn}: any, stack: Stack) => {\n  try {\n    return fn(getValue(stack), local.scope, stack)\n  } catch (err) {\n    console.error(err)\n    local.fail = true\n  }\n}\n","import {Store, Domain} from './unit.h'\nimport {is} from './is'\nimport {getParent} from './getter'\n\nexport const joinName = (unit: any, tag: string) => '' + unit.shortName + tag\n\nexport const mapName = (unit: any, name?: string) =>\n  name == null ? joinName(unit, ' → *') : name\n\nexport function unitObjectName(objOrArr: any, method: string = 'combine') {\n  let name = method + '('\n  let comma = ''\n  let i = 0\n  //@ts-ignore\n  for (const key in objOrArr) {\n    //@ts-ignore\n    const unit = objOrArr[key]\n    if (unit != null) {\n      name += comma\n      //@ts-ignore\n      name += is.unit(unit) ? unit.compositeName.fullName : unit.toString()\n    }\n    i += 1\n    /* inlined max object names constant */\n    if (i === 25) break\n    comma = ', '\n  }\n  name += ')'\n  return name\n}\n\nexport function setStoreName<State>(store: Store<State>, rawName: string) {\n  const compositeName = createName(rawName, getParent(store))\n  store.shortName = rawName\n  if (!store.compositeName) {\n    store.compositeName = compositeName\n    return\n  }\n  const currentComposite = store.compositeName\n  currentComposite.path = compositeName.path\n  currentComposite.shortName = compositeName.shortName\n  currentComposite.fullName = compositeName.fullName\n}\n\nexport type CompositeName = {\n  shortName: string\n  fullName: string\n  path: string[]\n}\n\nexport function createName(name: string, parent?: Domain): CompositeName {\n  let path: string[]\n  let fullName\n  let composite\n  const shortName = name\n  if (!parent) {\n    if (name.length === 0) {\n      path = []\n    } else {\n      path = [name]\n    }\n    fullName = name\n  } else {\n    composite = parent.compositeName\n    if (name.length === 0) {\n      path = composite.path\n      fullName = composite.fullName\n    } else {\n      path = composite.path.concat([name])\n      if (composite.fullName.length === 0) {\n        fullName = name\n      } else {\n        fullName = '' + composite.fullName + '/' + name\n      }\n    }\n  }\n  return {shortName, fullName, path}\n}\n","export function forIn<T>(\n  obj: Record<string, T>,\n  cb: (value: T, key: string) => void,\n) {\n  for (const key in obj) {\n    cb(obj[key], key)\n  }\n}\n\nexport const includes = (list: any[], item: any) => list.includes(item)\n\nexport const removeItem = (list: any[], item: any) => {\n  const pos = list.indexOf(item)\n  if (pos !== -1) {\n    list.splice(pos, 1)\n  }\n}\n\nexport function forEach<T>(\n  list: T[],\n  fn: (item: T, index: number, list: T[]) => void,\n): void\nexport function forEach<T>(list: Set<T>, fn: (item: T) => void): void\nexport function forEach(list: any, fn: Function) {\n  list.forEach(fn)\n}\n","import {observableSymbol} from './observable'\n\nimport {is, isObject, isFunction, assertObject, assertNodeSet} from './is'\nimport {Store, Event} from './unit.h'\n\nimport {step} from './typedef'\nimport {createStateRef, readRef} from './stateRef'\nimport {nextUnitID} from './id'\nimport {callStackAReg, callARegStack, callStack} from './caller'\nimport {bind} from './bind'\nimport {own} from './own'\nimport {createNode} from './createNode'\nimport {launch, currentPage, forkPage, setCurrentPage} from './kernel'\n\nimport {Subscriber, Config} from './index.h'\nimport {createName, mapName, joinName} from './naming'\nimport {createLinkNode} from './forward'\nimport {watchUnit} from './watch'\nimport {createSubscription} from './subscription'\nimport {readTemplate, readSidRoot} from './region'\nimport {\n  getSubscribers,\n  getConfig,\n  getNestedConfig,\n  getStoreState,\n  getGraph,\n  getParent,\n} from './getter'\nimport {includes} from './collection'\nimport {throwError} from './throw'\nimport {DOMAIN, STORE, EVENT, MAP, FILTER, REG_A} from './tag'\n\nconst normalizeConfig = (part: any, config: any) => {\n  if (isObject(part)) {\n    normalizeConfig(getConfig(part), config)\n    if (part.name != null) {\n      if (isObject(part.name)) normalizeConfig(part.name, config)\n      else if (isFunction(part.name)) config.handler = part.name\n      else config.name = part.name\n    }\n    if (part.loc) config.loc = part.loc\n    if (part.sid || part.sid === null) config.sid = part.sid\n    if (part.handler) config.handler = part.handler\n    if (part.updateFilter) config.updateFilter = part.updateFilter\n    if (getParent(part)) config.parent = getParent(part)\n    if ('strict' in part) config.strict = part.strict\n    if (part.named) config.named = part.named\n    normalizeConfig(getNestedConfig(part), config)\n  }\n  return config\n}\n\nexport const applyParentHook = (\n  source: any,\n  target: any,\n  hookType: 'event' | 'effect' = EVENT,\n) => {\n  if (getParent(source)) getParent(source).hooks[hookType](target)\n}\n\nlet isStrict: boolean\nexport const initUnit = (\n  kind: any,\n  unit: any,\n  rawConfigA: any,\n  rawConfigB?: any,\n) => {\n  const config = normalizeConfig(\n    {\n      name: rawConfigB,\n      config: rawConfigA,\n    },\n    {},\n  )\n  const isDomain = kind === DOMAIN\n  const id = nextUnitID()\n  let {parent = null, sid = null, strict = true, named = null} = config\n  const name = named ? named : config.name || (isDomain ? '' : id)\n  const compositeName = createName(name, parent)\n\n  const meta: Record<string, any> = {\n    unit: unit.kind = kind,\n    name: unit.shortName = name,\n    sid: unit.sid = readSidRoot(sid),\n    named,\n    unitId: unit.id = id,\n  }\n  unit.parent = parent\n  unit.compositeName = compositeName\n  unit.defaultConfig = config\n  unit.thru = (fn: Function) => fn(unit)\n  unit.getType = () => compositeName.fullName\n  if (!isDomain) {\n    unit.subscribe = (observer: Subscriber<any>) => {\n      assertObject(observer)\n      return unit.watch(\n        isFunction(observer)\n          ? observer\n          : (upd: any) => {\n              if (observer.next) {\n                observer.next(upd)\n              }\n            },\n      )\n    }\n    unit[observableSymbol] = () => unit\n    const template = readTemplate()\n    if (template) meta.nativeTemplate = template\n  }\n  isStrict = strict\n  return meta\n}\nexport const createNamedEvent = (named: string) => createEvent({named})\n\nconst createComputation = (from: any, to: any, op: any, fn: Function) =>\n  createLinkNode(from, to, {\n    scope: {fn},\n    node: [step.compute({fn: callStack})],\n    meta: {op},\n  })\n\nconst createEventFiltration = (event: any, op: string, fn: any, node: any) => {\n  let config\n  if (isObject(fn)) {\n    config = fn\n    fn = fn.fn\n  }\n  const mapped = createEvent(joinName(event, ' →? *'), config)\n  createLinkNode(event, mapped, {\n    scope: {fn},\n    node,\n    meta: {op},\n  })\n  return mapped\n}\n\nfunction callCreate(unit: any, template: any, payload: any, args: any[]): any {\n  const oldPage = currentPage\n  let page = null\n  if (template) {\n    page = currentPage\n    while (page && page.template !== template) {\n      page = getParent(page)\n    }\n  }\n  setCurrentPage(page)\n  const result = unit.create(payload, args)\n  setCurrentPage(oldPage)\n  return result\n}\n\nexport function createEvent<Payload = any>(\n  nameOrConfig?: any,\n  maybeConfig?: any,\n): Event<Payload> {\n  const event: any = (payload: Payload, ...args: any[]) => {\n    if (currentPage) {\n      return callCreate(event, template, payload, args)\n    }\n    return event.create(payload, args)\n  }\n  event.graphite = createNode({\n    meta: initUnit(EVENT, event, maybeConfig, nameOrConfig),\n    regional: true,\n  })\n  //eslint-disable-next-line no-unused-vars\n  event.create = (params: any, _: any) => {\n    const target = forkPage ? forkPage.find(event) : event\n    launch(target, params)\n    return params\n  }\n  event.watch = bind(watchUnit, event)\n  event.map = (fn: any) => {\n    let config\n    let name\n    if (isObject(fn)) {\n      config = fn\n      name = fn.name\n      fn = fn.fn\n    }\n    const mapped = createEvent(mapName(event, name), config)\n    createComputation(event, mapped, MAP, fn)\n    return mapped\n  }\n  event.filter = (fn: any) =>\n    createEventFiltration(event, FILTER, fn.fn ? fn : fn.fn, [\n      step.filter({fn: callStack}),\n    ])\n  event.filterMap = (fn: any) =>\n    createEventFiltration(event, 'filterMap', fn, [\n      step.compute({fn: callStack}),\n      step.check.defined(),\n    ])\n  event.prepend = (fn: any) => {\n    const contramapped: Event<any> = createEvent('* → ' + event.shortName, {\n      parent: getParent(event),\n    })\n    const template = readTemplate()\n    if (template) {\n      getGraph(contramapped).seq.push(template.upward)\n    }\n    createComputation(contramapped, event, 'prepend', fn)\n    applyParentHook(event, contramapped)\n    return contramapped\n  }\n  const template = readTemplate()\n  return event\n}\n\nexport function createStore<State>(\n  defaultState: State,\n  props?: Config,\n): Store<State> {\n  const plainState = createStateRef(defaultState)\n  const oldState = createStateRef(defaultState)\n  const updates = createNamedEvent('updates')\n  const template = readTemplate()\n  plainState.after = [{type: 'copy', to: oldState}]\n  if (template) {\n    template.plain.push(plainState, oldState)\n  }\n  const plainStateId = plainState.id\n  const store: any = {\n    subscribers: new Map(),\n    updates,\n    defaultState,\n    stateRef: plainState,\n    getState() {\n      let targetRef = plainState\n      let reachedPage\n      if (currentPage) {\n        let page = currentPage\n        while (page && !page.reg[plainStateId]) {\n          page = getParent(page)\n        }\n        if (page) reachedPage = page\n      }\n      if (!reachedPage && forkPage && forkPage.reg[plainStateId]) {\n        reachedPage = forkPage\n      }\n      if (reachedPage) targetRef = reachedPage.reg[plainStateId]\n      return readRef(targetRef)\n    },\n    setState(state: any) {\n      let target\n      if (forkPage) {\n        target = forkPage.nodeMap[getGraph(store).id]\n      }\n      if (!target) target = store\n      launch({\n        target,\n        params: state,\n        defer: true,\n      })\n    },\n    reset(...units: any[]) {\n      for (const unit of units) store.on(unit, () => store.defaultState)\n      return store\n    },\n    on(nodeSet: any, fn: Function) {\n      assertNodeSet(nodeSet, '.on', 'first argument')\n      if (Array.isArray(nodeSet)) {\n        for (const event of nodeSet) {\n          onEvent(event, fn)\n        }\n      } else {\n        onEvent(nodeSet, fn)\n      }\n      return store\n    },\n    off(unit: any) {\n      const currentSubscription = getSubscribers(store).get(unit)\n      if (currentSubscription) {\n        currentSubscription()\n        getSubscribers(store).delete(unit)\n      }\n      return store\n    },\n    map(fn: any, firstState?: any) {\n      let config\n      let name\n      if (isObject(fn)) {\n        config = fn\n        name = fn.name\n        firstState = fn.firstState\n        fn = fn.fn\n      }\n      let lastResult\n      const storeState = store.getState()\n      const template = readTemplate()\n      if (template) {\n        lastResult = null\n      } else if (storeState !== undefined) {\n        lastResult = fn(storeState, firstState)\n      }\n\n      const innerStore: Store<any> = createStore(lastResult, {\n        name: mapName(store, name),\n        config,\n        strict: false,\n      })\n      const linkNode = updateStore(store, innerStore, MAP, false, fn)\n\n      getStoreState(innerStore).before = [\n        {\n          type: MAP,\n          fn,\n          from: plainState,\n        },\n      ]\n      if (template) {\n        if (!includes(template.plain, plainState)) {\n          if (!includes(linkNode.seq, template.loader)) {\n            linkNode.seq.unshift(template.loader)\n          }\n        }\n      }\n      return innerStore\n    },\n    watch(eventOrFn: any, fn?: Function) {\n      if (!fn || !is.unit(eventOrFn)) {\n        const subscription = watchUnit(store, eventOrFn)\n        const template = readTemplate()\n        if (template) {\n          template.watch.push({\n            of: plainState,\n            fn: eventOrFn,\n          })\n        } else {\n          eventOrFn(store.getState())\n        }\n        return subscription\n      }\n      if (!isFunction(fn)) throwError('second argument should be a function')\n      return eventOrFn.watch((payload: any) => fn(store.getState(), payload))\n    },\n  }\n  function onEvent(event: any, fn: Function) {\n    store.off(event)\n    getSubscribers(store).set(\n      event,\n      createSubscription(\n        updateStore(event, store, 'on', true, fn, updateFilter),\n      ),\n    )\n  }\n  const meta = initUnit(STORE, store, props)\n  const updateFilter = store.defaultConfig.updateFilter\n  store.graphite = createNode({\n    scope: {state: plainState},\n    node: [\n      step.check.defined(),\n      step.check.changed({\n        store: oldState,\n      }),\n      updateFilter && step.mov({store: oldState, to: REG_A}),\n      updateFilter &&\n        step.filter({\n          fn: (update, _, {a}) => updateFilter(update, a),\n        }),\n      step.update({\n        store: plainState,\n      }),\n      step.update({\n        store: oldState,\n      }),\n    ],\n    child: updates,\n    meta,\n    regional: true,\n  })\n  if (isStrict && defaultState === undefined)\n    throwError(\"current state can't be undefined, use null instead\")\n  own(store, [updates])\n  return store\n}\n\nconst updateStore = (\n  from: any,\n  store: Store<any>,\n  op: string,\n  stateFirst: boolean,\n  fn: Function,\n  updateFilter?: Function,\n) => {\n  const storeRef = getStoreState(store)\n  const node = [\n    step.mov({store: storeRef, to: REG_A}),\n    step.compute({\n      fn: stateFirst ? callARegStack : callStackAReg,\n    }),\n    step.check.defined(),\n    step.check.changed({store: storeRef}),\n    updateFilter &&\n      step.filter({\n        fn: (update, _, {a}) => updateFilter(update, a),\n      }),\n    step.update({store: storeRef}),\n  ]\n  const template = readTemplate()\n  if (template) {\n    node.unshift(template.loader)\n    node.push(template.upward)\n    if (is.store(from)) {\n      const ref = getStoreState(from)\n      if (!includes(template.plain, ref)) {\n        //if (!includes(node, template.loader)) {\n        //  node.unshift(template.loader)\n        //}\n        if (!includes(template.closure, ref)) {\n          template.closure.push(ref)\n        }\n        if (!storeRef.before) storeRef.before = []\n        storeRef.before.push({\n          type: 'closure',\n          of: ref,\n        })\n      }\n    } else {\n      //if (!includes(node, template.loader)) {\n      //  node.unshift(template.loader)\n      //}\n    }\n  }\n  return createLinkNode(from, store, {\n    scope: {fn},\n    node,\n    meta: {op},\n  })\n}\n","import {Store} from './unit.h'\nimport {createStore} from './createUnit'\nimport {createStateRef} from './stateRef'\nimport {step} from './typedef'\nimport {onConfigNesting} from './config'\nimport {getGraph, getStoreState} from './getter'\nimport {is, isFunction, isObject} from './is'\nimport {unitObjectName} from './naming'\nimport {createLinkNode} from './forward'\nimport {throwError} from './throw'\nimport {readTemplate} from './region'\nimport {forIn, includes} from './collection'\nimport {BARRIER, MAP, REG_A, VALUE} from './tag'\n\nexport function combine(...args: any[]): Store<any> {\n  let handler\n  let stores\n  let config\n  onConfigNesting(args[0], (injectedData, userConfig) => {\n    config = injectedData\n    args = userConfig\n  })\n  const rawHandler = args[args.length - 1]\n  if (isFunction(rawHandler)) {\n    stores = args.slice(0, -1)\n    handler = rawHandler\n  } else {\n    stores = args\n  }\n\n  let structStoreShape\n  let shapeReady\n  if (stores.length === 1) {\n    const obj = stores[0]\n    /*\n      without edge case combine(Color, (Color) => '~')\n      */\n    if (!is.store(obj)) {\n      /*\n      case combine([R,G,B], ([R,G,B]) => '~')\n      case combine({R,G,B}, ({R,G,B}) => '~')\n\n      edge case combine([Color], ([Color]) => '~')\n      edge case combine({Color}, ({Color}) => '~')\n\n      edge case combine([R,G,B])\n      edge case combine({R,G,B})\n\n      edge case combine([Color])\n      edge case combine({Color})\n      */\n      structStoreShape = obj\n      shapeReady = true\n    }\n  }\n  if (!shapeReady) {\n    /*\n    case combine(R,G,B, (R,G,B) => '~')\n    */\n    structStoreShape = stores\n    /*\n    without edge case combine(R,G,B)\n    without edge case combine(Color)\n    */\n    if (handler) {\n      handler = spreadArgs(handler)\n    }\n  }\n  if (!isObject(structStoreShape)) throwError('shape should be an object')\n  return storeCombination(\n    Array.isArray(structStoreShape),\n    structStoreShape,\n    config,\n    handler,\n  )\n}\n\nconst spreadArgs = (fn: Function) => (list: any[]) => fn(...list)\n\nconst storeCombination = (\n  isArray: boolean,\n  obj: any,\n  config?: string,\n  fn?: (upd: any) => any,\n) => {\n  const clone = isArray ? (list: any) => list.slice() : (obj: any) => ({...obj})\n  const defaultState: any = isArray ? [] : {}\n  const template = readTemplate()\n  const stateNew = clone(defaultState)\n  const rawShape = createStateRef(stateNew)\n  const isFresh = createStateRef(true)\n  rawShape.type = isArray ? 'list' : 'shape'\n  if (template) {\n    template.plain.push(rawShape, isFresh)\n  }\n  const store = createStore(stateNew, {\n    name: config ? config : unitObjectName(obj),\n  })\n  getGraph(store).meta.isCombine = true\n  const node = [\n    step.check.defined(),\n    step.mov({\n      store: rawShape,\n      to: REG_A,\n    }),\n    //prettier-ignore\n    step.filter({\n      fn: (upd, {key}, {a}) => upd !== a[key],\n    }),\n    step.mov({\n      store: isFresh,\n      to: 'b',\n    }),\n    step.compute({\n      fn(upd, {clone, key}, reg) {\n        if (reg.b) {\n          reg.a = clone(reg.a)\n        }\n        reg.a[key] = upd\n      },\n    }),\n    step.mov({\n      from: REG_A,\n      target: rawShape,\n    }),\n    step.mov({\n      from: VALUE,\n      store: false,\n      target: isFresh,\n    }),\n    step.barrier({priority: BARRIER}),\n    step.mov({\n      from: VALUE,\n      store: true,\n      target: isFresh,\n    }),\n    step.mov({store: rawShape}),\n    fn && step.compute({fn}),\n    step.check.changed({\n      store: getStoreState(store),\n    }),\n  ]\n  const before: any[] = (rawShape.before = [])\n  forIn(obj, (child: Store<any> | any, key) => {\n    if (!is.store(child)) {\n      stateNew[key] = defaultState[key] = child\n      return\n    }\n    defaultState[key] = child.defaultState\n    stateNew[key] = child.getState()\n    const linkNode = createLinkNode(child, store, {\n      scope: {key, clone},\n      node,\n      meta: {op: 'combine'},\n    })\n    const childRef = getStoreState(child)\n    before.push({\n      type: 'field',\n      field: key,\n      from: childRef,\n    })\n    if (template) {\n      if (!includes(template.plain, childRef)) {\n        linkNode.seq.unshift(template.loader)\n      }\n    }\n  })\n\n  store.defaultShape = obj\n  rawShape.after = [\n    fn\n      ? {\n          type: MAP,\n          to: getStoreState(store),\n          fn,\n        }\n      : {\n          type: 'copy',\n          to: getStoreState(store),\n        },\n  ]\n  if (!template) {\n    store.defaultState = fn\n      ? (getStoreState(store).current = fn(stateNew))\n      : defaultState\n  }\n  return store\n}\n","export function createDefer(): {\n  rs: (value: any) => any\n  rj: (value: any) => any\n  req: Promise<any>\n} {\n  const result = {} as {\n    rs: (value: any) => any\n    rj: (value: any) => any\n    req: Promise<any>\n  }\n  result.req = new Promise((rs, rj) => {\n    result.rs = rs\n    result.rj = rj\n  })\n  result.req.catch(err => {})\n  return result\n}\n","import {step} from './typedef'\nimport {getForkPage, getGraph, getParent} from './getter'\nimport {own} from './own'\nimport {createNode} from './createNode'\nimport {launch, setForkPage, forkPage, isWatch} from './kernel'\nimport {createNamedEvent, createStore, createEvent} from './createUnit'\nimport {createDefer} from './defer'\nimport {isObject, isFunction} from './is'\nimport {throwError} from './throw'\nimport {EFFECT} from './tag'\n\nexport function createEffect<Payload, Done>(\n  nameOrConfig: any,\n  maybeConfig: any,\n) {\n  const instance: any = createEvent(nameOrConfig, maybeConfig)\n  let handler =\n    instance.defaultConfig.handler ||\n    (() => throwError(`no handler used in ${instance.getType()}`))\n  const node = getGraph(instance)\n  node.meta.onCopy = ['runner']\n  node.meta.unit = instance.kind = EFFECT\n  instance.use = (fn: Function) => {\n    if (!isFunction(fn)) throwError('.use argument should be a function')\n    handler = fn\n    return instance\n  }\n  const anyway = (instance.finally = createNamedEvent('finally'))\n  const done = (instance.done = (anyway as any).filterMap({\n    named: 'done',\n    fn({status, params, result}: any) {\n      if (status === 'done') return {params, result}\n    },\n  }))\n  const fail = (instance.fail = (anyway as any).filterMap({\n    named: 'fail',\n    fn({status, params, error}: any) {\n      if (status === 'fail') return {params, error}\n    },\n  }))\n  const doneData = (instance.doneData = done.map({\n    named: 'doneData',\n    fn: ({result}: any) => result,\n  }))\n  const failData = (instance.failData = fail.map({\n    named: 'failData',\n    fn: ({error}: any) => error,\n  }))\n\n  const effectRunner = createNode({\n    scope: {\n      getHandler: instance.use.getCurrent = () => handler,\n      finally: anyway,\n    },\n    node: [\n      step.run({\n        fn({params, req}, {finally: anyway, getHandler}, stack) {\n          const onResolve = onSettled({\n            params,\n            req,\n            ok: true,\n            anyway,\n            stack,\n          })\n          const onReject = onSettled({\n            params,\n            req,\n            ok: false,\n            anyway,\n            stack,\n          })\n          let result\n          try {\n            result = getHandler()(params)\n          } catch (err) {\n            return void onReject(err)\n          }\n          if (isObject(result) && isFunction(result.then)) {\n            result.then(onResolve, onReject)\n          } else {\n            onResolve(result)\n          }\n        },\n      }),\n    ],\n    meta: {\n      op: 'fx',\n      fx: 'runner',\n      onCopy: ['finally'],\n    },\n  })\n  node.scope.runner = effectRunner\n  node.seq.push(\n    step.compute({\n      fn(params, scope, stack) {\n        // empty stack means that this node was launched directly\n        if (!getParent(stack)) return params\n        return {\n          params,\n          req: {\n            rs(data: any) {},\n            rj(data: any) {},\n          },\n        }\n      },\n    }),\n    step.run({\n      fn(upd, {runner}, stack) {\n        launch({\n          target: runner,\n          params: upd,\n          defer: true,\n          forkPage: getForkPage(stack),\n        })\n        return upd.params\n      },\n    }),\n  )\n  instance.create = (params: Payload) => {\n    const req = createDefer()\n    const payload = {params, req}\n    if (forkPage) {\n      if (!isWatch) {\n        const savedFork = forkPage\n        req.req\n          .finally(() => {\n            setForkPage(savedFork)\n          })\n          .catch(() => {})\n      }\n      launch(forkPage.find(instance), payload)\n    } else {\n      launch(instance, payload)\n    }\n    return req.req\n  }\n\n  const inFlight = (instance.inFlight = createStore(0, {named: 'inFlight'})\n    .on(instance, x => x + 1)\n    .on(anyway, x => x - 1))\n\n  const pending = (instance.pending = inFlight.map({\n    //@ts-ignore\n    fn: amount => amount > 0,\n    named: 'pending',\n  }))\n\n  own(instance, [\n    anyway,\n    done,\n    fail,\n    doneData,\n    failData,\n    pending,\n    inFlight,\n    effectRunner,\n  ])\n  return instance\n}\n\nexport const onSettled = ({\n  params,\n  req,\n  ok,\n  anyway,\n  stack,\n}: {\n  params: any\n  req: {\n    rs(_: any): any\n    rj(_: any): any\n  }\n  ok: boolean\n  anyway: any\n  stack: any\n}) => (data: any) =>\n  launch({\n    target: [anyway, sidechain],\n    params: [\n      ok\n        ? {\n            status: 'done',\n            params,\n            result: data,\n          }\n        : {\n            status: 'fail',\n            params,\n            error: data,\n          },\n      {\n        fn: ok ? req.rs : req.rj,\n        value: data,\n      },\n    ],\n    defer: true,\n    page: stack.page,\n    forkPage: getForkPage(stack),\n  })\n\nexport const sidechain = createNode({\n  node: [\n    step.run({\n      fn({fn, value}) {\n        fn(value)\n      },\n    }),\n  ],\n  meta: {op: 'fx', fx: 'sidechain'},\n})\n","import {combine} from './combine'\nimport {createEffect, onSettled} from './createEffect'\nimport {applyParentHook} from './createUnit'\nimport {onConfigNesting} from './config'\nimport {getGraph, getStoreState} from './getter'\nimport {own} from './own'\nimport {is} from './is'\nimport {step} from './typedef'\nimport {launch} from './kernel'\nimport {addToReg} from './createNode'\nimport {STORE, EFFECT, REG_A} from './tag'\n\nexport function attach(config: any) {\n  let injected\n  onConfigNesting(config, (injectedData, userConfig) => {\n    injected = injectedData\n    config = userConfig\n  })\n  let {source, effect, mapParams} = config\n  if (!mapParams)\n    mapParams = source\n      ? (_: any, source: any) => source\n      : (params: any) => params\n  const attached = createEffect(config, injected)\n  const {runner} = getGraph(attached).scope\n\n  let runnerSteps\n  const runnerFn = (\n    {params, req}: any,\n    {finally: anyway, effect}: any,\n    stack: any,\n  ) => {\n    const rj = onSettled({\n      params,\n      req,\n      ok: false,\n      anyway,\n      stack,\n    })\n    let computedParams\n    try {\n      computedParams = mapParams(params, stack.a)\n    } catch (err) {\n      return rj(err)\n    }\n    launch({\n      target: effect,\n      params: {\n        params: computedParams,\n        req: {\n          rs: onSettled({\n            params,\n            req,\n            ok: true,\n            anyway,\n            stack,\n          }),\n          rj,\n        },\n      },\n      page: stack.page,\n      defer: true,\n    })\n  }\n  if (source) {\n    let state\n    if (is.store(source)) {\n      state = source\n      own(source, [attached])\n    } else {\n      state = combine(source)\n      own(attached, [state])\n    }\n    const readStateRef = step.mov({\n      from: STORE,\n      store: getStoreState(state),\n      to: REG_A,\n    })\n    runnerSteps = [\n      /* let another side-effects run first */\n      step.run({fn: _ => _}),\n      /* read state. assumed it already stable here because of previous step */\n      readStateRef,\n      /* no need for step.run because of first step */\n      step.compute({fn: runnerFn}),\n    ]\n    addToReg(readStateRef, runner.reg)\n  } else {\n    runnerSteps = [step.run({fn: runnerFn})]\n  }\n  own(effect, [attached])\n  runner.scope.effect = effect\n  runner.meta.onCopy.push(EFFECT)\n  runner.seq.splice(0, 1, ...runnerSteps)\n  applyParentHook(effect, attached, EFFECT)\n  return attached\n}\n","import {Store, Event} from './unit.h'\nimport {createEvent, applyParentHook} from './createUnit'\nimport {forIn} from './collection'\nimport {getParent} from './getter'\nimport {processArgsToConfig} from './config'\n\nexport function createApi(...args: [Store<any>, {[key: string]: Function}]) {\n  let [[store, setters], metadata] = processArgsToConfig(args)\n  const result: Record<string, Event<any>> = {}\n  forIn(setters, (fn, key) => {\n    const event = (result[key] = createEvent(key, {\n      parent: getParent(store),\n      config: metadata,\n    }))\n    store.on(event, fn)\n    applyParentHook(store, event)\n  })\n  return result\n}\n","import {Store, Event, Effect, Domain} from './unit.h'\nimport {own} from './own'\nimport {createNode} from './createNode'\nimport {Config, NodeUnit} from './index.h'\nimport {\n  createEvent,\n  createStore,\n  createNamedEvent,\n  initUnit,\n} from './createUnit'\nimport {createEffect} from './createEffect'\nimport {forward} from './forward'\nimport {forIn} from './collection'\nimport {getGraph, getParent} from './getter'\nimport {DOMAIN} from './tag'\nimport {launch} from './kernel'\nimport {step} from './typedef'\n\nconst createHook = (trigger: Event<any>, acc: Set<any>, node: any) => {\n  trigger.create = res => {\n    launch(trigger, res)\n    return res\n  }\n  getGraph(trigger).seq.push(\n    step.compute({\n      fn(upd, _, stack) {\n        stack.forkPage = null\n        return upd\n      },\n    }),\n  )\n  trigger.watch(data => {\n    own(node, [data])\n    acc.add(data)\n    if (!data.ownerSet) data.ownerSet = acc\n    if (!getParent(data)) data.parent = node\n  })\n  own(node, [trigger])\n  return (hook: (data: any) => any) => {\n    acc.forEach(hook)\n    return trigger.watch(hook)\n  }\n}\n\nexport function createDomain(nameOrConfig: any, maybeConfig?: any): Domain {\n  const domains: Set<Domain> = new Set()\n  const stores: Set<Store<any>> = new Set()\n  const effects: Set<Effect<any, any, any>> = new Set()\n  const events: Set<Event<any>> = new Set()\n\n  const node = createNode({\n    family: {type: DOMAIN},\n    regional: true,\n  })\n\n  const result: any = {\n    history: {\n      domains,\n      stores,\n      effects,\n      events,\n    },\n    graphite: node,\n  }\n\n  node.meta = initUnit(DOMAIN, result, maybeConfig, nameOrConfig)\n  const [event, effect, store, domain] = [\n    'onEvent',\n    'onEffect',\n    'onStore',\n    'onDomain',\n  ].map(createNamedEvent)\n\n  result.hooks = {\n    event,\n    effect,\n    store,\n    domain,\n  }\n  result.onCreateEvent = createHook(event, events, result)\n  result.onCreateEffect = createHook(effect, effects, result)\n  result.onCreateStore = createHook(store, stores, result)\n  result.onCreateDomain = createHook(domain, domains, result)\n\n  result.createEvent = result.event = (nameOrConfig: any, config?: Config) =>\n    event(\n      createEvent(nameOrConfig, {\n        parent: result,\n        config,\n      }),\n    )\n  result.createEffect = result.effect = (nameOrConfig: any, config?: Config) =>\n    effect(\n      createEffect(nameOrConfig, {\n        parent: result,\n        config,\n      }),\n    )\n  result.createDomain = result.domain = (nameOrConfig: any, config?: Config) =>\n    createDomain({\n      name: nameOrConfig,\n      parent: result,\n      config,\n    })\n  result.createStore = result.store = (state: any, config?: Config) =>\n    store(\n      createStore(state, {\n        parent: result,\n        config,\n      }),\n    )\n  const parent = getParent(result)\n  if (parent) {\n    forIn(result.hooks, (from: NodeUnit, key) => {\n      forward({from, to: parent.hooks[key]})\n    })\n    parent.hooks.domain(result)\n  }\n  return result\n}\n","import {observableSymbol} from './observable'\nimport {Event} from './unit.h'\nimport {clearNode} from './clearNode'\nimport {createEvent} from './createUnit'\nimport {bind2} from './bind'\nimport {assertObject} from './is'\nimport {throwError} from './throw'\n\nexport function fromObservable<T>(observable: any): Event<T> {\n  assertObject(observable)\n  const observableItem =\n    observableSymbol in observable ? observable[observableSymbol]() : observable\n  if (!observableItem.subscribe)\n    throwError('expect observable to have .subscribe')\n  const event = createEvent<T>()\n  const disposer = bind2(clearNode, event, undefined)\n  observableItem.subscribe({\n    next: event,\n    error: disposer,\n    complete: disposer,\n  })\n  return event\n}\n","import {Store, Event, Effect} from './unit.h'\nimport {createEvent} from './createUnit'\nimport {forward} from './forward'\nimport {unitObjectName} from './naming'\nimport {assertNodeSet} from './is'\n\nexport function merge<T>(\n  events: Array<Event<T> | Store<T> | Effect<T, any, any>>,\n  config?: object,\n): Event<T> {\n  const result = createEvent(config || unitObjectName(events, 'merge'))\n  assertNodeSet(events, 'merge', 'first argument')\n  forward({\n    from: events,\n    to: result,\n    meta: {op: 'merge'},\n  })\n  return result\n}\n","import {combine} from './combine'\nimport {step} from './typedef'\nimport {createStateRef, readRef} from './stateRef'\nimport {callStackAReg, callARegStack} from './caller'\nimport {processArgsToConfig} from './config'\nimport {getStoreState, getGraph} from './getter'\nimport {own} from './own'\nimport {assertNodeSet, is, isObject} from './is'\nimport {createStore} from './createUnit'\nimport {createEvent} from './createUnit'\nimport {createLinkNode} from './forward'\nimport {createNode} from './createNode'\nimport {readTemplate} from './region'\nimport {throwError} from './throw'\nimport {includes, forEach} from './collection'\nimport {REG_A, SAMPLE, SAMPLER, STACK, STORE, VALUE} from './tag'\nimport {merge} from './merge'\n\nconst sampleConfigFields = ['source', 'clock', 'target']\n\nfunction validateSampleConfig(config: any) {\n  let atLeastOneFieldExists = false\n  forEach(sampleConfigFields, field => {\n    if (field in config) {\n      if (config[field] == null) {\n        throwError(`sample: ${field} should be defined`)\n      }\n      atLeastOneFieldExists = true\n    }\n  })\n  return atLeastOneFieldExists\n}\n\nexport function sample(...args: any): any {\n  let target\n  let name\n  let [[source, clock, fn], metadata] = processArgsToConfig(args)\n  let sid\n  let greedy\n  //config case\n  if (clock === undefined && isObject(source) && validateSampleConfig(source)) {\n    clock = source.clock\n    fn = source.fn\n    greedy = source.greedy\n    //optional target & name accepted only from config\n    target = source.target\n    name = source.name\n    sid = source.sid\n    source = source.source\n  }\n  let needToCombine = true\n  if (source === undefined) {\n    assertNodeSet(clock, 'sample', 'clock')\n    if (Array.isArray(clock)) {\n      clock = merge(clock)\n    }\n    source = clock\n    needToCombine = false\n  }\n  if (needToCombine && !is.unit(source)) {\n    source = combine(source)\n  }\n  if (clock === undefined) {\n    //still undefined!\n    clock = source\n  }\n  assertNodeSet(clock, 'sample', 'clock')\n  name = metadata || name || source.shortName\n  const template = readTemplate()\n  const isUpward = !!target\n  if (!target) {\n    if (is.store(source) && is.store(clock)) {\n      const initialState = fn\n        ? fn(readRef(getStoreState(source)), readRef(getStoreState(clock)))\n        : readRef(getStoreState(source))\n      target = createStore(initialState, {name, sid})\n    } else {\n      target = createEvent(name)\n      if (template) {\n        getGraph(target).seq.push(template.loader)\n      }\n    }\n  }\n  const targetTemplate =\n    isUpward && is.unit(target) && getGraph(target).meta.nativeTemplate\n  if (is.store(source)) {\n    const sourceRef = getStoreState(source)\n    own(source, [\n      createLinkNode(clock, target, {\n        scope: {fn, targetTemplate},\n        node: [\n          template && template.loader,\n          //@ts-ignore\n          !greedy && step.barrier({priority: SAMPLER}),\n          step.mov({\n            store: sourceRef,\n            to: fn ? REG_A : STACK,\n          }),\n          fn && step.compute({fn: callARegStack}),\n          template && isUpward && template.upward,\n        ],\n        meta: {op: SAMPLE, sample: STORE},\n      }),\n    ])\n    if (template) {\n      if (\n        !includes(template.plain, sourceRef) &&\n        !includes(template.closure, sourceRef)\n      ) {\n        template.closure.push(sourceRef)\n      }\n    }\n  } else {\n    const hasSource = createStateRef(false)\n    const sourceState = createStateRef()\n    const clockState = createStateRef()\n    if (template) {\n      template.plain.push(hasSource, sourceState, clockState)\n    }\n    createNode({\n      parent: source,\n      node: [\n        step.update({store: sourceState}),\n        step.mov({\n          from: VALUE,\n          store: true,\n          target: hasSource,\n        }),\n      ],\n      family: {\n        owners: [source, target, clock],\n        links: target,\n      },\n      meta: {op: SAMPLE, sample: 'source'},\n      regional: true,\n    })\n    own(source, [\n      createLinkNode(clock, target, {\n        scope: {\n          fn,\n          targetTemplate,\n        },\n        node: [\n          template && template.loader,\n          step.update({store: clockState}),\n          step.mov({store: hasSource}),\n          step.filter({fn: hasSource => hasSource}),\n          //@ts-ignore\n          !greedy && step.barrier({priority: SAMPLER}),\n          step.mov({store: sourceState}),\n          step.mov({\n            store: clockState,\n            to: REG_A,\n          }),\n          fn && step.compute({fn: callStackAReg}),\n          template && isUpward && template.upward,\n        ],\n        meta: {op: SAMPLE, sample: 'clock'},\n      }),\n    ])\n  }\n  return target\n}\n","import {processArgsToConfig} from './config'\nimport {createLinkNode} from './forward'\nimport {sample} from './sample'\nimport {createEvent} from './createUnit'\nimport {combine} from './combine'\nimport {step} from './typedef'\nimport {callStack} from './caller'\nimport {assertNodeSet, is, isFunction} from './is'\nimport {createNode} from './createNode'\nimport {throwError} from './throw'\nimport {merge} from './merge'\n\nexport function guard(...args: any[]) {\n  const meta: Record<string, any> = {op: 'guard'}\n  let rawName = 'guard'\n  let [[source, config], metadata] = processArgsToConfig(args)\n  if (metadata) {\n    meta.config = metadata\n    if (metadata.name) rawName = metadata.name\n  }\n  if (!config) {\n    config = source\n    source = config.source\n  }\n  let {filter, greedy, clock, name = rawName} = config\n  const target = config.target || createEvent(name, meta.config)\n  const filterIsUnit = is.unit(filter)\n  let needToCombine = true\n  if (source === undefined) {\n    assertNodeSet(clock, 'guard', 'clock')\n    if (Array.isArray(clock)) {\n      clock = merge(clock)\n    }\n    source = clock\n    needToCombine = false\n  }\n  if (needToCombine && !is.unit(source)) source = combine(source)\n  if (clock) {\n    assertNodeSet(clock, 'guard', 'clock')\n    source = sample({\n      source,\n      clock,\n      greedy,\n      fn: filterIsUnit ? null : (source: any, clock: any) => ({source, clock}),\n    })\n  }\n  assertNodeSet(target, 'guard', 'target')\n  if (filterIsUnit) {\n    sample({\n      source: filter,\n      clock: source,\n      target: createNode({\n        node: [\n          step.filter({\n            fn: ({guard}) => guard,\n          }),\n          step.compute({\n            fn: ({data}) => data,\n          }),\n        ],\n        child: target,\n        meta,\n        family: {\n          owners: [source, filter, target, ...[].concat(clock ? clock : [])],\n          links: target,\n        },\n        regional: true,\n      }),\n      fn: (guard: any, data: any) => ({guard, data}),\n      greedy,\n      name,\n    })\n  } else {\n    if (!isFunction(filter)) throwError('`filter` should be function or unit')\n    createLinkNode(source, target, {\n      scope: {fn: filter},\n      node: clock\n        ? [\n            step.filter({\n              fn: ({source, clock}, {fn}) => fn(source, clock),\n            }),\n            step.compute({\n              fn: ({source}) => source,\n            }),\n          ]\n        : [step.filter({fn: callStack})],\n      meta,\n    })\n  }\n  return target\n}\n","import {createStore} from './createUnit'\nimport {is} from './is'\nimport {forIn} from './collection'\nimport {getParent} from './getter'\n\nexport function restore(obj: any, defaultState: any, config?: any): any {\n  if (is.store(obj)) {\n    return obj\n  }\n  if (is.unit(obj)) {\n    const domain = getParent(obj)\n    let result\n    if (is.event(obj)) {\n      result = createStore(defaultState, {\n        parent: domain,\n        name: obj.shortName,\n        ɔ: config,\n      }).on(obj, (_, v) => v)\n    }\n    if (is.effect(obj)) {\n      result = createStore(defaultState, {\n        parent: domain,\n        name: obj.shortName,\n        ɔ: config,\n      }).on(obj.done, (_: any, {result}: any) => result)\n    }\n    if (domain) domain.hooks.store(result)\n    return result\n  }\n  const result: Record<string, any> = Array.isArray(obj) ? [] : {}\n  forIn(obj, (value, key) => {\n    result[key] = is.store(value) ? value : createStore(value, {name: key})\n  })\n  return result\n}\n","import {Event} from './unit.h'\nimport {NodeUnit, Cmd} from './index.h'\nimport {is, isFunction, isObject} from './is'\nimport {forIn, includes} from './collection'\nimport {createStateRef} from './stateRef'\nimport {readTemplate} from './region'\nimport {createLinkNode} from './forward'\nimport {processArgsToConfig} from './config'\nimport {step} from './typedef'\nimport {createNode} from './createNode'\nimport {launch} from './kernel'\nimport {getStoreState} from './getter'\nimport {REG_A} from './tag'\nimport {throwError} from './throw'\nimport {createEvent} from './createUnit'\n\nconst launchCase = (\n  scopeTargets: Record<string, NodeUnit>,\n  field: string,\n  data: any,\n  stack: any,\n) => {\n  const target = scopeTargets[field]\n  if (target) {\n    launch({\n      target,\n      params: Array.isArray(target) ? target.map(() => data) : data,\n      defer: true,\n      stack,\n    })\n  }\n}\n\nexport function split(...args: any[]): any {\n  let targets: Record<string, Event<any> | NodeUnit>\n  let [[source, match], metadata] = processArgsToConfig(args)\n  const knownCases = !match\n  if (knownCases) {\n    targets = source.cases\n    match = source.match\n    source = source.source\n  }\n  const matchIsUnit = is.store(match)\n  const matchIsFunction = !is.unit(match) && isFunction(match)\n  const matchIsShape = !matchIsUnit && !matchIsFunction && isObject(match)\n  if (!targets!) targets = {}\n  if (!knownCases) {\n    if (!matchIsShape) throwError('match should be an object')\n    forIn(match, (_, key) => {\n      //@ts-ignore\n      targets[key] = createEvent(metadata)\n    })\n    targets.__ = createEvent(metadata)\n  }\n  //@ts-ignore\n  const template = readTemplate()\n  const owners = new Set(\n    ([] as NodeUnit[]).concat(source, Object.values(targets)),\n  )\n  const caseNames = Object.keys(\n    matchIsUnit || matchIsFunction ? targets : match,\n  )\n  let splitterSeq: Array<Cmd | false>\n  if (matchIsUnit || matchIsFunction) {\n    if (matchIsUnit) owners.add(match)\n    splitterSeq = [\n      matchIsUnit && step.barrier({priority: 'sampler'}),\n      matchIsUnit &&\n        step.mov({\n          store: getStoreState(match),\n          to: 'a',\n        }),\n      step.filter({\n        fn(data, scopeTargets, stack) {\n          const value = String(matchIsUnit ? stack.a : match(data))\n          launchCase(\n            scopeTargets,\n            includes(caseNames, value) ? value : '__',\n            data,\n            stack,\n          )\n        },\n      }),\n    ]\n  } else if (matchIsShape) {\n    const lastValues = createStateRef({})\n    lastValues.type = 'shape'\n    const before: any[] = (lastValues.before = [])\n    const updaterSteps = [\n      step.mov({\n        store: lastValues,\n        to: REG_A,\n      }),\n      step.compute({\n        fn(upd, {key}, {a}) {\n          a[key] = upd\n        },\n      }),\n    ]\n    const units = [] as string[]\n    let needBarrier: boolean\n    forIn(match, (storeOrFn: any, key) => {\n      if (is.unit(storeOrFn)) {\n        needBarrier = true\n        units.push(key)\n        owners.add(storeOrFn)\n        const updater = createLinkNode(storeOrFn, [], {\n          node: updaterSteps,\n          scope: {key},\n        })\n        if (is.store(storeOrFn)) {\n          lastValues.current[key] = storeOrFn.getState()\n          const storeRef = getStoreState(storeOrFn)\n          before.push({\n            type: 'field',\n            field: key,\n            from: storeRef,\n          })\n          if (template) {\n            if (!includes(template.plain, storeRef)) {\n              updater.seq.unshift(template.loader)\n            }\n          }\n        }\n      }\n    })\n    if (needBarrier! && template) {\n      template.plain.push(lastValues)\n    }\n    splitterSeq = [\n      needBarrier! && step.barrier({priority: 'sampler'}),\n      needBarrier! &&\n        step.mov({\n          store: lastValues,\n          to: 'a',\n        }),\n      step.filter({\n        fn(data, scopeTargets, stack) {\n          for (let i = 0; i < caseNames.length; i++) {\n            const caseName = caseNames[i]\n            const caseValue = includes(units, caseName)\n              ? stack.a[caseName]\n              : match[caseName](data)\n            if (caseValue) {\n              launchCase(scopeTargets, caseName, data, stack)\n              return\n            }\n          }\n          launchCase(scopeTargets, '__', data, stack)\n        },\n      }),\n    ]\n  } else {\n    throwError('expect match to be unit, function or object')\n  }\n  createNode({\n    meta: {\n      onCopy: Object.keys(targets),\n      op: 'split',\n    },\n    parent: source,\n    scope: targets,\n    node: splitterSeq!,\n    family: {\n      type: 'crosslink',\n      owners: Array.from(owners),\n    },\n    regional: true,\n  })\n  if (!knownCases) return targets\n}\n","import {getForkPage, getGraph, getLinks, getOwners, getParent} from './getter'\nimport {bind} from './bind'\nimport {createDefer} from './defer'\nimport {watchUnit} from './watch'\nimport {is, isObject} from './is'\nimport {throwError} from './throw'\nimport {launch, forkPage, setForkPage, currentPage} from './kernel'\nimport {createNode} from './createNode'\nimport {step} from './typedef'\nimport {Domain, Store} from './unit.h'\nimport {Node, StateRef} from './index.h'\nimport {removeItem, forEach, includes, forIn} from './collection'\nimport {DOMAIN, STORE, EVENT, EFFECT, SAMPLER, MAP, FORK_COUNTER} from './tag'\n\n/**\n hydrate state on client\n\n const root = createDomain()\n hydrate(root, {\n  values: window.__initialState__\n})\n\n */\nexport function hydrate(domain: Domain, {values}: {values: any}) {\n  const isScope = isObject(domain) && (domain as any).cloneOf\n  if (!is.domain(domain) && !isScope) {\n    throwError('first argument of hydrate should be domain or scope')\n  }\n  if (!isObject(values)) {\n    throwError('values property should be an object')\n  }\n  const normalizedValues = normalizeValues(values)\n  let storeWatches: Node[]\n  let storeWatchesRefs: any[]\n  if (isScope) {\n    storeWatches = []\n    storeWatchesRefs = []\n    forIn(normalizedValues, (val, sid) => {\n      //@ts-ignore\n      const node = domain.sidMap[sid]\n      if (node) {\n        storeWatches.push(node)\n        storeWatchesRefs.push(val)\n        ;(domain as any).changedStores.add(node.meta.forkOf.id)\n      }\n    })\n  } else {\n    const fillResult = fillValues({\n      flatGraphUnits: flatGraph(domain),\n      values: normalizedValues,\n      collectWatches: true,\n    })\n    storeWatches = fillResult.storeWatches\n    storeWatchesRefs = fillResult.storeWatchesRefs.map(({current}) => current)\n  }\n\n  launch({\n    target: storeWatches,\n    params: storeWatchesRefs,\n    forkPage: isScope ? domain : false,\n  })\n}\n\nfunction fillValues({\n  flatGraphUnits,\n  values,\n  collectWatches,\n}: {\n  flatGraphUnits: Node[]\n  values: Record<string, any>\n  collectWatches: boolean\n}) {\n  const storeWatches: Node[] = []\n  const storeWatchesRefs: StateRef[] = []\n  const refsMap = {} as Record<string, StateRef>\n  const predefinedRefs = new Set()\n  const valuesSidList = Object.getOwnPropertyNames(values)\n  forEach(flatGraphUnits, node => {\n    const {reg} = node\n    const {op, unit, sid} = node.meta\n    if (unit === STORE) {\n      if (sid && includes(valuesSidList, sid)) {\n        const {state} = node.scope\n        state.current = values[sid]\n        predefinedRefs.add(state)\n      }\n    }\n    if (collectWatches && op === 'watch') {\n      const owner = node.family.owners[0]\n      if (owner.meta.unit === STORE) {\n        storeWatches.push(node)\n        storeWatchesRefs.push(owner.scope.state)\n      }\n    }\n    forIn(reg, (ref, id) => {\n      refsMap[id] = ref\n    })\n  })\n  const refGraph = createRefGraph(refsMap)\n  const result = toposort(refGraph)\n  forEach(result, id => {\n    execRef(refsMap[id])\n  })\n\n  return {\n    storeWatches,\n    storeWatchesRefs,\n  }\n\n  function execRef(ref: StateRef) {\n    let isFresh = false\n    if (ref.before && !predefinedRefs.has(ref)) {\n      forEach(ref.before, cmd => {\n        switch (cmd.type) {\n          case MAP: {\n            const from = cmd.from\n            ref.current = cmd.fn(from.current)\n            break\n          }\n          case 'field': {\n            const from = cmd.from\n            if (!isFresh) {\n              isFresh = true\n              if (Array.isArray(ref.current)) {\n                ref.current = [...ref.current]\n              } else {\n                ref.current = {...ref.current}\n              }\n            }\n            ref.current[cmd.field] = from.current\n            break\n          }\n          case 'closure':\n            break\n        }\n      })\n    }\n    if (!ref.after) return\n    const value = ref.current\n    forEach(ref.after, cmd => {\n      const to = cmd.to\n      // if (predefinedRefs.has(to)) continue\n      switch (cmd.type) {\n        case 'copy':\n          to.current = value\n          break\n        case MAP:\n          to.current = cmd.fn(value)\n          break\n      }\n    })\n  }\n}\n\nfunction createRefGraph(refsMap: Record<string, StateRef>) {\n  const items = Object.values(refsMap)\n  const refGraph = {} as Record<string, string[]>\n  forEach(items, ({id}) => {\n    refGraph[id] = []\n  })\n  //prettier-ignore\n  forEach(items, ({id, before, after}) => {\n    before && forEach(before, cmd => {\n      refGraph[cmd.from.id].push(id)\n    })\n    after && forEach(after, cmd => {\n      refGraph[id].push(cmd.to.id)\n    })\n  })\n  return refGraph\n}\n\n/**\n serialize state on server\n */\nexport function serialize(\n  {clones, changedStores}: any,\n  {\n    ignore = [],\n    onlyChanges,\n  }: {ignore?: Array<Store<any>>; onlyChanges?: boolean} = {},\n) {\n  const result = {} as Record<string, any>\n  forEach(clones, ({meta, scope, reg}) => {\n    if (meta.unit !== STORE) return\n    const {sid} = meta\n    if (!sid) return\n    if (onlyChanges || meta.isCombine) {\n      if (!changedStores.has(meta.forkOf.id)) return\n    }\n    result[sid] = reg[scope.state.id].current\n  })\n  forEach(ignore, ({sid}) => {\n    if (sid) delete result[sid]\n  })\n  return result\n}\n\n/** bind event to scope */\nexport function scopeBind(unit: any) {\n  if (!forkPage) {\n    throwError('scopeBind cannot be called outside of forked .watch')\n  }\n  const savedForkPage = forkPage\n  const localUnit = forkPage.find(unit)\n  return is.effect(unit)\n    ? (params: any) => {\n        const req = createDefer()\n        launch({\n          target: localUnit,\n          params: {\n            params,\n            req,\n          },\n          forkPage: savedForkPage,\n        })\n      }\n    : (params: any) => {\n        launch({target: localUnit, params, forkPage: savedForkPage})\n        return params\n      }\n}\n\nfunction normalizeValues(\n  values: Map<Store<any>, any> | Record<string, any>,\n  assertEach = (key: any, value: any) => {},\n) {\n  if (values instanceof Map) {\n    const result = {} as Record<string, any>\n    for (const [key, value] of values) {\n      if (!is.unit(key)) throwError('Map key should be a unit')\n      assertEach(key, value)\n      result[key.sid!] = value\n    }\n    return result\n  }\n  return values\n}\n\nexport function fork(\n  domain: Domain,\n  {values, handlers}: {values?: any; handlers?: any} = {},\n) {\n  if (!is.domain(domain)) throwError('first argument of fork should be domain')\n  const needToFill = !!values\n  values = normalizeValues(\n    values || {},\n    unit =>\n      !is.store(unit) &&\n      throwError('Values map can contain only stores as keys'),\n  )\n  const forked = cloneGraph(domain)\n  if (needToFill) {\n    fillValues()\n  }\n  if (handlers) {\n    handlers = normalizeValues(\n      handlers,\n      unit =>\n        !is.effect(unit) &&\n        throwError(`Handlers map can contain only effects as keys`),\n    )\n    const handlerKeys = Object.keys(handlers)\n    forEach(forked.clones, ({scope, meta}) => {\n      if (meta.sid && includes(handlerKeys, meta.sid)) {\n        scope.runner.scope.getHandler = () => handlers[meta.sid]\n      }\n    })\n  }\n  return forked\n\n  function fillValues() {\n    const sourceList = flatGraph(domain)\n    const sourceRefsMap = {} as Record<string, StateRef>\n    const refsMap = {} as Record<string, StateRef>\n    const predefinedRefs = new Set()\n    const templateOwnedRefs = new Set<string>()\n    const valuesSidList = Object.getOwnPropertyNames(values)\n    forEach(sourceList, ({reg, meta}) => {\n      const {nativeTemplate} = meta\n      forIn(reg, (ref, id) => {\n        sourceRefsMap[id] = ref\n        if (nativeTemplate) {\n          templateOwnedRefs.add(id)\n        }\n      })\n    })\n    forEach(forked.clones, node => {\n      const {reg} = node\n      const {unit, sid} = node.meta\n      if (unit === STORE) {\n        if (sid && includes(valuesSidList, sid)) {\n          const {state} = node.scope\n          reg[state.id].current = values[sid]\n          predefinedRefs.add(state)\n          forked.changedStores.add(node.meta.forkOf.id)\n        }\n      }\n      forIn(reg, (ref, id) => {\n        refsMap[id] = ref\n      })\n    })\n    const refGraph = createRefGraph(sourceRefsMap)\n    const result = toposort(refGraph, templateOwnedRefs)\n    forEach(result, id => {\n      execRef(refsMap[id], sourceRefsMap[id])\n    })\n\n    function execRef(ref: StateRef, sourceRef?: StateRef) {\n      let isFresh = false\n      if (sourceRef && sourceRef.before && !predefinedRefs.has(ref)) {\n        forEach(sourceRef.before, cmd => {\n          switch (cmd.type) {\n            case MAP: {\n              const from = refsMap[cmd.from.id]\n              ref.current = cmd.fn(from.current)\n              break\n            }\n            case 'field': {\n              const from = refsMap[cmd.from.id]\n              if (!isFresh) {\n                isFresh = true\n                if (Array.isArray(ref.current)) {\n                  ref.current = [...ref.current]\n                } else {\n                  ref.current = {...ref.current}\n                }\n              }\n              ref.current[cmd.field] = from.current\n              break\n            }\n            case 'closure':\n              break\n          }\n        })\n      }\n      if (!sourceRef || !sourceRef.after) return\n      const value = ref.current\n      forEach(sourceRef.after, cmd => {\n        const to = refsMap[cmd.to.id]\n        // if (predefinedRefs.has(to)) continue\n        switch (cmd.type) {\n          case 'copy':\n            to.current = value\n            break\n          case MAP:\n            to.current = cmd.fn(value)\n            break\n        }\n      })\n    }\n  }\n}\n\nfunction toposort(rawGraph: Record<string, string[]>, ignore?: Set<string>) {\n  const graph = {} as Record<string, string[]>\n  for (const id in rawGraph) {\n    graph[id] = [...new Set(rawGraph[id])]\n  }\n  const result = [] as string[]\n  const visited = {} as Record<string, boolean>\n  const temp = {} as Record<string, boolean>\n  for (const node in graph) {\n    if (!visited[node] && !temp[node]) {\n      topologicalSortHelper(node)\n    }\n  }\n  result.reverse()\n  if (ignore && ignore.size > 0) {\n    const processed = [] as string[]\n    const ignored = [...ignore]\n    let item: string | void\n    while ((item = ignored.shift())) {\n      processed.push(item)\n      forEach(graph[item], child => {\n        if (includes(processed, child) || includes(ignored, child)) return\n        ignored.push(child)\n      })\n    }\n    forEach(processed, item => {\n      removeItem(result, item)\n    })\n  }\n  return result\n\n  function topologicalSortHelper(node: string) {\n    temp[node] = true\n    const neighbors = graph[node]\n    for (let i = 0; i < neighbors.length; i++) {\n      const n = neighbors[i]\n      if (temp[n]) {\n        continue\n        // throw Error('found cycle in DAG')\n      }\n      if (!visited[n]) {\n        topologicalSortHelper(n)\n      }\n    }\n    temp[node] = false\n    visited[node] = true\n    result.push(node)\n  }\n}\n\nexport function allSettled(\n  start: any,\n  {scope, params: ctx}: {scope: any; params?: any},\n) {\n  if (!is.unit(start))\n    return Promise.reject(Error('first argument should be unit'))\n  const defer = createDefer()\n  //@ts-ignore\n  defer.parentFork = forkPage\n  const {forkInFlightCounter} = scope.graphite.scope\n  forkInFlightCounter.scope.defers.push(defer)\n  const contextStart = scope.find(start)\n\n  const launchUnits = [contextStart]\n  const launchParams = []\n  if (is.effect(start)) {\n    launchParams.push({\n      params: ctx,\n      req: {\n        rs(value: any) {\n          //@ts-ignore\n          defer.value = {status: 'done', value}\n        },\n        rj(value: any) {\n          //@ts-ignore\n          defer.value = {status: 'fail', value}\n        },\n      },\n    })\n  } else {\n    launchParams.push(ctx)\n  }\n  launchUnits.push(forkInFlightCounter)\n  launchParams.push(null)\n  launch({\n    target: launchUnits,\n    params: launchParams,\n    forkPage: scope,\n  })\n  return defer.req\n}\n\nfunction flatGraph(unit: any) {\n  const list = [] as Node[]\n  ;(function traverse(node) {\n    if (includes(list, node)) return\n    list.push(node)\n    forEachRelatedNode(node, traverse)\n  })(getGraph(unit))\n  return list\n}\n\n/**\n everything we need to clone graph section\n reachable from given unit\n */\nfunction cloneGraph(unit: any) {\n  const list = flatGraph(unit)\n  const refs = new Map()\n  const scope = {\n    defers: [],\n    inFlight: 0,\n    fxID: 0,\n  }\n  const changedStores = new Set<string>()\n  const putStoreToChanged = step.compute({\n    fn(upd, _, stack) {\n      if (\n        !stack.node.meta.isCombine ||\n        (getParent(stack) && getParent(stack).node.meta.op !== 'combine')\n      )\n        changedStores.add(stack.node.meta.forkOf.id)\n      return upd\n    },\n  })\n  const forkInFlightCounter = createNode({\n    scope,\n    node: [\n      step.compute({\n        fn(_, scope, stack) {\n          if (!stack.parent) {\n            scope.fxID += 1\n            return\n          }\n          if (stack.parent.node.meta.named === 'finally') {\n            scope.inFlight -= 1\n          } else {\n            scope.inFlight += 1\n            scope.fxID += 1\n          }\n        },\n      }),\n      step.barrier({priority: SAMPLER}),\n      step.run({\n        fn(_, scope) {\n          const {inFlight, defers, fxID} = scope\n          if (inFlight > 0 || defers.length === 0) return\n          Promise.resolve().then(() => {\n            if (scope.fxID !== fxID) return\n            forEach(defers.splice(0, defers.length), (defer: any) => {\n              setForkPage(defer.parentFork)\n              defer.rs(defer.value)\n            })\n          })\n        },\n      }),\n    ],\n    meta: {unit: FORK_COUNTER},\n  })\n  const nodeMap = {} as Record<string, Node>\n  const sidMap = {} as Record<string, Node>\n  const clones = list.map(node => {\n    const {seq, next, meta, scope} = node\n    const result = createNode({\n      node: seq.map(step => ({\n        id: step.id,\n        type: step.type,\n        data: {...step.data},\n        hasRef: step.hasRef,\n      })) as any,\n      child: [...next],\n      meta: {forkOf: node, ...meta},\n      scope: {...scope},\n    })\n    result.family = {\n      type: node.family.type,\n      links: [...getLinks(node)],\n      owners: [...getOwners(node)],\n    }\n    nodeMap[node.id] = result\n    if (meta.sid) sidMap[meta.sid] = result\n    return result\n  })\n  const page = {} as Record<string, StateRef>\n  forEach(clones, node => {\n    const {\n      reg,\n      scope,\n      meta: {onCopy, op, unit},\n    } = node\n    forIn(reg, (ref, id) => {\n      let newRef = refs.get(ref)\n      if (!newRef) {\n        newRef = {\n          id: ref.id,\n          current: ref.current, //ref.id in values ? values[ref.id] : ref.current,\n        }\n        refs.set(ref, newRef)\n      }\n      page[id] = reg[id] = newRef\n    })\n    if (onCopy) {\n      forEach(onCopy, (copyField: string) => {\n        const origValue = scope[copyField]\n        scope[copyField] = Array.isArray(origValue)\n          ? origValue.map(findClone)\n          : findClone(origValue)\n      })\n    }\n    forEachRelatedNode(node, (node, i, siblings) => {\n      siblings[i] = findClone(node)\n    })\n    const itemTag = op || unit\n    switch (itemTag) {\n      case STORE:\n        node.meta.wrapped = wrapStore(node)\n        if (node.meta.sid) node.seq.push(putStoreToChanged)\n        break\n      // case EVENT:\n      //   break\n      case EFFECT:\n        node.next.push(forkInFlightCounter)\n        break\n      case 'fx': {\n        scope.finally.next.push(forkInFlightCounter)\n        break\n      }\n      // case 'watch':\n      //   break\n    }\n  })\n\n  return {\n    cloneOf: unit,\n    changedStores,\n    nodeMap,\n    sidMap,\n    clones,\n    find: findClone,\n    reg: page,\n    getState: (store: any) => findClone(store).meta.wrapped.getState(),\n    graphite: createNode({\n      family: {\n        type: DOMAIN,\n        links: [forkInFlightCounter, ...clones],\n      },\n      meta: {unit: 'fork'},\n      scope: {forkInFlightCounter},\n    }),\n  }\n\n  function findClone(unit: any) {\n    const node = getGraph(unit)\n    const index = list.indexOf(node)\n    if (index === -1) {\n      let unitName = 'unit'\n      if (unit !== node && unit.id !== unit.shortName) unitName = unit.shortName\n      throwError(`${unitName} not found in forked scope`)\n    }\n    return clones[index]\n  }\n}\n\nfunction wrapStore(node: Node) {\n  return {\n    kind: STORE,\n    getState: () => node.reg[node.scope.state.id].current,\n    updates: {\n      watch: bind(watchUnit, node),\n    },\n    graphite: node,\n    family: node.family,\n  }\n}\n\nfunction forEachRelatedNode(\n  node: Node,\n  cb: (node: Node, index: number, siblings: Node[]) => void,\n) {\n  const unit = node.meta.unit\n  if (unit === 'fork' || unit === FORK_COUNTER) return\n  forEach(node.next, cb)\n  forEach(getOwners(node), cb)\n  forEach(getLinks(node), cb)\n}\n","export const observableSymbol: any =\n  (typeof Symbol !== 'undefined' && Symbol.observable) || '@@observable'\n","import {kind} from './index.h'\nimport {DOMAIN, STORE, EVENT, EFFECT} from './tag'\nimport {isObject, isFunction} from './is'\n\nexport const unit = (obj: any) =>\n  (isFunction(obj) || isObject(obj)) && 'kind' in obj\n\nconst is = (type: kind) => (obj: any) => unit(obj) && obj.kind === type\n\nexport const store = is(STORE)\nexport const event = is(EVENT)\nexport const effect = is(EFFECT)\nexport const domain = is(DOMAIN)\n","export const throwError = (message: string) => {\n  throw Error(message)\n}\n","const idCount = () => {\n  let id = 0\n  return () => (++id).toString(36)\n}\n\nexport const nextUnitID = idCount()\nexport const nextStepID = idCount()\nexport const nextNodeID = idCount()\n","export const bind = (fn: Function, target: any) => fn.bind(null, target)\nexport const bind2 = (fn: Function, target: any, arg: any) =>\n  fn.bind(null, target, arg)\n","import {StateRef, Run, Filter, Compute, Barrier, Check, Mov} from './index.h'\nimport {nextStepID} from './id'\nimport {bind2} from './bind'\nimport {BARRIER, FILTER, STACK, STORE} from './tag'\n\nconst cmd = (type: any, hasRef: boolean, data: any): any => ({\n  id: nextStepID(),\n  type,\n  data,\n  hasRef,\n})\n\nlet nextBarrierID = 0\n\nexport const barrier: (data: {priority?: 'barrier' | 'sampler'}) => Barrier = ({\n  priority = BARRIER,\n}) =>\n  cmd(BARRIER, false, {\n    barrierID: ++nextBarrierID,\n    priority,\n  })\nexport const mov: (data: {\n  from?: 'value' | 'store' | 'stack' | 'a' | 'b'\n  to?: 'stack' | 'a' | 'b' | 'store'\n  store?: any\n  target?: any\n}) => Mov = ({from = STORE, store, target, to = target ? STORE : STACK}) =>\n  cmd('mov', from === STORE, {from, store, to, target})\nexport const check: {\n  defined(): Check\n  changed(config: {store: StateRef}): Check\n} = {\n  defined: () => cmd('check', false, {type: 'defined'}),\n  changed: ({store}) => cmd('check', true, {type: 'changed', store}),\n}\nexport const compute: (data: {\n  fn: (data: any, scope: {[key: string]: any}, stack: any) => any\n}) => Compute = bind2(cmd, 'compute', false)\nexport const filter: (data: {\n  fn: (data: any, scope: {[key: string]: any}, stack: any) => any\n}) => Filter = bind2(cmd, FILTER, false)\nexport const run: (data: {\n  fn: (data: any, scope: {[key: string]: any}, stack: any) => any\n}) => Run = bind2(cmd, 'run', false)\nexport const update: (data: {store: StateRef}) => Mov = ({store}) =>\n  mov({from: STACK, target: store})\n","import {StateRef} from './index.h'\nimport {nextStepID} from './id'\n\nexport const createStateRef = (current?: any): StateRef => ({\n  id: nextStepID(),\n  current,\n})\nexport const readRef = ({current}: StateRef | {current: any}) => current\n","export const callStackAReg = (stack: any, {fn}: any, {a}: any) => fn(stack, a)\nexport const callARegStack = (stack: any, {fn}: any, {a}: any) => fn(a, stack)\nexport const callStack = (stack: any, {fn}: any, _: any) => fn(stack)\n","import {Node, StateRef} from './index.h'\n\nexport const getGraph = (graph: any): Node => graph.graphite || graph\nexport const getOwners = (node: Node) => node.family.owners\nexport const getLinks = (node: Node) => node.family.links\nexport const getStoreState = (store: any): StateRef => store.stateRef\nexport const getConfig = (opts: any) => opts.config\nexport const getNestedConfig = (opts: any) => opts.ɔ\nexport const getValue = (stack: any) => stack.value\nexport const getSubscribers = (store: any) => store.subscribers\nexport const getParent = (unit: any) => unit.parent\nexport const getForkPage = (val: any) => val.forkPage\n","import {NodeUnit} from './index.h'\nimport {getGraph, getOwners, getLinks} from './getter'\nimport {DOMAIN, CROSSLINK} from './tag'\n\nexport const own = (ownerUnit: NodeUnit, links: NodeUnit[]) => {\n  const owner = getGraph(ownerUnit)\n  for (let i = 0; i < links.length; i++) {\n    const link = getGraph(links[i])\n    if (owner.family.type !== DOMAIN) link.family.type = CROSSLINK\n    getOwners(link).push(owner)\n    getLinks(owner).push(link)\n  }\n}\n","import {getConfig, getNestedConfig} from './getter'\nimport {assertObject} from './is'\n\nexport const onConfigNesting = (\n  rawConfig: any,\n  fn: (babelData: any, userConfig: any) => void,\n) => {\n  assertObject(rawConfig)\n  if (getNestedConfig(rawConfig)) {\n    fn(getConfig(rawConfig), getNestedConfig(rawConfig))\n  }\n}\n\nexport const processArgsToConfig = (args: any[]): [any[], any | void] => {\n  let metadata\n  onConfigNesting(args[0], (injected, config) => {\n    metadata = injected\n    args = config\n  })\n  return [args, metadata]\n}\n","import {Node, NodeUnit} from './index.h'\nimport {getGraph, getOwners, getLinks, getSubscribers} from './getter'\nimport {is} from './is'\nimport {removeItem} from './collection'\nimport {CROSSLINK} from './tag'\n\nconst removeFromNode = (currentNode: Node, targetNode: Node) => {\n  removeItem(currentNode.next, targetNode)\n  removeItem(getOwners(currentNode), targetNode)\n  removeItem(getLinks(currentNode), targetNode)\n}\nconst clearNodeNormalized = (\n  targetNode: Node,\n  deep: boolean,\n  isDomainUnit: boolean,\n) => {\n  targetNode.next.length = 0\n  targetNode.seq.length = 0\n  //@ts-ignore\n  targetNode.scope = null\n  let currentNode\n  let list = getLinks(targetNode)\n  while ((currentNode = list.pop())) {\n    removeFromNode(currentNode, targetNode)\n    if (\n      deep ||\n      (isDomainUnit && !targetNode.meta.sample) ||\n      currentNode.family.type === CROSSLINK\n    ) {\n      clearNodeNormalized(\n        currentNode,\n        deep,\n        currentNode.meta.op !== 'on' && isDomainUnit,\n      )\n    }\n  }\n  list = getOwners(targetNode)\n  while ((currentNode = list.pop())) {\n    removeFromNode(currentNode, targetNode)\n    if (isDomainUnit && currentNode.family.type === CROSSLINK) {\n      clearNodeNormalized(\n        currentNode,\n        deep,\n        currentNode.meta.op !== 'on' && isDomainUnit,\n      )\n    }\n  }\n}\nconst clearMap = (map: any) => map.clear()\nexport const clearNode = (\n  graphite: NodeUnit,\n  {\n    deep,\n  }: {\n    deep?: boolean\n  } = {},\n) => {\n  let isDomainUnit = false\n  //@ts-ignore\n  if (graphite.ownerSet) graphite.ownerSet.delete(graphite)\n  if (is.store(graphite)) {\n    clearMap(getSubscribers(graphite))\n  } else if (is.domain(graphite)) {\n    isDomainUnit = true\n    //@ts-ignore\n    const history = graphite.history\n    clearMap(history.events)\n    clearMap(history.effects)\n    clearMap(history.stores)\n    clearMap(history.domains)\n  }\n  clearNodeNormalized(getGraph(graphite), !!deep, isDomainUnit)\n}\n","import {Subscription, NodeUnit} from './index.h'\nimport {bind2} from './bind'\nimport {clearNode} from './clearNode'\n\nexport const createSubscription = (node: NodeUnit): Subscription => {\n  const result = bind2(clearNode, node, undefined)\n  result.unsubscribe = result\n  return result\n}\n","import {onConfigNesting} from './config'\nimport {createNode} from './createNode'\nimport {Subscription, NodeUnit, Cmd} from './index.h'\nimport {createSubscription} from './subscription'\nimport {assertNodeSet} from './is'\n\nexport const createLinkNode = (\n  parent: NodeUnit,\n  child: NodeUnit | NodeUnit[],\n  {\n    node,\n    scope,\n    meta,\n  }: {\n    node?: Array<Cmd | false | void | null>\n    scope?: {[name: string]: any}\n    meta?: {[name: string]: any}\n  },\n) =>\n  createNode({\n    node,\n    parent,\n    child,\n    scope,\n    meta,\n    family: {\n      owners: [parent, child],\n      links: child,\n    },\n    regional: true,\n  })\nexport const forward = (opts: {\n  from: NodeUnit | NodeUnit[]\n  to: NodeUnit | NodeUnit[]\n  meta?: Record<string, any>\n}): Subscription => {\n  let config\n  onConfigNesting(opts, (injectedData, userConfig) => {\n    config = injectedData\n    opts = userConfig\n  })\n  const {from, to, meta = {op: 'forward'}} = opts\n  assertNodeSet(from, 'forward', '\"from\"')\n  assertNodeSet(to, 'forward', '\"to\"')\n  if (config) meta.config = config\n  return createSubscription(\n    createNode({\n      parent: from,\n      child: to,\n      meta,\n      family: {},\n      regional: true,\n    }),\n  )\n}\n","import {step} from './typedef'\nimport {callStack} from './caller'\nimport {createNode} from './createNode'\nimport {Subscription, NodeUnit} from './index.h'\nimport {createSubscription} from './subscription'\nimport {throwError} from './throw'\nimport {isFunction} from './is'\nimport {forkPage} from './kernel'\nimport {getGraph} from './getter'\n\nexport const watchUnit = (\n  unit: NodeUnit,\n  handler: (payload: any) => any,\n): Subscription => {\n  if (!isFunction(handler)) throwError('.watch argument should be a function')\n  if (forkPage) {\n    const forkedNode = forkPage.nodeMap[getGraph(unit).id]\n    if (forkedNode) unit = forkedNode\n  }\n  return createSubscription(\n    createNode({\n      scope: {fn: handler},\n      node: [step.run({fn: callStack})],\n      parent: unit,\n      meta: {op: 'watch'},\n      family: {\n        owners: unit,\n      },\n      regional: true,\n    }),\n  )\n}\n"]},"metadata":{},"sourceType":"module"}