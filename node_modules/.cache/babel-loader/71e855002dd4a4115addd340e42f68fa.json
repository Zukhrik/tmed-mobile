{"ast":null,"code":"function e(e, t, r, a) {\n  (V(e) || J(e)) && ('family' in e || 'graphite' in e) || B(`${t}: expect ${r} to be a unit (store, event or effect)${a}`);\n}\n\nfunction t(t, r, a) {\n  if (Array.isArray(t)) for (let n = 0; n < t.length; n++) e(t[n], r, `${n} item of ${a}`, '');else e(t, r, a, ' or array of units');\n}\n\nfunction r(e, t) {\n  let r = ge(e).meta;\n  Ce = {\n    parent: Ce,\n    value: e,\n    template: r.template || je(),\n    sidRoot: r.sidRoot || Ce && Ce.sidRoot\n  };\n\n  try {\n    return t();\n  } finally {\n    Ce = xe(Ce);\n  }\n}\n\nfunction a({\n  node: e = [],\n  from: t,\n  source: r,\n  parent: a = t || r,\n  to: n,\n  target: o,\n  child: s = n || o,\n  scope: l = {},\n  meta: i = {},\n  family: f = {\n    type: 'regular'\n  },\n  regional: c\n} = {}) {\n  let u = Fe(a),\n      p = Fe(f.links),\n      d = Fe(f.owners),\n      m = [],\n      h = {};\n\n  for (let t = 0; t < e.length; t++) {\n    let r = e[t];\n    r && (m.push(r), Re(r, h));\n  }\n\n  let g = {\n    id: Y(),\n    seq: m,\n    next: Fe(s),\n    meta: i,\n    scope: l,\n    family: {\n      type: f.type || \"crosslink\",\n      links: p,\n      owners: d\n    },\n    reg: h\n  };\n\n  for (let e = 0; e < p.length; e++) ye(p[e]).push(g);\n\n  for (let e = 0; e < d.length; e++) ke(d[e]).push(g);\n\n  for (let e = 0; e < u.length; e++) u[e].next.push(g);\n\n  return c && Ce && Ae(Se(Ce), [g]), g;\n}\n\nfunction n(e, t, r) {\n  let a = Be,\n      n = null,\n      o = He;\n  if (e.target && (t = e.params, r = e.defer, a = 'page' in e ? e.page : a, e.stack && (n = e.stack), o = Ne(e) || o, e = e.target), o && He && o !== He && (He = null), Array.isArray(e)) for (let r = 0; r < e.length; r++) Ee('pure', a, ge(e[r]), n, t[r], o);else Ee('pure', a, ge(e), n, t, o);\n  if (r && !Ge) return;\n  let s,\n      l,\n      i,\n      f,\n      c,\n      u,\n      p = {\n    isRoot: Ge,\n    currentPage: Be,\n    forkPage: He,\n    isWatch: Ue\n  };\n  Ge = 0;\n\n  e: for (; f = $e();) {\n    let {\n      idx: e,\n      stack: t,\n      type: r\n    } = f;\n    i = t.node, Be = c = t.page, He = Ne(t), u = (c || i).reg;\n    let a = {\n      fail: 0,\n      scope: i.scope\n    };\n    s = l = 0;\n\n    for (let n = e; n < i.seq.length && !s; n++) {\n      let o = i.seq[n],\n          f = o.data;\n\n      switch (o.type) {\n        case \"barrier\":\n          {\n            let a = f.barrierID;\n            c && (a = `${c.fullID}_${a}`);\n            let o = f.priority;\n\n            if (n !== e || r !== o) {\n              Te.has(a) || (Te.add(a), ze(n, t, o, a));\n              continue e;\n            }\n\n            Te.delete(a);\n            break;\n          }\n\n        case 'mov':\n          {\n            let e;\n\n            switch (f.from) {\n              case \"stack\":\n                e = Se(t);\n                break;\n\n              case \"a\":\n              case 'b':\n                e = t[f.from];\n                break;\n\n              case \"value\":\n                e = f.store;\n                break;\n\n              case I:\n                u[f.store.id] || (t.page = c = Ke(c, f.store.id), u = c ? c.reg : i.reg), e = pe(u[f.store.id]);\n            }\n\n            switch (f.to) {\n              case \"stack\":\n                t.value = e;\n                break;\n\n              case \"a\":\n              case 'b':\n                t[f.to] = e;\n                break;\n\n              case I:\n                Le(c, i, f.target.id).current = e;\n            }\n\n            break;\n          }\n\n        case 'check':\n          switch (f.type) {\n            case 'defined':\n              l = void 0 === Se(t);\n              break;\n\n            case 'changed':\n              l = Se(t) === pe(Le(c, i, f.store.id));\n          }\n\n          break;\n\n        case \"filter\":\n          l = !Qe(a, f, t);\n          break;\n\n        case 'run':\n          if (n !== e || \"effect\" !== r) {\n            ze(n, t, \"effect\");\n            continue e;\n          }\n\n        case 'compute':\n          Ue = 'watch' === i.meta.op, t.value = Qe(a, f, t), Ue = p.isWatch;\n      }\n\n      s = a.fail || l;\n    }\n\n    if (!s) for (let e = 0; e < i.next.length; e++) Ee('child', c, i.next[e], t, Se(t), Ne(t));\n  }\n\n  Ge = p.isRoot, Be = p.currentPage, He = Ne(p);\n}\n\nfunction o(e, t = \"combine\") {\n  let r = t + '(',\n      a = '',\n      n = 0;\n\n  for (let t in e) {\n    let o = e[t];\n    if (null != o && (r += a, r += E(o) ? o.compositeName.fullName : o.toString()), n += 1, 25 === n) break;\n    a = ', ';\n  }\n\n  return r += ')', r;\n}\n\nfunction s(e, t) {\n  let r = l(t, xe(e));\n  if (e.shortName = t, !e.compositeName) return void (e.compositeName = r);\n  let a = e.compositeName;\n  a.path = r.path, a.shortName = r.shortName, a.fullName = r.fullName;\n}\n\nfunction l(e, t) {\n  let r,\n      a,\n      n,\n      o = e;\n  return t ? (n = t.compositeName, 0 === e.length ? (r = n.path, a = n.fullName) : (r = n.path.concat([e]), a = 0 === n.fullName.length ? e : n.fullName + '/' + e)) : (r = 0 === e.length ? [] : [e], a = e), {\n    shortName: o,\n    fullName: a,\n    path: r\n  };\n}\n\nfunction i(e, t) {\n  for (let r in e) t(e[r], r);\n}\n\nfunction f(e, t) {\n  e.forEach(t);\n}\n\nfunction c(e, t) {\n  let r = (e, ...t) => Be ? ((e, t, r, a) => {\n    let n = Be,\n        o = null;\n    if (t) for (o = Be; o && o.template !== t;) o = xe(o);\n    Je(o);\n    let s = e.create(r, a);\n    return Je(n), s;\n  })(r, o, e, t) : r.create(e, t);\n\n  r.graphite = a({\n    meta: ht(\"event\", r, t, e),\n    regional: 1\n  }), r.create = e => (n(He ? He.find(r) : r, e), e), r.watch = Z(ut, r), r.map = e => {\n    let t, a;\n    V(e) && (t = e, a = e.name, e = e.fn);\n    let n = c(Ye(r, a), t);\n    return yt(r, n, $, e), n;\n  }, r.filter = e => kt(r, \"filter\", e.fn ? e : e.fn, [le({\n    fn: he\n  })]), r.filterMap = e => kt(r, 'filterMap', e, [se({\n    fn: he\n  }), oe.defined()]), r.prepend = e => {\n    let t = c('* → ' + r.shortName, {\n      parent: xe(r)\n    }),\n        a = je();\n    return a && ge(t).seq.push(a.upward), yt(t, r, 'prepend', e), mt(r, t), t;\n  };\n  let o = je();\n  return r;\n}\n\nfunction u(e, r) {\n  function o(e, t) {\n    p.off(e), qe(p).set(e, lt(bt(e, p, 'on', 1, t, m)));\n  }\n\n  let s = ue(e),\n      l = ue(e),\n      i = gt('updates'),\n      f = je();\n  s.after = [{\n    type: 'copy',\n    to: l\n  }], f && f.plain.push(s, l);\n  let c = s.id,\n      p = {\n    subscribers: new Map(),\n    updates: i,\n    defaultState: e,\n    stateRef: s,\n\n    getState() {\n      let e,\n          t = s;\n\n      if (Be) {\n        let t = Be;\n\n        for (; t && !t.reg[c];) t = xe(t);\n\n        t && (e = t);\n      }\n\n      return !e && He && He.reg[c] && (e = He), e && (t = e.reg[c]), pe(t);\n    },\n\n    setState(e) {\n      let t;\n      He && (t = He.nodeMap[ge(p).id]), t || (t = p), n({\n        target: t,\n        params: e,\n        defer: 1\n      });\n    },\n\n    reset(...e) {\n      for (let t of e) p.on(t, () => p.defaultState);\n\n      return p;\n    },\n\n    on(e, r) {\n      if (t(e, '.on', 'first argument'), Array.isArray(e)) for (let t of e) o(t, r);else o(e, r);\n      return p;\n    },\n\n    off(e) {\n      let t = qe(p).get(e);\n      return t && (t(), qe(p).delete(e)), p;\n    },\n\n    map(e, t) {\n      let r, a, n;\n      V(e) && (r = e, a = e.name, t = e.firstState, e = e.fn);\n      let o = p.getState(),\n          l = je();\n      l ? n = null : void 0 !== o && (n = e(o, t));\n      let i = u(n, {\n        name: Ye(p, a),\n        config: r,\n        strict: 0\n      }),\n          f = bt(p, i, $, 0, e);\n      return be(i).before = [{\n        type: $,\n        fn: e,\n        from: s\n      }], l && (tt(l.plain, s) || tt(f.seq, l.loader) || f.seq.unshift(l.loader)), i;\n    },\n\n    watch(e, t) {\n      if (!t || !E(e)) {\n        let t = ut(p, e),\n            r = je();\n        return r ? r.watch.push({\n          of: s,\n          fn: e\n        }) : e(p.getState()), t;\n      }\n\n      return J(t) || B('second argument should be a function'), e.watch(e => t(p.getState(), e));\n    }\n\n  },\n      d = ht(I, p, r),\n      m = p.defaultConfig.updateFilter;\n  return p.graphite = a({\n    scope: {\n      state: s\n    },\n    node: [oe.defined(), oe.changed({\n      store: l\n    }), m && ne({\n      store: l,\n      to: \"a\"\n    }), m && le({\n      fn: (e, t, {\n        a: r\n      }) => m(e, r)\n    }), fe({\n      store: s\n    }), fe({\n      store: l\n    })],\n    child: i,\n    meta: d,\n    regional: 1\n  }), dt && void 0 === e && B(\"current state can't be undefined, use null instead\"), Ae(p, [i]), p;\n}\n\nfunction p(...e) {\n  let t, r, a;\n  Ze(e[0], (t, r) => {\n    a = t, e = r;\n  });\n  let n,\n      o,\n      s = e[e.length - 1];\n\n  if (J(s) ? (r = e.slice(0, -1), t = s) : r = e, 1 === r.length) {\n    let e = r[0];\n    W(e) || (n = e, o = 1);\n  }\n\n  return o || (n = r, t && (t = vt(t))), V(n) || B('shape should be an object'), wt(Array.isArray(n), n, a, t);\n}\n\nfunction d() {\n  let e = {};\n  return e.req = new Promise((t, r) => {\n    e.rs = t, e.rj = r;\n  }), e.req.catch(() => {}), e;\n}\n\nfunction m(e, t) {\n  let r = c(e, t),\n      o = r.defaultConfig.handler || (() => B(`no handler used in ${r.getType()}`)),\n      s = ge(r);\n\n  s.meta.onCopy = ['runner'], s.meta.unit = r.kind = \"effect\", r.use = e => (J(e) || B('.use argument should be a function'), o = e, r);\n  let l = r.finally = gt('finally'),\n      i = r.done = l.filterMap({\n    named: 'done',\n\n    fn({\n      status: e,\n      params: t,\n      result: r\n    }) {\n      if ('done' === e) return {\n        params: t,\n        result: r\n      };\n    }\n\n  }),\n      f = r.fail = l.filterMap({\n    named: 'fail',\n\n    fn({\n      status: e,\n      params: t,\n      error: r\n    }) {\n      if ('fail' === e) return {\n        params: t,\n        error: r\n      };\n    }\n\n  }),\n      p = r.doneData = i.map({\n    named: 'doneData',\n    fn: ({\n      result: e\n    }) => e\n  }),\n      m = r.failData = f.map({\n    named: 'failData',\n    fn: ({\n      error: e\n    }) => e\n  }),\n      h = a({\n    scope: {\n      getHandler: r.use.getCurrent = () => o,\n      finally: l\n    },\n    node: [ie({\n      fn({\n        params: e,\n        req: t\n      }, {\n        finally: r,\n        getHandler: a\n      }, n) {\n        let o,\n            s = St({\n          params: e,\n          req: t,\n          ok: 1,\n          anyway: r,\n          stack: n\n        }),\n            l = St({\n          params: e,\n          req: t,\n          ok: 0,\n          anyway: r,\n          stack: n\n        });\n\n        try {\n          o = a()(e);\n        } catch (e) {\n          return void l(e);\n        }\n\n        V(o) && J(o.then) ? o.then(s, l) : s(o);\n      }\n\n    })],\n    meta: {\n      op: 'fx',\n      fx: 'runner',\n      onCopy: ['finally']\n    }\n  });\n  s.scope.runner = h, s.seq.push(se({\n    fn: (e, t, r) => xe(r) ? {\n      params: e,\n      req: {\n        rs(e) {},\n\n        rj(e) {}\n\n      }\n    } : e\n  }), ie({\n    fn: (e, {\n      runner: t\n    }, r) => (n({\n      target: t,\n      params: e,\n      defer: 1,\n      forkPage: Ne(r)\n    }), e.params)\n  })), r.create = e => {\n    let t = d(),\n        a = {\n      params: e,\n      req: t\n    };\n\n    if (He) {\n      if (!Ue) {\n        let e = He;\n        t.req.finally(() => {\n          Ve(e);\n        }).catch(() => {});\n      }\n\n      n(He.find(r), a);\n    } else n(r, a);\n\n    return t.req;\n  };\n  let g = r.inFlight = u(0, {\n    named: 'inFlight'\n  }).on(r, e => e + 1).on(l, e => e - 1),\n      y = r.pending = g.map({\n    fn: e => e > 0,\n    named: 'pending'\n  });\n  return Ae(r, [l, i, f, p, m, y, g, h]), r;\n}\n\nfunction h(e) {\n  let t;\n  Ze(e, (r, a) => {\n    t = r, e = a;\n  });\n  let {\n    source: r,\n    effect: a,\n    mapParams: o\n  } = e;\n  o || (o = r ? (e, t) => t : e => e);\n\n  let s,\n      l = m(e, t),\n      {\n    runner: i\n  } = ge(l).scope,\n      f = ({\n    params: e,\n    req: t\n  }, {\n    finally: r,\n    effect: a\n  }, s) => {\n    let l,\n        i = St({\n      params: e,\n      req: t,\n      ok: 0,\n      anyway: r,\n      stack: s\n    });\n\n    try {\n      l = o(e, s.a);\n    } catch (e) {\n      return i(e);\n    }\n\n    n({\n      target: a,\n      params: {\n        params: l,\n        req: {\n          rs: St({\n            params: e,\n            req: t,\n            ok: 1,\n            anyway: r,\n            stack: s\n          }),\n          rj: i\n        }\n      },\n      page: s.page,\n      defer: 1\n    });\n  };\n\n  if (r) {\n    let e;\n    W(r) ? (e = r, Ae(r, [l])) : (e = p(r), Ae(l, [e]));\n    let t = ne({\n      from: I,\n      store: be(e),\n      to: \"a\"\n    });\n    s = [ie({\n      fn: e => e\n    }), t, se({\n      fn: f\n    })], Re(t, i.reg);\n  } else s = [ie({\n    fn: f\n  })];\n\n  return Ae(a, [l]), i.scope.effect = a, i.meta.onCopy.push(\"effect\"), i.seq.splice(0, 1, ...s), mt(a, l, \"effect\"), l;\n}\n\nfunction g(...e) {\n  let [[t, r], a] = et(e),\n      n = {};\n  return i(r, (e, r) => {\n    let o = n[r] = c(r, {\n      parent: xe(t),\n      config: a\n    });\n    t.on(o, e), mt(t, o);\n  }), n;\n}\n\nfunction y(e, t) {\n  let r = new Set(),\n      n = new Set(),\n      o = new Set(),\n      s = new Set(),\n      l = a({\n    family: {\n      type: \"domain\"\n    },\n    regional: 1\n  }),\n      f = {\n    history: {\n      domains: r,\n      stores: n,\n      effects: o,\n      events: s\n    },\n    graphite: l\n  };\n  l.meta = ht(\"domain\", f, t, e);\n  let [p, d, h, g] = ['onEvent', 'onEffect', 'onStore', 'onDomain'].map(gt);\n  f.hooks = {\n    event: p,\n    effect: d,\n    store: h,\n    domain: g\n  }, f.onCreateEvent = xt(p, s, f), f.onCreateEffect = xt(d, o, f), f.onCreateStore = xt(h, n, f), f.onCreateDomain = xt(g, r, f), f.createEvent = f.event = (e, t) => p(c(e, {\n    parent: f,\n    config: t\n  })), f.createEffect = f.effect = (e, t) => d(m(e, {\n    parent: f,\n    config: t\n  })), f.createDomain = f.domain = (e, t) => y({\n    name: e,\n    parent: f,\n    config: t\n  }), f.createStore = f.store = (e, t) => h(u(e, {\n    parent: f,\n    config: t\n  }));\n  let k = xe(f);\n  return k && (i(f.hooks, (e, t) => {\n    ct({\n      from: e,\n      to: k.hooks[t]\n    });\n  }), k.hooks.domain(f)), f;\n}\n\nfunction k(e) {\n  K(e);\n  let t = _ in e ? e[_]() : e;\n  t.subscribe || B('expect observable to have .subscribe');\n  let r = c(),\n      a = ee(st, r, void 0);\n  return t.subscribe({\n    next: r,\n    error: a,\n    complete: a\n  }), r;\n}\n\nfunction b(e, r) {\n  let a = c(r || o(e, 'merge'));\n  return t(e, 'merge', 'first argument'), ct({\n    from: e,\n    to: a,\n    meta: {\n      op: 'merge'\n    }\n  }), a;\n}\n\nfunction v(...e) {\n  let r,\n      n,\n      o,\n      s,\n      [[l, i, d], m] = et(e);\n  void 0 === i && V(l) && (e => {\n    let t = 0;\n    return f(Nt, r => {\n      r in e && (null == e[r] && B(`sample: ${r} should be defined`), t = 1);\n    }), t;\n  })(l) && (i = l.clock, d = l.fn, s = l.greedy, r = l.target, n = l.name, o = l.sid, l = l.source);\n  let h = 1;\n  void 0 === l && (t(i, 'sample', 'clock'), Array.isArray(i) && (i = b(i)), l = i, h = 0), h && !E(l) && (l = p(l)), void 0 === i && (i = l), t(i, 'sample', 'clock'), n = m || n || l.shortName;\n  let g = je(),\n      y = !!r;\n  r || (W(l) && W(i) ? r = u(d ? d(pe(be(l)), pe(be(i))) : pe(be(l)), {\n    name: n,\n    sid: o\n  }) : (r = c(n), g && ge(r).seq.push(g.loader)));\n  let k = y && E(r) && ge(r).meta.nativeTemplate;\n\n  if (W(l)) {\n    let e = be(l);\n    Ae(l, [ft(i, r, {\n      scope: {\n        fn: d,\n        targetTemplate: k\n      },\n      node: [g && g.loader, !s && ae({\n        priority: \"sampler\"\n      }), ne({\n        store: e,\n        to: d ? \"a\" : \"stack\"\n      }), d && se({\n        fn: me\n      }), g && y && g.upward],\n      meta: {\n        op: \"sample\",\n        sample: I\n      }\n    })]), g && (tt(g.plain, e) || tt(g.closure, e) || g.closure.push(e));\n  } else {\n    let e = ue(0),\n        t = ue(),\n        n = ue();\n    g && g.plain.push(e, t, n), a({\n      parent: l,\n      node: [fe({\n        store: t\n      }), ne({\n        from: \"value\",\n        store: 1,\n        target: e\n      })],\n      family: {\n        owners: [l, r, i],\n        links: r\n      },\n      meta: {\n        op: \"sample\",\n        sample: 'source'\n      },\n      regional: 1\n    }), Ae(l, [ft(i, r, {\n      scope: {\n        fn: d,\n        targetTemplate: k\n      },\n      node: [g && g.loader, fe({\n        store: n\n      }), ne({\n        store: e\n      }), le({\n        fn: e => e\n      }), !s && ae({\n        priority: \"sampler\"\n      }), ne({\n        store: t\n      }), ne({\n        store: n,\n        to: \"a\"\n      }), d && se({\n        fn: de\n      }), g && y && g.upward],\n      meta: {\n        op: \"sample\",\n        sample: 'clock'\n      }\n    })]);\n  }\n\n  return r;\n}\n\nfunction w(...e) {\n  let r = {\n    op: 'guard'\n  },\n      n = 'guard',\n      [[o, s], l] = et(e);\n  l && (r.config = l, l.name && (n = l.name)), s || (s = o, o = s.source);\n  let {\n    filter: i,\n    greedy: f,\n    clock: u,\n    name: d = n\n  } = s,\n      m = s.target || c(d, r.config),\n      h = E(i),\n      g = 1;\n  return void 0 === o && (t(u, 'guard', 'clock'), Array.isArray(u) && (u = b(u)), o = u, g = 0), g && !E(o) && (o = p(o)), u && (t(u, 'guard', 'clock'), o = v({\n    source: o,\n    clock: u,\n    greedy: f,\n    fn: h ? null : (e, t) => ({\n      source: e,\n      clock: t\n    })\n  })), t(m, 'guard', 'target'), h ? v({\n    source: i,\n    clock: o,\n    target: a({\n      node: [le({\n        fn: ({\n          guard: e\n        }) => e\n      }), se({\n        fn: ({\n          data: e\n        }) => e\n      })],\n      child: m,\n      meta: r,\n      family: {\n        owners: [o, i, m, ...[].concat(u || [])],\n        links: m\n      },\n      regional: 1\n    }),\n    fn: (e, t) => ({\n      guard: e,\n      data: t\n    }),\n    greedy: f,\n    name: d\n  }) : (J(i) || B('`filter` should be function or unit'), ft(o, m, {\n    scope: {\n      fn: i\n    },\n    node: u ? [le({\n      fn: ({\n        source: e,\n        clock: t\n      }, {\n        fn: r\n      }) => r(e, t)\n    }), se({\n      fn: ({\n        source: e\n      }) => e\n    })] : [le({\n      fn: he\n    })],\n    meta: r\n  })), m;\n}\n\nfunction S(e, t, r) {\n  if (W(e)) return e;\n\n  if (E(e)) {\n    let a,\n        n = xe(e);\n    return T(e) && (a = u(t, {\n      parent: n,\n      name: e.shortName,\n      ɔ: r\n    }).on(e, (e, t) => t)), H(e) && (a = u(t, {\n      parent: n,\n      name: e.shortName,\n      ɔ: r\n    }).on(e.done, (e, {\n      result: t\n    }) => t)), n && n.hooks.store(a), a;\n  }\n\n  let a = Array.isArray(e) ? [] : {};\n  return i(e, (e, t) => {\n    a[t] = W(e) ? e : u(e, {\n      name: t\n    });\n  }), a;\n}\n\nfunction q(...e) {\n  let t,\n      [[r, n], o] = et(e),\n      s = !n;\n  s && (t = r.cases, n = r.match, r = r.source);\n  let l = W(n),\n      f = !E(n) && J(n),\n      u = !l && !f && V(n);\n  t || (t = {}), s || (u || B('match should be an object'), i(n, (e, r) => {\n    t[r] = c(o);\n  }), t.__ = c(o));\n  let p,\n      d = je(),\n      m = new Set([].concat(r, Object.values(t))),\n      h = Object.keys(l || f ? t : n);\n  if (l || f) l && m.add(n), p = [l && ae({\n    priority: 'sampler'\n  }), l && ne({\n    store: be(n),\n    to: 'a'\n  }), le({\n    fn(e, t, r) {\n      let a = String(l ? r.a : n(e));\n      At(t, tt(h, a) ? a : '__', e, r);\n    }\n\n  })];else if (u) {\n    let e = ue({});\n    e.type = 'shape';\n    let t,\n        r = e.before = [],\n        a = [ne({\n      store: e,\n      to: \"a\"\n    }), se({\n      fn(e, {\n        key: t\n      }, {\n        a: r\n      }) {\n        r[t] = e;\n      }\n\n    })],\n        o = [];\n    i(n, (n, s) => {\n      if (E(n)) {\n        t = 1, o.push(s), m.add(n);\n        let l = ft(n, [], {\n          node: a,\n          scope: {\n            key: s\n          }\n        });\n\n        if (W(n)) {\n          e.current[s] = n.getState();\n          let t = be(n);\n          r.push({\n            type: 'field',\n            field: s,\n            from: t\n          }), d && (tt(d.plain, t) || l.seq.unshift(d.loader));\n        }\n      }\n    }), t && d && d.plain.push(e), p = [t && ae({\n      priority: 'sampler'\n    }), t && ne({\n      store: e,\n      to: 'a'\n    }), le({\n      fn(e, t, r) {\n        for (let a = 0; a < h.length; a++) {\n          let s = h[a];\n          if (tt(o, s) ? r.a[s] : n[s](e)) return void At(t, s, e, r);\n        }\n\n        At(t, '__', e, r);\n      }\n\n    })];\n  } else B('expect match to be unit, function or object');\n  if (a({\n    meta: {\n      onCopy: Object.keys(t),\n      op: 'split'\n    },\n    parent: r,\n    scope: t,\n    node: p,\n    family: {\n      type: 'crosslink',\n      owners: Array.from(m)\n    },\n    regional: 1\n  }), !s) return t;\n}\n\nfunction x(e, {\n  values: t\n}) {\n  let r = V(e) && e.cloneOf;\n  G(e) || r || B('first argument of hydrate should be domain or scope'), V(t) || B('values property should be an object');\n  let a,\n      o,\n      s = j(t);\n  if (r) a = [], o = [], i(s, (t, r) => {\n    let n = e.sidMap[r];\n    n && (a.push(n), o.push(t), e.changedStores.add(n.meta.forkOf.id));\n  });else {\n    let t = (({\n      flatGraphUnits: e,\n      values: t,\n      collectWatches: r\n    }) => {\n      let a = [],\n          n = [],\n          o = {},\n          s = new Set(),\n          l = Object.getOwnPropertyNames(t);\n      return f(e, e => {\n        let {\n          reg: f\n        } = e,\n            {\n          op: c,\n          unit: u,\n          sid: p\n        } = e.meta;\n\n        if (u === I && p && tt(l, p)) {\n          let {\n            state: r\n          } = e.scope;\n          r.current = t[p], s.add(r);\n        }\n\n        if (r && 'watch' === c) {\n          let t = e.family.owners[0];\n          t.meta.unit === I && (a.push(e), n.push(t.scope.state));\n        }\n\n        i(f, (e, t) => {\n          o[t] = e;\n        });\n      }), f(P(N(o)), e => {\n        (e => {\n          let t = 0;\n          if (e.before && !s.has(e) && f(e.before, r => {\n            switch (r.type) {\n              case $:\n                e.current = r.fn(r.from.current);\n                break;\n\n              case 'field':\n                {\n                  let a = r.from;\n                  t || (t = 1, e.current = Array.isArray(e.current) ? [...e.current] : { ...e.current\n                  }), e.current[r.field] = a.current;\n                  break;\n                }\n            }\n          }), !e.after) return;\n          let r = e.current;\n          f(e.after, e => {\n            let t = e.to;\n\n            switch (e.type) {\n              case 'copy':\n                t.current = r;\n                break;\n\n              case $:\n                t.current = e.fn(r);\n            }\n          });\n        })(o[e]);\n      }), {\n        storeWatches: a,\n        storeWatchesRefs: n\n      };\n    })({\n      flatGraphUnits: R(e),\n      values: s,\n      collectWatches: 1\n    });\n\n    a = t.storeWatches, o = t.storeWatchesRefs.map(({\n      current: e\n    }) => e);\n  }\n  n({\n    target: a,\n    params: o,\n    forkPage: r ? e : 0\n  });\n}\n\nfunction N(e) {\n  let t = Object.values(e),\n      r = {};\n  return f(t, ({\n    id: e\n  }) => {\n    r[e] = [];\n  }), f(t, ({\n    id: e,\n    before: t,\n    after: a\n  }) => {\n    t && f(t, t => {\n      r[t.from.id].push(e);\n    }), a && f(a, t => {\n      r[e].push(t.to.id);\n    });\n  }), r;\n}\n\nfunction A({\n  clones: e,\n  changedStores: t\n}, {\n  ignore: r = [],\n  onlyChanges: a\n} = {}) {\n  let n = {};\n  return f(e, ({\n    meta: e,\n    scope: r,\n    reg: o\n  }) => {\n    if (e.unit !== I) return;\n    let {\n      sid: s\n    } = e;\n    s && (!a && !e.isCombine || t.has(e.forkOf.id)) && (n[s] = o[r.state.id].current);\n  }), f(r, ({\n    sid: e\n  }) => {\n    e && delete n[e];\n  }), n;\n}\n\nfunction C(e) {\n  He || B('scopeBind cannot be called outside of forked .watch');\n  let t = He,\n      r = He.find(e);\n  return H(e) ? e => {\n    let a = d();\n    n({\n      target: r,\n      params: {\n        params: e,\n        req: a\n      },\n      forkPage: t\n    });\n  } : e => (n({\n    target: r,\n    params: e,\n    forkPage: t\n  }), e);\n}\n\nfunction j(e, t = () => {}) {\n  if (e instanceof Map) {\n    let r = {};\n\n    for (let [a, n] of e) E(a) || B('Map key should be a unit'), t(a, n), r[a.sid] = n;\n\n    return r;\n  }\n\n  return e;\n}\n\nfunction O(e, {\n  values: t,\n  handlers: r\n} = {}) {\n  G(e) || B('first argument of fork should be domain');\n  let n = !!t;\n  t = j(t || {}, e => !W(e) && B('Values map can contain only stores as keys'));\n\n  let o = (e => {\n    function t(e) {\n      let t = ge(e),\n          a = r.indexOf(t);\n\n      if (-1 === a) {\n        let r = 'unit';\n        e !== t && e.id !== e.shortName && (r = e.shortName), B(`${r} not found in forked scope`);\n      }\n\n      return p[a];\n    }\n\n    let r = R(e),\n        n = new Map(),\n        o = new Set(),\n        s = se({\n      fn: (e, t, r) => ((!r.node.meta.isCombine || xe(r) && 'combine' !== xe(r).node.meta.op) && o.add(r.node.meta.forkOf.id), e)\n    }),\n        l = a({\n      scope: {\n        defers: [],\n        inFlight: 0,\n        fxID: 0\n      },\n      node: [se({\n        fn(e, t, r) {\n          r.parent ? 'finally' === r.parent.node.meta.named ? t.inFlight -= 1 : (t.inFlight += 1, t.fxID += 1) : t.fxID += 1;\n        }\n\n      }), ae({\n        priority: \"sampler\"\n      }), ie({\n        fn(e, t) {\n          let {\n            inFlight: r,\n            defers: a,\n            fxID: n\n          } = t;\n          r > 0 || 0 === a.length || Promise.resolve().then(() => {\n            t.fxID === n && f(a.splice(0, a.length), e => {\n              Ve(e.parentFork), e.rs(e.value);\n            });\n          });\n        }\n\n      })],\n      meta: {\n        unit: \"forkInFlightCounter\"\n      }\n    }),\n        c = {},\n        u = {},\n        p = r.map(e => {\n      let {\n        seq: t,\n        next: r,\n        meta: n,\n        scope: o\n      } = e,\n          s = a({\n        node: t.map(e => ({\n          id: e.id,\n          type: e.type,\n          data: { ...e.data\n          },\n          hasRef: e.hasRef\n        })),\n        child: [...r],\n        meta: {\n          forkOf: e,\n          ...n\n        },\n        scope: { ...o\n        }\n      });\n      return s.family = {\n        type: e.family.type,\n        links: [...ke(e)],\n        owners: [...ye(e)]\n      }, c[e.id] = s, n.sid && (u[n.sid] = s), s;\n    }),\n        d = {};\n    return f(p, e => {\n      let {\n        reg: r,\n        scope: a,\n        meta: {\n          onCopy: o,\n          op: c,\n          unit: u\n        }\n      } = e;\n\n      switch (i(r, (e, t) => {\n        let a = n.get(e);\n        a || (a = {\n          id: e.id,\n          current: e.current\n        }, n.set(e, a)), d[t] = r[t] = a;\n      }), o && f(o, e => {\n        let r = a[e];\n        a[e] = Array.isArray(r) ? r.map(t) : t(r);\n      }), D(e, (e, r, a) => {\n        a[r] = t(e);\n      }), c || u) {\n        case I:\n          e.meta.wrapped = (e => ({\n            kind: I,\n            getState: () => e.reg[e.scope.state.id].current,\n            updates: {\n              watch: Z(ut, e)\n            },\n            graphite: e,\n            family: e.family\n          }))(e), e.meta.sid && e.seq.push(s);\n          break;\n\n        case M:\n          e.next.push(l);\n          break;\n\n        case 'fx':\n          a.finally.next.push(l);\n      }\n    }), {\n      cloneOf: e,\n      changedStores: o,\n      nodeMap: c,\n      sidMap: u,\n      clones: p,\n      find: t,\n      reg: d,\n      getState: e => t(e).meta.wrapped.getState(),\n      graphite: a({\n        family: {\n          type: \"domain\",\n          links: [l, ...p]\n        },\n        meta: {\n          unit: 'fork'\n        },\n        scope: {\n          forkInFlightCounter: l\n        }\n      })\n    };\n  })(e);\n\n  if (n && (() => {\n    let r = R(e),\n        a = {},\n        n = {},\n        s = new Set(),\n        l = new Set(),\n        c = Object.getOwnPropertyNames(t);\n    f(r, ({\n      reg: e,\n      meta: t\n    }) => {\n      let {\n        nativeTemplate: r\n      } = t;\n      i(e, (e, t) => {\n        a[t] = e, r && l.add(t);\n      });\n    }), f(o.clones, e => {\n      let {\n        reg: r\n      } = e,\n          {\n        unit: a,\n        sid: l\n      } = e.meta;\n\n      if (a === I && l && tt(c, l)) {\n        let {\n          state: a\n        } = e.scope;\n        r[a.id].current = t[l], s.add(a), o.changedStores.add(e.meta.forkOf.id);\n      }\n\n      i(r, (e, t) => {\n        n[t] = e;\n      });\n    }), f(P(N(a), l), e => {\n      ((e, t) => {\n        let r = 0;\n        if (t && t.before && !s.has(e) && f(t.before, t => {\n          switch (t.type) {\n            case $:\n              e.current = t.fn(n[t.from.id].current);\n              break;\n\n            case 'field':\n              {\n                let a = n[t.from.id];\n                r || (r = 1, e.current = Array.isArray(e.current) ? [...e.current] : { ...e.current\n                }), e.current[t.field] = a.current;\n                break;\n              }\n          }\n        }), !t || !t.after) return;\n        let a = e.current;\n        f(t.after, e => {\n          let t = n[e.to.id];\n\n          switch (e.type) {\n            case 'copy':\n              t.current = a;\n              break;\n\n            case $:\n              t.current = e.fn(a);\n          }\n        });\n      })(n[e], a[e]);\n    });\n  })(), r) {\n    r = j(r, e => !H(e) && B(\"Handlers map can contain only effects as keys\"));\n    let e = Object.keys(r);\n    f(o.clones, ({\n      scope: t,\n      meta: a\n    }) => {\n      a.sid && tt(e, a.sid) && (t.runner.scope.getHandler = () => r[a.sid]);\n    });\n  }\n\n  return o;\n}\n\nfunction P(e, t) {\n  function r(e) {\n    s[e] = 1;\n    let t = a[e];\n\n    for (let e = 0; e < t.length; e++) {\n      let a = t[e];\n      s[a] || o[a] || r(a);\n    }\n\n    s[e] = 0, o[e] = 1, n.push(e);\n  }\n\n  let a = {};\n\n  for (let t in e) a[t] = [...new Set(e[t])];\n\n  let n = [],\n      o = {},\n      s = {};\n\n  for (let e in a) o[e] || s[e] || r(e);\n\n  if (n.reverse(), t && t.size > 0) {\n    let e,\n        r = [],\n        o = [...t];\n\n    for (; e = o.shift();) r.push(e), f(a[e], e => {\n      tt(r, e) || tt(o, e) || o.push(e);\n    });\n\n    f(r, e => {\n      rt(n, e);\n    });\n  }\n\n  return n;\n}\n\nfunction F(e, {\n  scope: t,\n  params: r\n}) {\n  if (!E(e)) return Promise.reject(Error('first argument should be unit'));\n  let a = d();\n  a.parentFork = He;\n  let {\n    forkInFlightCounter: o\n  } = t.graphite.scope;\n  o.scope.defers.push(a);\n  let s = [t.find(e)],\n      l = [];\n  return H(e) ? l.push({\n    params: r,\n    req: {\n      rs(e) {\n        a.value = {\n          status: 'done',\n          value: e\n        };\n      },\n\n      rj(e) {\n        a.value = {\n          status: 'fail',\n          value: e\n        };\n      }\n\n    }\n  }) : l.push(r), s.push(o), l.push(null), n({\n    target: s,\n    params: l,\n    forkPage: t\n  }), a.req;\n}\n\nfunction R(e) {\n  let t = [];\n  return function e(r) {\n    tt(t, r) || (t.push(r), D(r, e));\n  }(ge(e)), t;\n}\n\nfunction D(e, t) {\n  let r = e.meta.unit;\n  'fork' !== r && \"forkInFlightCounter\" !== r && (f(e.next, t), f(ye(e), t), f(ke(e), t));\n}\n\nlet _ = 'undefined' != typeof Symbol && Symbol.observable || '@@observable',\n    I = 'store',\n    M = 'effect',\n    $ = 'map',\n    E = e => (J(e) || V(e)) && 'kind' in e;\n\nconst z = e => t => E(t) && t.kind === e;\n\nlet W = z(I),\n    T = z(\"event\"),\n    H = z(M),\n    G = z(\"domain\");\nvar U = {\n  __proto__: null,\n  unit: E,\n  store: W,\n  event: T,\n  effect: H,\n  domain: G\n};\n\nlet B = e => {\n  throw Error(e);\n},\n    V = e => 'object' == typeof e && null !== e,\n    J = e => 'function' == typeof e,\n    K = e => {\n  V(e) || J(e) || B('expect first argument be an object');\n};\n\nconst L = () => {\n  let e = 0;\n  return () => (++e).toString(36);\n};\n\nlet Q = L(),\n    X = L(),\n    Y = L(),\n    Z = (e, t) => e.bind(null, t),\n    ee = (e, t, r) => e.bind(null, t, r);\n\nconst te = (e, t, r) => ({\n  id: X(),\n  type: e,\n  data: r,\n  hasRef: t\n});\n\nlet re = 0,\n    ae = ({\n  priority: e = \"barrier\"\n}) => te(\"barrier\", 0, {\n  barrierID: ++re,\n  priority: e\n}),\n    ne = ({\n  from: e = I,\n  store: t,\n  target: r,\n  to: a = r ? I : \"stack\"\n}) => te('mov', e === I, {\n  from: e,\n  store: t,\n  to: a,\n  target: r\n}),\n    oe = {\n  defined: () => te('check', 0, {\n    type: 'defined'\n  }),\n  changed: ({\n    store: e\n  }) => te('check', 1, {\n    type: 'changed',\n    store: e\n  })\n},\n    se = ee(te, 'compute', 0),\n    le = ee(te, \"filter\", 0),\n    ie = ee(te, 'run', 0),\n    fe = ({\n  store: e\n}) => ne({\n  from: \"stack\",\n  target: e\n});\n\nvar ce = {\n  __proto__: null,\n  barrier: ae,\n  mov: ne,\n  check: oe,\n  compute: se,\n  filter: le,\n  run: ie,\n  update: fe\n};\n\nlet ue = e => ({\n  id: X(),\n  current: e\n}),\n    pe = ({\n  current: e\n}) => e,\n    de = (e, {\n  fn: t\n}, {\n  a: r\n}) => t(e, r),\n    me = (e, {\n  fn: t\n}, {\n  a: r\n}) => t(r, e),\n    he = (e, {\n  fn: t\n}) => t(e),\n    ge = e => e.graphite || e,\n    ye = e => e.family.owners,\n    ke = e => e.family.links,\n    be = e => e.stateRef,\n    ve = e => e.config,\n    we = e => e.ɔ,\n    Se = e => e.value,\n    qe = e => e.subscribers,\n    xe = e => e.parent,\n    Ne = e => e.forkPage,\n    Ae = (e, t) => {\n  let r = ge(e);\n\n  for (let e = 0; e < t.length; e++) {\n    let a = ge(t[e]);\n    \"domain\" !== r.family.type && (a.family.type = \"crosslink\"), ye(a).push(r), ke(r).push(a);\n  }\n},\n    Ce = null,\n    je = () => Ce && Ce.template,\n    Oe = e => (e && Ce && Ce.sidRoot && (e = `${Ce.sidRoot}ɔ${e}`), e),\n    Pe = ({\n  sid: e,\n  name: t,\n  loc: n,\n  method: o,\n  fn: s\n}) => r(a({\n  meta: {\n    sidRoot: Oe(e),\n    name: t,\n    loc: n,\n    method: o\n  }\n}), s);\n\nconst Fe = (e = []) => {\n  let t = [];\n  if (Array.isArray(e)) for (let r = 0; r < e.length; r++) Array.isArray(e[r]) ? t.push(...e[r]) : t.push(e[r]);else t.push(e);\n  return t.map(ge);\n};\n\nlet Re = ({\n  hasRef: e,\n  type: t,\n  data: r\n}, a) => {\n  let n;\n  e && (n = r.store, a[n.id] = n), 'mov' === t && r.to === I && (n = r.target, a[n.id] = n);\n},\n    De = null;\n\nconst _e = (e, t) => {\n  if (!e) return t;\n  if (!t) return e;\n  let r,\n      a = e.v.type === t.v.type;\n  return (a && e.v.id > t.v.id || !a && \"sampler\" === e.v.type) && (r = e, e = t, t = r), r = _e(e.r, t), e.r = e.l, e.l = r, e;\n},\n      Ie = [];\n\nlet Me = 0;\n\nfor (; Me < 5;) Ie.push({\n  first: null,\n  last: null,\n  size: 0\n}), Me += 1;\n\nconst $e = () => {\n  for (let e = 0; e < 5; e++) {\n    let t = Ie[e];\n\n    if (t.size > 0) {\n      if (2 === e || 3 === e) {\n        t.size -= 1;\n        let e = De.v;\n        return De = _e(De.l, De.r), e;\n      }\n\n      1 === t.size && (t.last = null);\n      let r = t.first;\n      return t.first = r.r, t.size -= 1, r.v;\n    }\n  }\n},\n      Ee = (e, t, r, a, n, o) => ze(0, {\n  a: null,\n  b: null,\n  node: r,\n  parent: a,\n  value: n,\n  page: t,\n  forkPage: o\n}, e),\n      ze = (e, t, r, a = 0) => {\n  let n = We(r),\n      o = Ie[n],\n      s = {\n    v: {\n      idx: e,\n      stack: t,\n      type: r,\n      id: a\n    },\n    l: 0,\n    r: 0\n  };\n  2 === n || 3 === n ? De = _e(De, s) : (0 === o.size ? o.first = s : o.last.r = s, o.last = s), o.size += 1;\n},\n      We = e => {\n  switch (e) {\n    case 'child':\n      return 0;\n\n    case 'pure':\n      return 1;\n\n    case \"barrier\":\n      return 2;\n\n    case \"sampler\":\n      return 3;\n\n    case M:\n      return 4;\n\n    default:\n      return -1;\n  }\n},\n      Te = new Set();\n\nlet He,\n    Ge = 1,\n    Ue = 0,\n    Be = null,\n    Ve = e => {\n  He = e;\n},\n    Je = e => {\n  Be = e;\n};\n\nconst Ke = (e, t) => {\n  if (e) {\n    for (; e && !e.reg[t];) e = xe(e);\n\n    if (e) return e;\n  }\n\n  return null;\n},\n      Le = (e, t, r) => (Ke(e, r) || t).reg[r],\n      Qe = (e, {\n  fn: t\n}, r) => {\n  try {\n    return t(Se(r), e.scope, r);\n  } catch (t) {\n    console.error(t), e.fail = 1;\n  }\n};\n\nlet Xe = (e, t) => '' + e.shortName + t,\n    Ye = (e, t) => null == t ? Xe(e, ' → *') : t,\n    Ze = (e, t) => {\n  K(e), we(e) && t(ve(e), we(e));\n},\n    et = e => {\n  let t;\n  return Ze(e[0], (r, a) => {\n    t = r, e = a;\n  }), [e, t];\n},\n    tt = (e, t) => e.includes(t),\n    rt = (e, t) => {\n  let r = e.indexOf(t);\n  -1 !== r && e.splice(r, 1);\n};\n\nconst at = (e, t) => {\n  rt(e.next, t), rt(ye(e), t), rt(ke(e), t);\n},\n      nt = (e, t, r) => {\n  let a;\n  e.next.length = 0, e.seq.length = 0, e.scope = null;\n  let n = ke(e);\n\n  for (; a = n.pop();) at(a, e), (t || r && !e.meta.sample || \"crosslink\" === a.family.type) && nt(a, t, 'on' !== a.meta.op && r);\n\n  for (n = ye(e); a = n.pop();) at(a, e), r && \"crosslink\" === a.family.type && nt(a, t, 'on' !== a.meta.op && r);\n},\n      ot = e => e.clear();\n\nlet st = (e, {\n  deep: t\n} = {}) => {\n  let r = 0;\n  if (e.ownerSet && e.ownerSet.delete(e), W(e)) ot(qe(e));else if (G(e)) {\n    r = 1;\n    let t = e.history;\n    ot(t.events), ot(t.effects), ot(t.stores), ot(t.domains);\n  }\n  nt(ge(e), !!t, r);\n},\n    lt = e => {\n  let t = ee(st, e, void 0);\n  return t.unsubscribe = t, t;\n},\n    ft = (e, t, {\n  node: r,\n  scope: n,\n  meta: o\n}) => a({\n  node: r,\n  parent: e,\n  child: t,\n  scope: n,\n  meta: o,\n  family: {\n    owners: [e, t],\n    links: t\n  },\n  regional: 1\n}),\n    ct = e => {\n  let r;\n  Ze(e, (t, a) => {\n    r = t, e = a;\n  });\n  let {\n    from: n,\n    to: o,\n    meta: s = {\n      op: 'forward'\n    }\n  } = e;\n  return t(n, 'forward', '\"from\"'), t(o, 'forward', '\"to\"'), r && (s.config = r), lt(a({\n    parent: n,\n    child: o,\n    meta: s,\n    family: {},\n    regional: 1\n  }));\n},\n    ut = (e, t) => {\n  if (J(t) || B('.watch argument should be a function'), He) {\n    let t = He.nodeMap[ge(e).id];\n    t && (e = t);\n  }\n\n  return lt(a({\n    scope: {\n      fn: t\n    },\n    node: [ie({\n      fn: he\n    })],\n    parent: e,\n    meta: {\n      op: 'watch'\n    },\n    family: {\n      owners: e\n    },\n    regional: 1\n  }));\n};\n\nconst pt = (e, t) => (V(e) && (pt(ve(e), t), null != e.name && (V(e.name) ? pt(e.name, t) : J(e.name) ? t.handler = e.name : t.name = e.name), e.loc && (t.loc = e.loc), (e.sid || null === e.sid) && (t.sid = e.sid), e.handler && (t.handler = e.handler), e.updateFilter && (t.updateFilter = e.updateFilter), xe(e) && (t.parent = xe(e)), 'strict' in e && (t.strict = e.strict), e.named && (t.named = e.named), pt(we(e), t)), t);\n\nlet dt,\n    mt = (e, t, r = \"event\") => {\n  xe(e) && xe(e).hooks[r](t);\n},\n    ht = (e, t, r, a) => {\n  let n = pt({\n    name: a,\n    config: r\n  }, {}),\n      o = \"domain\" === e,\n      s = Q(),\n      {\n    parent: i = null,\n    sid: f = null,\n    strict: c = 1,\n    named: u = null\n  } = n,\n      p = u || n.name || (o ? '' : s),\n      d = l(p, i),\n      m = {\n    unit: t.kind = e,\n    name: t.shortName = p,\n    sid: t.sid = Oe(f),\n    named: u,\n    unitId: t.id = s\n  };\n\n  if (t.parent = i, t.compositeName = d, t.defaultConfig = n, t.thru = e => e(t), t.getType = () => d.fullName, !o) {\n    t.subscribe = e => (K(e), t.watch(J(e) ? e : t => {\n      e.next && e.next(t);\n    })), t[_] = () => t;\n    let e = je();\n    e && (m.nativeTemplate = e);\n  }\n\n  return dt = c, m;\n},\n    gt = e => c({\n  named: e\n});\n\nconst yt = (e, t, r, a) => ft(e, t, {\n  scope: {\n    fn: a\n  },\n  node: [se({\n    fn: he\n  })],\n  meta: {\n    op: r\n  }\n}),\n      kt = (e, t, r, a) => {\n  let n;\n  V(r) && (n = r, r = r.fn);\n  let o = c(Xe(e, ' →? *'), n);\n  return ft(e, o, {\n    scope: {\n      fn: r\n    },\n    node: a,\n    meta: {\n      op: t\n    }\n  }), o;\n},\n      bt = (e, t, r, a, n, o) => {\n  let s = be(t),\n      l = [ne({\n    store: s,\n    to: \"a\"\n  }), se({\n    fn: a ? me : de\n  }), oe.defined(), oe.changed({\n    store: s\n  }), o && le({\n    fn: (e, t, {\n      a: r\n    }) => o(e, r)\n  }), fe({\n    store: s\n  })],\n      i = je();\n\n  if (i && (l.unshift(i.loader), l.push(i.upward), W(e))) {\n    let t = be(e);\n    tt(i.plain, t) || (tt(i.closure, t) || i.closure.push(t), s.before || (s.before = []), s.before.push({\n      type: 'closure',\n      of: t\n    }));\n  }\n\n  return ft(e, t, {\n    scope: {\n      fn: n\n    },\n    node: l,\n    meta: {\n      op: r\n    }\n  });\n},\n      vt = e => t => e(...t),\n      wt = (e, t, r, a) => {\n  let n = e ? e => e.slice() : e => ({ ...e\n  }),\n      s = e ? [] : {},\n      l = je(),\n      f = n(s),\n      c = ue(f),\n      p = ue(1);\n  c.type = e ? 'list' : 'shape', l && l.plain.push(c, p);\n  let d = u(f, {\n    name: r || o(t)\n  });\n  ge(d).meta.isCombine = 1;\n  let m = [oe.defined(), ne({\n    store: c,\n    to: \"a\"\n  }), le({\n    fn: (e, {\n      key: t\n    }, {\n      a: r\n    }) => e !== r[t]\n  }), ne({\n    store: p,\n    to: 'b'\n  }), se({\n    fn(e, {\n      clone: t,\n      key: r\n    }, a) {\n      a.b && (a.a = t(a.a)), a.a[r] = e;\n    }\n\n  }), ne({\n    from: \"a\",\n    target: c\n  }), ne({\n    from: \"value\",\n    store: 0,\n    target: p\n  }), ae({\n    priority: \"barrier\"\n  }), ne({\n    from: \"value\",\n    store: 1,\n    target: p\n  }), ne({\n    store: c\n  }), a && se({\n    fn: a\n  }), oe.changed({\n    store: be(d)\n  })],\n      h = c.before = [];\n  return i(t, (e, t) => {\n    if (!W(e)) return void (f[t] = s[t] = e);\n    s[t] = e.defaultState, f[t] = e.getState();\n    let r = ft(e, d, {\n      scope: {\n        key: t,\n        clone: n\n      },\n      node: m,\n      meta: {\n        op: 'combine'\n      }\n    }),\n        a = be(e);\n    h.push({\n      type: 'field',\n      field: t,\n      from: a\n    }), l && (tt(l.plain, a) || r.seq.unshift(l.loader));\n  }), d.defaultShape = t, c.after = [a ? {\n    type: $,\n    to: be(d),\n    fn: a\n  } : {\n    type: 'copy',\n    to: be(d)\n  }], l || (d.defaultState = a ? be(d).current = a(f) : s), d;\n};\n\nlet St = ({\n  params: e,\n  req: t,\n  ok: r,\n  anyway: a,\n  stack: o\n}) => s => n({\n  target: [a, qt],\n  params: [r ? {\n    status: 'done',\n    params: e,\n    result: s\n  } : {\n    status: 'fail',\n    params: e,\n    error: s\n  }, {\n    fn: r ? t.rs : t.rj,\n    value: s\n  }],\n  defer: 1,\n  page: o.page,\n  forkPage: Ne(o)\n}),\n    qt = a({\n  node: [ie({\n    fn({\n      fn: e,\n      value: t\n    }) {\n      e(t);\n    }\n\n  })],\n  meta: {\n    op: 'fx',\n    fx: 'sidechain'\n  }\n});\n\nconst xt = (e, t, r) => (e.create = t => (n(e, t), t), ge(e).seq.push(se({\n  fn: (e, t, r) => (r.forkPage = null, e)\n})), e.watch(e => {\n  Ae(r, [e]), t.add(e), e.ownerSet || (e.ownerSet = t), xe(e) || (e.parent = r);\n}), Ae(r, [e]), r => (t.forEach(r), e.watch(r))),\n      Nt = ['source', 'clock', 'target'],\n      At = (e, t, r, a) => {\n  let o = e[t];\n  o && n({\n    target: o,\n    params: Array.isArray(o) ? o.map(() => r) : r,\n    defer: 1,\n    stack: a\n  });\n},\n      Ct = \"21.8.12\";\n\nexport { F as allSettled, h as attach, st as clearNode, p as combine, g as createApi, y as createDomain, m as createEffect, c as createEvent, a as createNode, u as createStore, p as createStoreObject, O as fork, ct as forward, k as fromObservable, w as guard, x as hydrate, U as is, n as launch, b as merge, S as restore, v as sample, C as scopeBind, A as serialize, s as setStoreName, q as split, ce as step, Ct as version, Pe as withFactory, r as withRegion };","map":null,"metadata":{},"sourceType":"module"}