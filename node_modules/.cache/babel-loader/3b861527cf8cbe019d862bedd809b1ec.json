{"ast":null,"code":"import _objectSpread from \"/Users/zuhriddinkamilzanov/Desktop/t-med(mobile)/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nimport _slicedToArray from \"/Users/zuhriddinkamilzanov/Desktop/t-med(mobile)/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _toConsumableArray from \"/Users/zuhriddinkamilzanov/Desktop/t-med(mobile)/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _createForOfIteratorHelper from \"/Users/zuhriddinkamilzanov/Desktop/t-med(mobile)/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\n\nfunction e(e, t, r, a) {\n  (V(e) || J(e)) && ('family' in e || 'graphite' in e) || B(\"\".concat(t, \": expect \").concat(r, \" to be a unit (store, event or effect)\").concat(a));\n}\n\nfunction t(t, r, a) {\n  if (Array.isArray(t)) for (var _n = 0; _n < t.length; _n++) {\n    e(t[_n], r, \"\".concat(_n, \" item of \").concat(a), '');\n  } else e(t, r, a, ' or array of units');\n}\n\nfunction r(e, t) {\n  var r = ge(e).meta;\n  Ce = {\n    parent: Ce,\n    value: e,\n    template: r.template || je(),\n    sidRoot: r.sidRoot || Ce && Ce.sidRoot\n  };\n\n  try {\n    return t();\n  } finally {\n    Ce = xe(Ce);\n  }\n}\n\nfunction a() {\n  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      _ref$node = _ref.node,\n      e = _ref$node === void 0 ? [] : _ref$node,\n      t = _ref.from,\n      r = _ref.source,\n      _ref$parent = _ref.parent,\n      a = _ref$parent === void 0 ? t || r : _ref$parent,\n      n = _ref.to,\n      o = _ref.target,\n      _ref$child = _ref.child,\n      s = _ref$child === void 0 ? n || o : _ref$child,\n      _ref$scope = _ref.scope,\n      l = _ref$scope === void 0 ? {} : _ref$scope,\n      _ref$meta = _ref.meta,\n      i = _ref$meta === void 0 ? {} : _ref$meta,\n      _ref$family = _ref.family,\n      f = _ref$family === void 0 ? {\n    type: 'regular'\n  } : _ref$family,\n      c = _ref.regional;\n\n  var u = Fe(a),\n      p = Fe(f.links),\n      d = Fe(f.owners),\n      m = [],\n      h = {};\n\n  for (var _t = 0; _t < e.length; _t++) {\n    var _r = e[_t];\n    _r && (m.push(_r), Re(_r, h));\n  }\n\n  var g = {\n    id: Y(),\n    seq: m,\n    next: Fe(s),\n    meta: i,\n    scope: l,\n    family: {\n      type: f.type || \"crosslink\",\n      links: p,\n      owners: d\n    },\n    reg: h\n  };\n\n  for (var _e2 = 0; _e2 < p.length; _e2++) {\n    ye(p[_e2]).push(g);\n  }\n\n  for (var _e3 = 0; _e3 < d.length; _e3++) {\n    ke(d[_e3]).push(g);\n  }\n\n  for (var _e4 = 0; _e4 < u.length; _e4++) {\n    u[_e4].next.push(g);\n  }\n\n  return c && Ce && Ae(Se(Ce), [g]), g;\n}\n\nfunction n(e, t, r) {\n  var a = Be,\n      n = null,\n      o = He;\n  if (e.target && (t = e.params, r = e.defer, a = 'page' in e ? e.page : a, e.stack && (n = e.stack), o = Ne(e) || o, e = e.target), o && He && o !== He && (He = null), Array.isArray(e)) for (var _r2 = 0; _r2 < e.length; _r2++) {\n    Ee('pure', a, ge(e[_r2]), n, t[_r2], o);\n  } else Ee('pure', a, ge(e), n, t, o);\n  if (r && !Ge) return;\n  var s,\n      l,\n      i,\n      f,\n      c,\n      u,\n      p = {\n    isRoot: Ge,\n    currentPage: Be,\n    forkPage: He,\n    isWatch: Ue\n  };\n  Ge = 0;\n\n  e: for (; f = $e();) {\n    var _f = f,\n        _e5 = _f.idx,\n        _t2 = _f.stack,\n        _r3 = _f.type;\n    i = _t2.node, Be = c = _t2.page, He = Ne(_t2), u = (c || i).reg;\n    var _a = {\n      fail: 0,\n      scope: i.scope\n    };\n    s = l = 0;\n\n    for (var _n2 = _e5; _n2 < i.seq.length && !s; _n2++) {\n      var _o = i.seq[_n2],\n          _f2 = _o.data;\n\n      switch (_o.type) {\n        case \"barrier\":\n          {\n            var _a2 = _f2.barrierID;\n            c && (_a2 = \"\".concat(c.fullID, \"_\").concat(_a2));\n            var _o2 = _f2.priority;\n\n            if (_n2 !== _e5 || _r3 !== _o2) {\n              Te.has(_a2) || (Te.add(_a2), ze(_n2, _t2, _o2, _a2));\n              continue e;\n            }\n\n            Te.delete(_a2);\n            break;\n          }\n\n        case 'mov':\n          {\n            var _e6 = void 0;\n\n            switch (_f2.from) {\n              case \"stack\":\n                _e6 = Se(_t2);\n                break;\n\n              case \"a\":\n              case 'b':\n                _e6 = _t2[_f2.from];\n                break;\n\n              case \"value\":\n                _e6 = _f2.store;\n                break;\n\n              case I:\n                u[_f2.store.id] || (_t2.page = c = Ke(c, _f2.store.id), u = c ? c.reg : i.reg), _e6 = pe(u[_f2.store.id]);\n            }\n\n            switch (_f2.to) {\n              case \"stack\":\n                _t2.value = _e6;\n                break;\n\n              case \"a\":\n              case 'b':\n                _t2[_f2.to] = _e6;\n                break;\n\n              case I:\n                Le(c, i, _f2.target.id).current = _e6;\n            }\n\n            break;\n          }\n\n        case 'check':\n          switch (_f2.type) {\n            case 'defined':\n              l = void 0 === Se(_t2);\n              break;\n\n            case 'changed':\n              l = Se(_t2) === pe(Le(c, i, _f2.store.id));\n          }\n\n          break;\n\n        case \"filter\":\n          l = !Qe(_a, _f2, _t2);\n          break;\n\n        case 'run':\n          if (_n2 !== _e5 || \"effect\" !== _r3) {\n            ze(_n2, _t2, \"effect\");\n            continue e;\n          }\n\n        case 'compute':\n          Ue = 'watch' === i.meta.op, _t2.value = Qe(_a, _f2, _t2), Ue = p.isWatch;\n      }\n\n      s = _a.fail || l;\n    }\n\n    if (!s) for (var _e7 = 0; _e7 < i.next.length; _e7++) {\n      Ee('child', c, i.next[_e7], _t2, Se(_t2), Ne(_t2));\n    }\n  }\n\n  Ge = p.isRoot, Be = p.currentPage, He = Ne(p);\n}\n\nfunction o(e) {\n  var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"combine\";\n  var r = t + '(',\n      a = '',\n      n = 0;\n\n  for (var _t3 in e) {\n    var _o3 = e[_t3];\n    if (null != _o3 && (r += a, r += E(_o3) ? _o3.compositeName.fullName : _o3.toString()), n += 1, 25 === n) break;\n    a = ', ';\n  }\n\n  return r += ')', r;\n}\n\nfunction s(e, t) {\n  var r = l(t, xe(e));\n  if (e.shortName = t, !e.compositeName) return void (e.compositeName = r);\n  var a = e.compositeName;\n  a.path = r.path, a.shortName = r.shortName, a.fullName = r.fullName;\n}\n\nfunction l(e, t) {\n  var r,\n      a,\n      n,\n      o = e;\n  return t ? (n = t.compositeName, 0 === e.length ? (r = n.path, a = n.fullName) : (r = n.path.concat([e]), a = 0 === n.fullName.length ? e : n.fullName + '/' + e)) : (r = 0 === e.length ? [] : [e], a = e), {\n    shortName: o,\n    fullName: a,\n    path: r\n  };\n}\n\nfunction i(e, t) {\n  for (var _r4 in e) {\n    t(e[_r4], _r4);\n  }\n}\n\nfunction f(e, t) {\n  e.forEach(t);\n}\n\nfunction c(e, t) {\n  var r = function r(e) {\n    for (var _len = arguments.length, t = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      t[_key - 1] = arguments[_key];\n    }\n\n    return Be ? function (e, t, r, a) {\n      var n = Be,\n          o = null;\n      if (t) for (o = Be; o && o.template !== t;) {\n        o = xe(o);\n      }\n      Je(o);\n      var s = e.create(r, a);\n      return Je(n), s;\n    }(r, o, e, t) : r.create(e, t);\n  };\n\n  r.graphite = a({\n    meta: ht(\"event\", r, t, e),\n    regional: 1\n  }), r.create = function (e) {\n    return n(He ? He.find(r) : r, e), e;\n  }, r.watch = Z(ut, r), r.map = function (e) {\n    var t, a;\n    V(e) && (t = e, a = e.name, e = e.fn);\n    var n = c(Ye(r, a), t);\n    return yt(r, n, $, e), n;\n  }, r.filter = function (e) {\n    return kt(r, \"filter\", e.fn ? e : e.fn, [le({\n      fn: he\n    })]);\n  }, r.filterMap = function (e) {\n    return kt(r, 'filterMap', e, [se({\n      fn: he\n    }), oe.defined()]);\n  }, r.prepend = function (e) {\n    var t = c('* → ' + r.shortName, {\n      parent: xe(r)\n    }),\n        a = je();\n    return a && ge(t).seq.push(a.upward), yt(t, r, 'prepend', e), mt(r, t), t;\n  };\n  var o = je();\n  return r;\n}\n\nfunction u(e, r) {\n  function o(e, t) {\n    p.off(e), qe(p).set(e, lt(bt(e, p, 'on', 1, t, m)));\n  }\n\n  var s = ue(e),\n      l = ue(e),\n      i = gt('updates'),\n      f = je();\n  s.after = [{\n    type: 'copy',\n    to: l\n  }], f && f.plain.push(s, l);\n  var c = s.id,\n      p = {\n    subscribers: new Map(),\n    updates: i,\n    defaultState: e,\n    stateRef: s,\n    getState: function getState() {\n      var e,\n          t = s;\n\n      if (Be) {\n        var _t4 = Be;\n\n        for (; _t4 && !_t4.reg[c];) {\n          _t4 = xe(_t4);\n        }\n\n        _t4 && (e = _t4);\n      }\n\n      return !e && He && He.reg[c] && (e = He), e && (t = e.reg[c]), pe(t);\n    },\n    setState: function setState(e) {\n      var t;\n      He && (t = He.nodeMap[ge(p).id]), t || (t = p), n({\n        target: t,\n        params: e,\n        defer: 1\n      });\n    },\n    reset: function reset() {\n      for (var _len2 = arguments.length, e = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        e[_key2] = arguments[_key2];\n      }\n\n      for (var _i = 0, _e8 = e; _i < _e8.length; _i++) {\n        var _t5 = _e8[_i];\n        p.on(_t5, function () {\n          return p.defaultState;\n        });\n      }\n\n      return p;\n    },\n    on: function on(e, r) {\n      if (t(e, '.on', 'first argument'), Array.isArray(e)) {\n        var _iterator = _createForOfIteratorHelper(e),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var _t6 = _step.value;\n            o(_t6, r);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      } else o(e, r);\n\n      return p;\n    },\n    off: function off(e) {\n      var t = qe(p).get(e);\n      return t && (t(), qe(p).delete(e)), p;\n    },\n    map: function map(e, t) {\n      var r, a, n;\n      V(e) && (r = e, a = e.name, t = e.firstState, e = e.fn);\n      var o = p.getState(),\n          l = je();\n      l ? n = null : void 0 !== o && (n = e(o, t));\n      var i = u(n, {\n        name: Ye(p, a),\n        config: r,\n        strict: 0\n      }),\n          f = bt(p, i, $, 0, e);\n      return be(i).before = [{\n        type: $,\n        fn: e,\n        from: s\n      }], l && (tt(l.plain, s) || tt(f.seq, l.loader) || f.seq.unshift(l.loader)), i;\n    },\n    watch: function watch(e, t) {\n      if (!t || !E(e)) {\n        var _t7 = ut(p, e),\n            _r5 = je();\n\n        return _r5 ? _r5.watch.push({\n          of: s,\n          fn: e\n        }) : e(p.getState()), _t7;\n      }\n\n      return J(t) || B('second argument should be a function'), e.watch(function (e) {\n        return t(p.getState(), e);\n      });\n    }\n  },\n      d = ht(I, p, r),\n      m = p.defaultConfig.updateFilter;\n  return p.graphite = a({\n    scope: {\n      state: s\n    },\n    node: [oe.defined(), oe.changed({\n      store: l\n    }), m && ne({\n      store: l,\n      to: \"a\"\n    }), m && le({\n      fn: function fn(e, t, _ref2) {\n        var r = _ref2.a;\n        return m(e, r);\n      }\n    }), fe({\n      store: s\n    }), fe({\n      store: l\n    })],\n    child: i,\n    meta: d,\n    regional: 1\n  }), dt && void 0 === e && B(\"current state can't be undefined, use null instead\"), Ae(p, [i]), p;\n}\n\nfunction p() {\n  for (var _len3 = arguments.length, e = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n    e[_key3] = arguments[_key3];\n  }\n\n  var t, r, a;\n  Ze(e[0], function (t, r) {\n    a = t, e = r;\n  });\n  var n,\n      o,\n      s = e[e.length - 1];\n\n  if (J(s) ? (r = e.slice(0, -1), t = s) : r = e, 1 === r.length) {\n    var _e9 = r[0];\n    W(_e9) || (n = _e9, o = 1);\n  }\n\n  return o || (n = r, t && (t = vt(t))), V(n) || B('shape should be an object'), wt(Array.isArray(n), n, a, t);\n}\n\nfunction d() {\n  var e = {};\n  return e.req = new Promise(function (t, r) {\n    e.rs = t, e.rj = r;\n  }), e.req.catch(function () {}), e;\n}\n\nfunction m(e, t) {\n  var r = c(e, t),\n      o = r.defaultConfig.handler || function () {\n    return B(\"no handler used in \".concat(r.getType()));\n  },\n      s = ge(r);\n\n  s.meta.onCopy = ['runner'], s.meta.unit = r.kind = \"effect\", r.use = function (e) {\n    return J(e) || B('.use argument should be a function'), o = e, r;\n  };\n  var l = r.finally = gt('finally'),\n      i = r.done = l.filterMap({\n    named: 'done',\n    fn: function fn(_ref3) {\n      var e = _ref3.status,\n          t = _ref3.params,\n          r = _ref3.result;\n      if ('done' === e) return {\n        params: t,\n        result: r\n      };\n    }\n  }),\n      f = r.fail = l.filterMap({\n    named: 'fail',\n    fn: function fn(_ref4) {\n      var e = _ref4.status,\n          t = _ref4.params,\n          r = _ref4.error;\n      if ('fail' === e) return {\n        params: t,\n        error: r\n      };\n    }\n  }),\n      p = r.doneData = i.map({\n    named: 'doneData',\n    fn: function fn(_ref5) {\n      var e = _ref5.result;\n      return e;\n    }\n  }),\n      m = r.failData = f.map({\n    named: 'failData',\n    fn: function fn(_ref6) {\n      var e = _ref6.error;\n      return e;\n    }\n  }),\n      h = a({\n    scope: {\n      getHandler: r.use.getCurrent = function () {\n        return o;\n      },\n      finally: l\n    },\n    node: [ie({\n      fn: function fn(_ref7, _ref8, n) {\n        var e = _ref7.params,\n            t = _ref7.req;\n        var r = _ref8.finally,\n            a = _ref8.getHandler;\n        var o,\n            s = St({\n          params: e,\n          req: t,\n          ok: 1,\n          anyway: r,\n          stack: n\n        }),\n            l = St({\n          params: e,\n          req: t,\n          ok: 0,\n          anyway: r,\n          stack: n\n        });\n\n        try {\n          o = a()(e);\n        } catch (e) {\n          return void l(e);\n        }\n\n        V(o) && J(o.then) ? o.then(s, l) : s(o);\n      }\n    })],\n    meta: {\n      op: 'fx',\n      fx: 'runner',\n      onCopy: ['finally']\n    }\n  });\n  s.scope.runner = h, s.seq.push(se({\n    fn: function fn(e, t, r) {\n      return xe(r) ? {\n        params: e,\n        req: {\n          rs: function rs(e) {},\n          rj: function rj(e) {}\n        }\n      } : e;\n    }\n  }), ie({\n    fn: function fn(e, _ref9, r) {\n      var t = _ref9.runner;\n      return n({\n        target: t,\n        params: e,\n        defer: 1,\n        forkPage: Ne(r)\n      }), e.params;\n    }\n  })), r.create = function (e) {\n    var t = d(),\n        a = {\n      params: e,\n      req: t\n    };\n\n    if (He) {\n      if (!Ue) {\n        var _e10 = He;\n        t.req.finally(function () {\n          Ve(_e10);\n        }).catch(function () {});\n      }\n\n      n(He.find(r), a);\n    } else n(r, a);\n\n    return t.req;\n  };\n  var g = r.inFlight = u(0, {\n    named: 'inFlight'\n  }).on(r, function (e) {\n    return e + 1;\n  }).on(l, function (e) {\n    return e - 1;\n  }),\n      y = r.pending = g.map({\n    fn: function fn(e) {\n      return e > 0;\n    },\n    named: 'pending'\n  });\n  return Ae(r, [l, i, f, p, m, y, g, h]), r;\n}\n\nfunction h(e) {\n  var _i$seq;\n\n  var t;\n  Ze(e, function (r, a) {\n    t = r, e = a;\n  });\n  var _e11 = e,\n      r = _e11.source,\n      a = _e11.effect,\n      o = _e11.mapParams;\n  o || (o = r ? function (e, t) {\n    return t;\n  } : function (e) {\n    return e;\n  });\n\n  var s,\n      l = m(e, t),\n      i = ge(l).scope.runner,\n      f = function f(_ref10, _ref11, s) {\n    var e = _ref10.params,\n        t = _ref10.req;\n    var r = _ref11.finally,\n        a = _ref11.effect;\n    var l,\n        i = St({\n      params: e,\n      req: t,\n      ok: 0,\n      anyway: r,\n      stack: s\n    });\n\n    try {\n      l = o(e, s.a);\n    } catch (e) {\n      return i(e);\n    }\n\n    n({\n      target: a,\n      params: {\n        params: l,\n        req: {\n          rs: St({\n            params: e,\n            req: t,\n            ok: 1,\n            anyway: r,\n            stack: s\n          }),\n          rj: i\n        }\n      },\n      page: s.page,\n      defer: 1\n    });\n  };\n\n  if (r) {\n    var _e12;\n\n    W(r) ? (_e12 = r, Ae(r, [l])) : (_e12 = p(r), Ae(l, [_e12]));\n\n    var _t8 = ne({\n      from: I,\n      store: be(_e12),\n      to: \"a\"\n    });\n\n    s = [ie({\n      fn: function fn(e) {\n        return e;\n      }\n    }), _t8, se({\n      fn: f\n    })], Re(_t8, i.reg);\n  } else s = [ie({\n    fn: f\n  })];\n\n  return Ae(a, [l]), i.scope.effect = a, i.meta.onCopy.push(\"effect\"), (_i$seq = i.seq).splice.apply(_i$seq, [0, 1].concat(_toConsumableArray(s))), mt(a, l, \"effect\"), l;\n}\n\nfunction g() {\n  for (var _len4 = arguments.length, e = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n    e[_key4] = arguments[_key4];\n  }\n\n  var _et = et(e),\n      _et2 = _slicedToArray(_et, 2),\n      _et2$ = _slicedToArray(_et2[0], 2),\n      t = _et2$[0],\n      r = _et2$[1],\n      a = _et2[1],\n      n = {};\n\n  return i(r, function (e, r) {\n    var o = n[r] = c(r, {\n      parent: xe(t),\n      config: a\n    });\n    t.on(o, e), mt(t, o);\n  }), n;\n}\n\nfunction y(e, t) {\n  var r = new Set(),\n      n = new Set(),\n      o = new Set(),\n      s = new Set(),\n      l = a({\n    family: {\n      type: \"domain\"\n    },\n    regional: 1\n  }),\n      f = {\n    history: {\n      domains: r,\n      stores: n,\n      effects: o,\n      events: s\n    },\n    graphite: l\n  };\n  l.meta = ht(\"domain\", f, t, e);\n\n  var _map = ['onEvent', 'onEffect', 'onStore', 'onDomain'].map(gt),\n      _map2 = _slicedToArray(_map, 4),\n      p = _map2[0],\n      d = _map2[1],\n      h = _map2[2],\n      g = _map2[3];\n\n  f.hooks = {\n    event: p,\n    effect: d,\n    store: h,\n    domain: g\n  }, f.onCreateEvent = xt(p, s, f), f.onCreateEffect = xt(d, o, f), f.onCreateStore = xt(h, n, f), f.onCreateDomain = xt(g, r, f), f.createEvent = f.event = function (e, t) {\n    return p(c(e, {\n      parent: f,\n      config: t\n    }));\n  }, f.createEffect = f.effect = function (e, t) {\n    return d(m(e, {\n      parent: f,\n      config: t\n    }));\n  }, f.createDomain = f.domain = function (e, t) {\n    return y({\n      name: e,\n      parent: f,\n      config: t\n    });\n  }, f.createStore = f.store = function (e, t) {\n    return h(u(e, {\n      parent: f,\n      config: t\n    }));\n  };\n  var k = xe(f);\n  return k && (i(f.hooks, function (e, t) {\n    ct({\n      from: e,\n      to: k.hooks[t]\n    });\n  }), k.hooks.domain(f)), f;\n}\n\nfunction k(e) {\n  K(e);\n  var t = _ in e ? e[_]() : e;\n  t.subscribe || B('expect observable to have .subscribe');\n  var r = c(),\n      a = ee(st, r, void 0);\n  return t.subscribe({\n    next: r,\n    error: a,\n    complete: a\n  }), r;\n}\n\nfunction b(e, r) {\n  var a = c(r || o(e, 'merge'));\n  return t(e, 'merge', 'first argument'), ct({\n    from: e,\n    to: a,\n    meta: {\n      op: 'merge'\n    }\n  }), a;\n}\n\nfunction v() {\n  for (var _len5 = arguments.length, e = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n    e[_key5] = arguments[_key5];\n  }\n\n  var r,\n      n,\n      o,\n      s,\n      _et3 = et(e),\n      _et4 = _slicedToArray(_et3, 2),\n      _et4$ = _slicedToArray(_et4[0], 3),\n      l = _et4$[0],\n      i = _et4$[1],\n      d = _et4$[2],\n      m = _et4[1];\n\n  void 0 === i && V(l) && function (e) {\n    var t = 0;\n    return f(Nt, function (r) {\n      r in e && (null == e[r] && B(\"sample: \".concat(r, \" should be defined\")), t = 1);\n    }), t;\n  }(l) && (i = l.clock, d = l.fn, s = l.greedy, r = l.target, n = l.name, o = l.sid, l = l.source);\n  var h = 1;\n  void 0 === l && (t(i, 'sample', 'clock'), Array.isArray(i) && (i = b(i)), l = i, h = 0), h && !E(l) && (l = p(l)), void 0 === i && (i = l), t(i, 'sample', 'clock'), n = m || n || l.shortName;\n  var g = je(),\n      y = !!r;\n  r || (W(l) && W(i) ? r = u(d ? d(pe(be(l)), pe(be(i))) : pe(be(l)), {\n    name: n,\n    sid: o\n  }) : (r = c(n), g && ge(r).seq.push(g.loader)));\n  var k = y && E(r) && ge(r).meta.nativeTemplate;\n\n  if (W(l)) {\n    var _e13 = be(l);\n\n    Ae(l, [ft(i, r, {\n      scope: {\n        fn: d,\n        targetTemplate: k\n      },\n      node: [g && g.loader, !s && ae({\n        priority: \"sampler\"\n      }), ne({\n        store: _e13,\n        to: d ? \"a\" : \"stack\"\n      }), d && se({\n        fn: me\n      }), g && y && g.upward],\n      meta: {\n        op: \"sample\",\n        sample: I\n      }\n    })]), g && (tt(g.plain, _e13) || tt(g.closure, _e13) || g.closure.push(_e13));\n  } else {\n    var _e14 = ue(0),\n        _t9 = ue(),\n        _n3 = ue();\n\n    g && g.plain.push(_e14, _t9, _n3), a({\n      parent: l,\n      node: [fe({\n        store: _t9\n      }), ne({\n        from: \"value\",\n        store: 1,\n        target: _e14\n      })],\n      family: {\n        owners: [l, r, i],\n        links: r\n      },\n      meta: {\n        op: \"sample\",\n        sample: 'source'\n      },\n      regional: 1\n    }), Ae(l, [ft(i, r, {\n      scope: {\n        fn: d,\n        targetTemplate: k\n      },\n      node: [g && g.loader, fe({\n        store: _n3\n      }), ne({\n        store: _e14\n      }), le({\n        fn: function fn(e) {\n          return e;\n        }\n      }), !s && ae({\n        priority: \"sampler\"\n      }), ne({\n        store: _t9\n      }), ne({\n        store: _n3,\n        to: \"a\"\n      }), d && se({\n        fn: de\n      }), g && y && g.upward],\n      meta: {\n        op: \"sample\",\n        sample: 'clock'\n      }\n    })]);\n  }\n\n  return r;\n}\n\nfunction w() {\n  for (var _len6 = arguments.length, e = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n    e[_key6] = arguments[_key6];\n  }\n\n  var r = {\n    op: 'guard'\n  },\n      n = 'guard',\n      _et5 = et(e),\n      _et6 = _slicedToArray(_et5, 2),\n      _et6$ = _slicedToArray(_et6[0], 2),\n      o = _et6$[0],\n      s = _et6$[1],\n      l = _et6[1];\n\n  l && (r.config = l, l.name && (n = l.name)), s || (s = o, o = s.source);\n  var _s = s,\n      i = _s.filter,\n      f = _s.greedy,\n      u = _s.clock,\n      _s$name = _s.name,\n      d = _s$name === void 0 ? n : _s$name,\n      m = s.target || c(d, r.config),\n      h = E(i),\n      g = 1;\n  return void 0 === o && (t(u, 'guard', 'clock'), Array.isArray(u) && (u = b(u)), o = u, g = 0), g && !E(o) && (o = p(o)), u && (t(u, 'guard', 'clock'), o = v({\n    source: o,\n    clock: u,\n    greedy: f,\n    fn: h ? null : function (e, t) {\n      return {\n        source: e,\n        clock: t\n      };\n    }\n  })), t(m, 'guard', 'target'), h ? v({\n    source: i,\n    clock: o,\n    target: a({\n      node: [le({\n        fn: function fn(_ref12) {\n          var e = _ref12.guard;\n          return e;\n        }\n      }), se({\n        fn: function fn(_ref13) {\n          var e = _ref13.data;\n          return e;\n        }\n      })],\n      child: m,\n      meta: r,\n      family: {\n        owners: [o, i, m].concat(_toConsumableArray([].concat(u || []))),\n        links: m\n      },\n      regional: 1\n    }),\n    fn: function fn(e, t) {\n      return {\n        guard: e,\n        data: t\n      };\n    },\n    greedy: f,\n    name: d\n  }) : (J(i) || B('`filter` should be function or unit'), ft(o, m, {\n    scope: {\n      fn: i\n    },\n    node: u ? [le({\n      fn: function fn(_ref14, _ref15) {\n        var e = _ref14.source,\n            t = _ref14.clock;\n        var r = _ref15.fn;\n        return r(e, t);\n      }\n    }), se({\n      fn: function fn(_ref16) {\n        var e = _ref16.source;\n        return e;\n      }\n    })] : [le({\n      fn: he\n    })],\n    meta: r\n  })), m;\n}\n\nfunction S(e, t, r) {\n  if (W(e)) return e;\n\n  if (E(e)) {\n    var _a3,\n        _n4 = xe(e);\n\n    return T(e) && (_a3 = u(t, {\n      parent: _n4,\n      name: e.shortName,\n      ɔ: r\n    }).on(e, function (e, t) {\n      return t;\n    })), H(e) && (_a3 = u(t, {\n      parent: _n4,\n      name: e.shortName,\n      ɔ: r\n    }).on(e.done, function (e, _ref17) {\n      var t = _ref17.result;\n      return t;\n    })), _n4 && _n4.hooks.store(_a3), _a3;\n  }\n\n  var a = Array.isArray(e) ? [] : {};\n  return i(e, function (e, t) {\n    a[t] = W(e) ? e : u(e, {\n      name: t\n    });\n  }), a;\n}\n\nfunction q() {\n  for (var _len7 = arguments.length, e = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n    e[_key7] = arguments[_key7];\n  }\n\n  var t,\n      _et7 = et(e),\n      _et8 = _slicedToArray(_et7, 2),\n      _et8$ = _slicedToArray(_et8[0], 2),\n      r = _et8$[0],\n      n = _et8$[1],\n      o = _et8[1],\n      s = !n;\n\n  s && (t = r.cases, n = r.match, r = r.source);\n  var l = W(n),\n      f = !E(n) && J(n),\n      u = !l && !f && V(n);\n  t || (t = {}), s || (u || B('match should be an object'), i(n, function (e, r) {\n    t[r] = c(o);\n  }), t.__ = c(o));\n  var p,\n      d = je(),\n      m = new Set([].concat(r, Object.values(t))),\n      h = Object.keys(l || f ? t : n);\n  if (l || f) l && m.add(n), p = [l && ae({\n    priority: 'sampler'\n  }), l && ne({\n    store: be(n),\n    to: 'a'\n  }), le({\n    fn: function fn(e, t, r) {\n      var a = String(l ? r.a : n(e));\n      At(t, tt(h, a) ? a : '__', e, r);\n    }\n  })];else if (u) {\n    var _e15 = ue({});\n\n    _e15.type = 'shape';\n\n    var _t10,\n        _r6 = _e15.before = [],\n        _a4 = [ne({\n      store: _e15,\n      to: \"a\"\n    }), se({\n      fn: function fn(e, _ref18, _ref19) {\n        var t = _ref18.key;\n        var r = _ref19.a;\n        r[t] = e;\n      }\n    })],\n        _o4 = [];\n\n    i(n, function (n, s) {\n      if (E(n)) {\n        _t10 = 1, _o4.push(s), m.add(n);\n\n        var _l = ft(n, [], {\n          node: _a4,\n          scope: {\n            key: s\n          }\n        });\n\n        if (W(n)) {\n          _e15.current[s] = n.getState();\n\n          var _t11 = be(n);\n\n          _r6.push({\n            type: 'field',\n            field: s,\n            from: _t11\n          }), d && (tt(d.plain, _t11) || _l.seq.unshift(d.loader));\n        }\n      }\n    }), _t10 && d && d.plain.push(_e15), p = [_t10 && ae({\n      priority: 'sampler'\n    }), _t10 && ne({\n      store: _e15,\n      to: 'a'\n    }), le({\n      fn: function fn(e, t, r) {\n        for (var _a5 = 0; _a5 < h.length; _a5++) {\n          var _s2 = h[_a5];\n          if (tt(_o4, _s2) ? r.a[_s2] : n[_s2](e)) return void At(t, _s2, e, r);\n        }\n\n        At(t, '__', e, r);\n      }\n    })];\n  } else B('expect match to be unit, function or object');\n  if (a({\n    meta: {\n      onCopy: Object.keys(t),\n      op: 'split'\n    },\n    parent: r,\n    scope: t,\n    node: p,\n    family: {\n      type: 'crosslink',\n      owners: Array.from(m)\n    },\n    regional: 1\n  }), !s) return t;\n}\n\nfunction x(e, _ref20) {\n  var t = _ref20.values;\n  var r = V(e) && e.cloneOf;\n  G(e) || r || B('first argument of hydrate should be domain or scope'), V(t) || B('values property should be an object');\n  var a,\n      o,\n      s = j(t);\n  if (r) a = [], o = [], i(s, function (t, r) {\n    var n = e.sidMap[r];\n    n && (a.push(n), o.push(t), e.changedStores.add(n.meta.forkOf.id));\n  });else {\n    var _t12 = function (_ref21) {\n      var e = _ref21.flatGraphUnits,\n          t = _ref21.values,\n          r = _ref21.collectWatches;\n      var a = [],\n          n = [],\n          o = {},\n          s = new Set(),\n          l = Object.getOwnPropertyNames(t);\n      return f(e, function (e) {\n        var f = e.reg,\n            _e$meta = e.meta,\n            c = _e$meta.op,\n            u = _e$meta.unit,\n            p = _e$meta.sid;\n\n        if (u === I && p && tt(l, p)) {\n          var _r7 = e.scope.state;\n          _r7.current = t[p], s.add(_r7);\n        }\n\n        if (r && 'watch' === c) {\n          var _t13 = e.family.owners[0];\n          _t13.meta.unit === I && (a.push(e), n.push(_t13.scope.state));\n        }\n\n        i(f, function (e, t) {\n          o[t] = e;\n        });\n      }), f(P(N(o)), function (e) {\n        (function (e) {\n          var t = 0;\n          if (e.before && !s.has(e) && f(e.before, function (r) {\n            switch (r.type) {\n              case $:\n                e.current = r.fn(r.from.current);\n                break;\n\n              case 'field':\n                {\n                  var _a6 = r.from;\n                  t || (t = 1, e.current = Array.isArray(e.current) ? _toConsumableArray(e.current) : _objectSpread({}, e.current)), e.current[r.field] = _a6.current;\n                  break;\n                }\n            }\n          }), !e.after) return;\n          var r = e.current;\n          f(e.after, function (e) {\n            var t = e.to;\n\n            switch (e.type) {\n              case 'copy':\n                t.current = r;\n                break;\n\n              case $:\n                t.current = e.fn(r);\n            }\n          });\n        })(o[e]);\n      }), {\n        storeWatches: a,\n        storeWatchesRefs: n\n      };\n    }({\n      flatGraphUnits: R(e),\n      values: s,\n      collectWatches: 1\n    });\n\n    a = _t12.storeWatches, o = _t12.storeWatchesRefs.map(function (_ref22) {\n      var e = _ref22.current;\n      return e;\n    });\n  }\n  n({\n    target: a,\n    params: o,\n    forkPage: r ? e : 0\n  });\n}\n\nfunction N(e) {\n  var t = Object.values(e),\n      r = {};\n  return f(t, function (_ref23) {\n    var e = _ref23.id;\n    r[e] = [];\n  }), f(t, function (_ref24) {\n    var e = _ref24.id,\n        t = _ref24.before,\n        a = _ref24.after;\n    t && f(t, function (t) {\n      r[t.from.id].push(e);\n    }), a && f(a, function (t) {\n      r[e].push(t.to.id);\n    });\n  }), r;\n}\n\nfunction A(_ref25) {\n  var e = _ref25.clones,\n      t = _ref25.changedStores;\n\n  var _ref26 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref26$ignore = _ref26.ignore,\n      r = _ref26$ignore === void 0 ? [] : _ref26$ignore,\n      a = _ref26.onlyChanges;\n\n  var n = {};\n  return f(e, function (_ref27) {\n    var e = _ref27.meta,\n        r = _ref27.scope,\n        o = _ref27.reg;\n    if (e.unit !== I) return;\n    var s = e.sid;\n    s && (!a && !e.isCombine || t.has(e.forkOf.id)) && (n[s] = o[r.state.id].current);\n  }), f(r, function (_ref28) {\n    var e = _ref28.sid;\n    e && delete n[e];\n  }), n;\n}\n\nfunction C(e) {\n  He || B('scopeBind cannot be called outside of forked .watch');\n  var t = He,\n      r = He.find(e);\n  return H(e) ? function (e) {\n    var a = d();\n    n({\n      target: r,\n      params: {\n        params: e,\n        req: a\n      },\n      forkPage: t\n    });\n  } : function (e) {\n    return n({\n      target: r,\n      params: e,\n      forkPage: t\n    }), e;\n  };\n}\n\nfunction j(e) {\n  var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};\n\n  if (e instanceof Map) {\n    var _r8 = {};\n\n    var _iterator2 = _createForOfIteratorHelper(e),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var _step2$value = _slicedToArray(_step2.value, 2),\n            _a7 = _step2$value[0],\n            _n5 = _step2$value[1];\n\n        E(_a7) || B('Map key should be a unit'), t(_a7, _n5), _r8[_a7.sid] = _n5;\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n\n    return _r8;\n  }\n\n  return e;\n}\n\nfunction O(e) {\n  var _ref29 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      t = _ref29.values,\n      r = _ref29.handlers;\n\n  G(e) || B('first argument of fork should be domain');\n  var n = !!t;\n  t = j(t || {}, function (e) {\n    return !W(e) && B('Values map can contain only stores as keys');\n  });\n\n  var o = function (e) {\n    function t(e) {\n      var t = ge(e),\n          a = r.indexOf(t);\n\n      if (-1 === a) {\n        var _r9 = 'unit';\n        e !== t && e.id !== e.shortName && (_r9 = e.shortName), B(\"\".concat(_r9, \" not found in forked scope\"));\n      }\n\n      return p[a];\n    }\n\n    var r = R(e),\n        n = new Map(),\n        o = new Set(),\n        s = se({\n      fn: function fn(e, t, r) {\n        return (!r.node.meta.isCombine || xe(r) && 'combine' !== xe(r).node.meta.op) && o.add(r.node.meta.forkOf.id), e;\n      }\n    }),\n        l = a({\n      scope: {\n        defers: [],\n        inFlight: 0,\n        fxID: 0\n      },\n      node: [se({\n        fn: function fn(e, t, r) {\n          r.parent ? 'finally' === r.parent.node.meta.named ? t.inFlight -= 1 : (t.inFlight += 1, t.fxID += 1) : t.fxID += 1;\n        }\n      }), ae({\n        priority: \"sampler\"\n      }), ie({\n        fn: function fn(e, t) {\n          var r = t.inFlight,\n              a = t.defers,\n              n = t.fxID;\n          r > 0 || 0 === a.length || Promise.resolve().then(function () {\n            t.fxID === n && f(a.splice(0, a.length), function (e) {\n              Ve(e.parentFork), e.rs(e.value);\n            });\n          });\n        }\n      })],\n      meta: {\n        unit: \"forkInFlightCounter\"\n      }\n    }),\n        c = {},\n        u = {},\n        p = r.map(function (e) {\n      var t = e.seq,\n          r = e.next,\n          n = e.meta,\n          o = e.scope,\n          s = a({\n        node: t.map(function (e) {\n          return {\n            id: e.id,\n            type: e.type,\n            data: _objectSpread({}, e.data),\n            hasRef: e.hasRef\n          };\n        }),\n        child: _toConsumableArray(r),\n        meta: _objectSpread({\n          forkOf: e\n        }, n),\n        scope: _objectSpread({}, o)\n      });\n      return s.family = {\n        type: e.family.type,\n        links: _toConsumableArray(ke(e)),\n        owners: _toConsumableArray(ye(e))\n      }, c[e.id] = s, n.sid && (u[n.sid] = s), s;\n    }),\n        d = {};\n    return f(p, function (e) {\n      var r = e.reg,\n          a = e.scope,\n          _e$meta2 = e.meta,\n          o = _e$meta2.onCopy,\n          c = _e$meta2.op,\n          u = _e$meta2.unit;\n\n      switch (i(r, function (e, t) {\n        var a = n.get(e);\n        a || (a = {\n          id: e.id,\n          current: e.current\n        }, n.set(e, a)), d[t] = r[t] = a;\n      }), o && f(o, function (e) {\n        var r = a[e];\n        a[e] = Array.isArray(r) ? r.map(t) : t(r);\n      }), D(e, function (e, r, a) {\n        a[r] = t(e);\n      }), c || u) {\n        case I:\n          e.meta.wrapped = function (e) {\n            return {\n              kind: I,\n              getState: function getState() {\n                return e.reg[e.scope.state.id].current;\n              },\n              updates: {\n                watch: Z(ut, e)\n              },\n              graphite: e,\n              family: e.family\n            };\n          }(e), e.meta.sid && e.seq.push(s);\n          break;\n\n        case M:\n          e.next.push(l);\n          break;\n\n        case 'fx':\n          a.finally.next.push(l);\n      }\n    }), {\n      cloneOf: e,\n      changedStores: o,\n      nodeMap: c,\n      sidMap: u,\n      clones: p,\n      find: t,\n      reg: d,\n      getState: function getState(e) {\n        return t(e).meta.wrapped.getState();\n      },\n      graphite: a({\n        family: {\n          type: \"domain\",\n          links: [l].concat(_toConsumableArray(p))\n        },\n        meta: {\n          unit: 'fork'\n        },\n        scope: {\n          forkInFlightCounter: l\n        }\n      })\n    };\n  }(e);\n\n  if (n && function () {\n    var r = R(e),\n        a = {},\n        n = {},\n        s = new Set(),\n        l = new Set(),\n        c = Object.getOwnPropertyNames(t);\n    f(r, function (_ref30) {\n      var e = _ref30.reg,\n          t = _ref30.meta;\n      var r = t.nativeTemplate;\n      i(e, function (e, t) {\n        a[t] = e, r && l.add(t);\n      });\n    }), f(o.clones, function (e) {\n      var r = e.reg,\n          _e$meta3 = e.meta,\n          a = _e$meta3.unit,\n          l = _e$meta3.sid;\n\n      if (a === I && l && tt(c, l)) {\n        var _a8 = e.scope.state;\n        r[_a8.id].current = t[l], s.add(_a8), o.changedStores.add(e.meta.forkOf.id);\n      }\n\n      i(r, function (e, t) {\n        n[t] = e;\n      });\n    }), f(P(N(a), l), function (e) {\n      (function (e, t) {\n        var r = 0;\n        if (t && t.before && !s.has(e) && f(t.before, function (t) {\n          switch (t.type) {\n            case $:\n              e.current = t.fn(n[t.from.id].current);\n              break;\n\n            case 'field':\n              {\n                var _a9 = n[t.from.id];\n                r || (r = 1, e.current = Array.isArray(e.current) ? _toConsumableArray(e.current) : _objectSpread({}, e.current)), e.current[t.field] = _a9.current;\n                break;\n              }\n          }\n        }), !t || !t.after) return;\n        var a = e.current;\n        f(t.after, function (e) {\n          var t = n[e.to.id];\n\n          switch (e.type) {\n            case 'copy':\n              t.current = a;\n              break;\n\n            case $:\n              t.current = e.fn(a);\n          }\n        });\n      })(n[e], a[e]);\n    });\n  }(), r) {\n    r = j(r, function (e) {\n      return !H(e) && B(\"Handlers map can contain only effects as keys\");\n    });\n\n    var _e16 = Object.keys(r);\n\n    f(o.clones, function (_ref31) {\n      var t = _ref31.scope,\n          a = _ref31.meta;\n      a.sid && tt(_e16, a.sid) && (t.runner.scope.getHandler = function () {\n        return r[a.sid];\n      });\n    });\n  }\n\n  return o;\n}\n\nfunction P(e, t) {\n  function r(e) {\n    s[e] = 1;\n    var t = a[e];\n\n    for (var _e17 = 0; _e17 < t.length; _e17++) {\n      var _a10 = t[_e17];\n      s[_a10] || o[_a10] || r(_a10);\n    }\n\n    s[e] = 0, o[e] = 1, n.push(e);\n  }\n\n  var a = {};\n\n  for (var _t14 in e) {\n    a[_t14] = _toConsumableArray(new Set(e[_t14]));\n  }\n\n  var n = [],\n      o = {},\n      s = {};\n\n  for (var _e18 in a) {\n    o[_e18] || s[_e18] || r(_e18);\n  }\n\n  if (n.reverse(), t && t.size > 0) {\n    (function () {\n      var e,\n          r = [],\n          o = _toConsumableArray(t);\n\n      for (; e = o.shift();) {\n        r.push(e), f(a[e], function (e) {\n          tt(r, e) || tt(o, e) || o.push(e);\n        });\n      }\n\n      f(r, function (e) {\n        rt(n, e);\n      });\n    })();\n  }\n\n  return n;\n}\n\nfunction F(e, _ref32) {\n  var t = _ref32.scope,\n      r = _ref32.params;\n  if (!E(e)) return Promise.reject(Error('first argument should be unit'));\n  var a = d();\n  a.parentFork = He;\n  var o = t.graphite.scope.forkInFlightCounter;\n  o.scope.defers.push(a);\n  var s = [t.find(e)],\n      l = [];\n  return H(e) ? l.push({\n    params: r,\n    req: {\n      rs: function rs(e) {\n        a.value = {\n          status: 'done',\n          value: e\n        };\n      },\n      rj: function rj(e) {\n        a.value = {\n          status: 'fail',\n          value: e\n        };\n      }\n    }\n  }) : l.push(r), s.push(o), l.push(null), n({\n    target: s,\n    params: l,\n    forkPage: t\n  }), a.req;\n}\n\nfunction R(e) {\n  var t = [];\n  return function e(r) {\n    tt(t, r) || (t.push(r), D(r, e));\n  }(ge(e)), t;\n}\n\nfunction D(e, t) {\n  var r = e.meta.unit;\n  'fork' !== r && \"forkInFlightCounter\" !== r && (f(e.next, t), f(ye(e), t), f(ke(e), t));\n}\n\nvar _ = 'undefined' != typeof Symbol && Symbol.observable || '@@observable',\n    I = 'store',\n    M = 'effect',\n    $ = 'map',\n    E = function E(e) {\n  return (J(e) || V(e)) && 'kind' in e;\n};\n\nvar z = function z(e) {\n  return function (t) {\n    return E(t) && t.kind === e;\n  };\n};\n\nvar W = z(I),\n    T = z(\"event\"),\n    H = z(M),\n    G = z(\"domain\");\nvar U = {\n  __proto__: null,\n  unit: E,\n  store: W,\n  event: T,\n  effect: H,\n  domain: G\n};\n\nvar B = function B(e) {\n  throw Error(e);\n},\n    V = function V(e) {\n  return 'object' == typeof e && null !== e;\n},\n    J = function J(e) {\n  return 'function' == typeof e;\n},\n    K = function K(e) {\n  V(e) || J(e) || B('expect first argument be an object');\n};\n\nvar L = function L() {\n  var e = 0;\n  return function () {\n    return (++e).toString(36);\n  };\n};\n\nvar Q = L(),\n    X = L(),\n    Y = L(),\n    Z = function Z(e, t) {\n  return e.bind(null, t);\n},\n    ee = function ee(e, t, r) {\n  return e.bind(null, t, r);\n};\n\nvar te = function te(e, t, r) {\n  return {\n    id: X(),\n    type: e,\n    data: r,\n    hasRef: t\n  };\n};\n\nvar re = 0,\n    ae = function ae(_ref33) {\n  var _ref33$priority = _ref33.priority,\n      e = _ref33$priority === void 0 ? \"barrier\" : _ref33$priority;\n  return te(\"barrier\", 0, {\n    barrierID: ++re,\n    priority: e\n  });\n},\n    ne = function ne(_ref34) {\n  var _ref34$from = _ref34.from,\n      e = _ref34$from === void 0 ? I : _ref34$from,\n      t = _ref34.store,\n      r = _ref34.target,\n      _ref34$to = _ref34.to,\n      a = _ref34$to === void 0 ? r ? I : \"stack\" : _ref34$to;\n  return te('mov', e === I, {\n    from: e,\n    store: t,\n    to: a,\n    target: r\n  });\n},\n    oe = {\n  defined: function defined() {\n    return te('check', 0, {\n      type: 'defined'\n    });\n  },\n  changed: function changed(_ref35) {\n    var e = _ref35.store;\n    return te('check', 1, {\n      type: 'changed',\n      store: e\n    });\n  }\n},\n    se = ee(te, 'compute', 0),\n    le = ee(te, \"filter\", 0),\n    ie = ee(te, 'run', 0),\n    fe = function fe(_ref36) {\n  var e = _ref36.store;\n  return ne({\n    from: \"stack\",\n    target: e\n  });\n};\n\nvar ce = {\n  __proto__: null,\n  barrier: ae,\n  mov: ne,\n  check: oe,\n  compute: se,\n  filter: le,\n  run: ie,\n  update: fe\n};\n\nvar ue = function ue(e) {\n  return {\n    id: X(),\n    current: e\n  };\n},\n    pe = function pe(_ref37) {\n  var e = _ref37.current;\n  return e;\n},\n    de = function de(e, _ref38, _ref39) {\n  var t = _ref38.fn;\n  var r = _ref39.a;\n  return t(e, r);\n},\n    me = function me(e, _ref40, _ref41) {\n  var t = _ref40.fn;\n  var r = _ref41.a;\n  return t(r, e);\n},\n    he = function he(e, _ref42) {\n  var t = _ref42.fn;\n  return t(e);\n},\n    ge = function ge(e) {\n  return e.graphite || e;\n},\n    ye = function ye(e) {\n  return e.family.owners;\n},\n    ke = function ke(e) {\n  return e.family.links;\n},\n    be = function be(e) {\n  return e.stateRef;\n},\n    ve = function ve(e) {\n  return e.config;\n},\n    we = function we(e) {\n  return e.ɔ;\n},\n    Se = function Se(e) {\n  return e.value;\n},\n    qe = function qe(e) {\n  return e.subscribers;\n},\n    xe = function xe(e) {\n  return e.parent;\n},\n    Ne = function Ne(e) {\n  return e.forkPage;\n},\n    Ae = function Ae(e, t) {\n  var r = ge(e);\n\n  for (var _e19 = 0; _e19 < t.length; _e19++) {\n    var _a11 = ge(t[_e19]);\n\n    \"domain\" !== r.family.type && (_a11.family.type = \"crosslink\"), ye(_a11).push(r), ke(r).push(_a11);\n  }\n},\n    Ce = null,\n    je = function je() {\n  return Ce && Ce.template;\n},\n    Oe = function Oe(e) {\n  return e && Ce && Ce.sidRoot && (e = \"\".concat(Ce.sidRoot, \"\\u0254\").concat(e)), e;\n},\n    Pe = function Pe(_ref43) {\n  var e = _ref43.sid,\n      t = _ref43.name,\n      n = _ref43.loc,\n      o = _ref43.method,\n      s = _ref43.fn;\n  return r(a({\n    meta: {\n      sidRoot: Oe(e),\n      name: t,\n      loc: n,\n      method: o\n    }\n  }), s);\n};\n\nvar Fe = function Fe() {\n  var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  var t = [];\n  if (Array.isArray(e)) for (var _r10 = 0; _r10 < e.length; _r10++) {\n    Array.isArray(e[_r10]) ? t.push.apply(t, _toConsumableArray(e[_r10])) : t.push(e[_r10]);\n  } else t.push(e);\n  return t.map(ge);\n};\n\nvar Re = function Re(_ref44, a) {\n  var e = _ref44.hasRef,\n      t = _ref44.type,\n      r = _ref44.data;\n  var n;\n  e && (n = r.store, a[n.id] = n), 'mov' === t && r.to === I && (n = r.target, a[n.id] = n);\n},\n    De = null;\n\nvar _e = function _e(e, t) {\n  if (!e) return t;\n  if (!t) return e;\n  var r,\n      a = e.v.type === t.v.type;\n  return (a && e.v.id > t.v.id || !a && \"sampler\" === e.v.type) && (r = e, e = t, t = r), r = _e(e.r, t), e.r = e.l, e.l = r, e;\n},\n    Ie = [];\n\nvar Me = 0;\n\nfor (; Me < 5;) {\n  Ie.push({\n    first: null,\n    last: null,\n    size: 0\n  }), Me += 1;\n}\n\nvar $e = function $e() {\n  for (var _e20 = 0; _e20 < 5; _e20++) {\n    var _t15 = Ie[_e20];\n\n    if (_t15.size > 0) {\n      if (2 === _e20 || 3 === _e20) {\n        _t15.size -= 1;\n        var _e21 = De.v;\n        return De = _e(De.l, De.r), _e21;\n      }\n\n      1 === _t15.size && (_t15.last = null);\n      var _r11 = _t15.first;\n      return _t15.first = _r11.r, _t15.size -= 1, _r11.v;\n    }\n  }\n},\n    Ee = function Ee(e, t, r, a, n, o) {\n  return ze(0, {\n    a: null,\n    b: null,\n    node: r,\n    parent: a,\n    value: n,\n    page: t,\n    forkPage: o\n  }, e);\n},\n    ze = function ze(e, t, r) {\n  var a = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  var n = We(r),\n      o = Ie[n],\n      s = {\n    v: {\n      idx: e,\n      stack: t,\n      type: r,\n      id: a\n    },\n    l: 0,\n    r: 0\n  };\n  2 === n || 3 === n ? De = _e(De, s) : (0 === o.size ? o.first = s : o.last.r = s, o.last = s), o.size += 1;\n},\n    We = function We(e) {\n  switch (e) {\n    case 'child':\n      return 0;\n\n    case 'pure':\n      return 1;\n\n    case \"barrier\":\n      return 2;\n\n    case \"sampler\":\n      return 3;\n\n    case M:\n      return 4;\n\n    default:\n      return -1;\n  }\n},\n    Te = new Set();\n\nvar He,\n    Ge = 1,\n    Ue = 0,\n    Be = null,\n    Ve = function Ve(e) {\n  He = e;\n},\n    Je = function Je(e) {\n  Be = e;\n};\n\nvar Ke = function Ke(e, t) {\n  if (e) {\n    for (; e && !e.reg[t];) {\n      e = xe(e);\n    }\n\n    if (e) return e;\n  }\n\n  return null;\n},\n    Le = function Le(e, t, r) {\n  return (Ke(e, r) || t).reg[r];\n},\n    Qe = function Qe(e, _ref45, r) {\n  var t = _ref45.fn;\n\n  try {\n    return t(Se(r), e.scope, r);\n  } catch (t) {\n    console.error(t), e.fail = 1;\n  }\n};\n\nvar Xe = function Xe(e, t) {\n  return '' + e.shortName + t;\n},\n    Ye = function Ye(e, t) {\n  return null == t ? Xe(e, ' → *') : t;\n},\n    Ze = function Ze(e, t) {\n  K(e), we(e) && t(ve(e), we(e));\n},\n    et = function et(e) {\n  var t;\n  return Ze(e[0], function (r, a) {\n    t = r, e = a;\n  }), [e, t];\n},\n    tt = function tt(e, t) {\n  return e.includes(t);\n},\n    rt = function rt(e, t) {\n  var r = e.indexOf(t);\n  -1 !== r && e.splice(r, 1);\n};\n\nvar at = function at(e, t) {\n  rt(e.next, t), rt(ye(e), t), rt(ke(e), t);\n},\n    nt = function nt(e, t, r) {\n  var a;\n  e.next.length = 0, e.seq.length = 0, e.scope = null;\n  var n = ke(e);\n\n  for (; a = n.pop();) {\n    at(a, e), (t || r && !e.meta.sample || \"crosslink\" === a.family.type) && nt(a, t, 'on' !== a.meta.op && r);\n  }\n\n  for (n = ye(e); a = n.pop();) {\n    at(a, e), r && \"crosslink\" === a.family.type && nt(a, t, 'on' !== a.meta.op && r);\n  }\n},\n    ot = function ot(e) {\n  return e.clear();\n};\n\nvar st = function st(e) {\n  var _ref46 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      t = _ref46.deep;\n\n  var r = 0;\n  if (e.ownerSet && e.ownerSet.delete(e), W(e)) ot(qe(e));else if (G(e)) {\n    r = 1;\n    var _t16 = e.history;\n    ot(_t16.events), ot(_t16.effects), ot(_t16.stores), ot(_t16.domains);\n  }\n  nt(ge(e), !!t, r);\n},\n    lt = function lt(e) {\n  var t = ee(st, e, void 0);\n  return t.unsubscribe = t, t;\n},\n    ft = function ft(e, t, _ref47) {\n  var r = _ref47.node,\n      n = _ref47.scope,\n      o = _ref47.meta;\n  return a({\n    node: r,\n    parent: e,\n    child: t,\n    scope: n,\n    meta: o,\n    family: {\n      owners: [e, t],\n      links: t\n    },\n    regional: 1\n  });\n},\n    ct = function ct(e) {\n  var r;\n  Ze(e, function (t, a) {\n    r = t, e = a;\n  });\n  var _e22 = e,\n      n = _e22.from,\n      o = _e22.to,\n      _e22$meta = _e22.meta,\n      s = _e22$meta === void 0 ? {\n    op: 'forward'\n  } : _e22$meta;\n  return t(n, 'forward', '\"from\"'), t(o, 'forward', '\"to\"'), r && (s.config = r), lt(a({\n    parent: n,\n    child: o,\n    meta: s,\n    family: {},\n    regional: 1\n  }));\n},\n    ut = function ut(e, t) {\n  if (J(t) || B('.watch argument should be a function'), He) {\n    var _t17 = He.nodeMap[ge(e).id];\n    _t17 && (e = _t17);\n  }\n\n  return lt(a({\n    scope: {\n      fn: t\n    },\n    node: [ie({\n      fn: he\n    })],\n    parent: e,\n    meta: {\n      op: 'watch'\n    },\n    family: {\n      owners: e\n    },\n    regional: 1\n  }));\n};\n\nvar pt = function pt(e, t) {\n  return V(e) && (pt(ve(e), t), null != e.name && (V(e.name) ? pt(e.name, t) : J(e.name) ? t.handler = e.name : t.name = e.name), e.loc && (t.loc = e.loc), (e.sid || null === e.sid) && (t.sid = e.sid), e.handler && (t.handler = e.handler), e.updateFilter && (t.updateFilter = e.updateFilter), xe(e) && (t.parent = xe(e)), 'strict' in e && (t.strict = e.strict), e.named && (t.named = e.named), pt(we(e), t)), t;\n};\n\nvar dt,\n    mt = function mt(e, t) {\n  var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"event\";\n  xe(e) && xe(e).hooks[r](t);\n},\n    ht = function ht(e, t, r, a) {\n  var n = pt({\n    name: a,\n    config: r\n  }, {}),\n      o = \"domain\" === e,\n      s = Q(),\n      _n$parent = n.parent,\n      i = _n$parent === void 0 ? null : _n$parent,\n      _n$sid = n.sid,\n      f = _n$sid === void 0 ? null : _n$sid,\n      _n$strict = n.strict,\n      c = _n$strict === void 0 ? 1 : _n$strict,\n      _n$named = n.named,\n      u = _n$named === void 0 ? null : _n$named,\n      p = u || n.name || (o ? '' : s),\n      d = l(p, i),\n      m = {\n    unit: t.kind = e,\n    name: t.shortName = p,\n    sid: t.sid = Oe(f),\n    named: u,\n    unitId: t.id = s\n  };\n\n  if (t.parent = i, t.compositeName = d, t.defaultConfig = n, t.thru = function (e) {\n    return e(t);\n  }, t.getType = function () {\n    return d.fullName;\n  }, !o) {\n    t.subscribe = function (e) {\n      return K(e), t.watch(J(e) ? e : function (t) {\n        e.next && e.next(t);\n      });\n    }, t[_] = function () {\n      return t;\n    };\n\n    var _e23 = je();\n\n    _e23 && (m.nativeTemplate = _e23);\n  }\n\n  return dt = c, m;\n},\n    gt = function gt(e) {\n  return c({\n    named: e\n  });\n};\n\nvar yt = function yt(e, t, r, a) {\n  return ft(e, t, {\n    scope: {\n      fn: a\n    },\n    node: [se({\n      fn: he\n    })],\n    meta: {\n      op: r\n    }\n  });\n},\n    kt = function kt(e, t, r, a) {\n  var n;\n  V(r) && (n = r, r = r.fn);\n  var o = c(Xe(e, ' →? *'), n);\n  return ft(e, o, {\n    scope: {\n      fn: r\n    },\n    node: a,\n    meta: {\n      op: t\n    }\n  }), o;\n},\n    bt = function bt(e, t, r, a, n, o) {\n  var s = be(t),\n      l = [ne({\n    store: s,\n    to: \"a\"\n  }), se({\n    fn: a ? me : de\n  }), oe.defined(), oe.changed({\n    store: s\n  }), o && le({\n    fn: function fn(e, t, _ref48) {\n      var r = _ref48.a;\n      return o(e, r);\n    }\n  }), fe({\n    store: s\n  })],\n      i = je();\n\n  if (i && (l.unshift(i.loader), l.push(i.upward), W(e))) {\n    var _t18 = be(e);\n\n    tt(i.plain, _t18) || (tt(i.closure, _t18) || i.closure.push(_t18), s.before || (s.before = []), s.before.push({\n      type: 'closure',\n      of: _t18\n    }));\n  }\n\n  return ft(e, t, {\n    scope: {\n      fn: n\n    },\n    node: l,\n    meta: {\n      op: r\n    }\n  });\n},\n    vt = function vt(e) {\n  return function (t) {\n    return e.apply(void 0, _toConsumableArray(t));\n  };\n},\n    wt = function wt(e, t, r, a) {\n  var n = e ? function (e) {\n    return e.slice();\n  } : function (e) {\n    return _objectSpread({}, e);\n  },\n      s = e ? [] : {},\n      l = je(),\n      f = n(s),\n      c = ue(f),\n      p = ue(1);\n  c.type = e ? 'list' : 'shape', l && l.plain.push(c, p);\n  var d = u(f, {\n    name: r || o(t)\n  });\n  ge(d).meta.isCombine = 1;\n  var m = [oe.defined(), ne({\n    store: c,\n    to: \"a\"\n  }), le({\n    fn: function fn(e, _ref49, _ref50) {\n      var t = _ref49.key;\n      var r = _ref50.a;\n      return e !== r[t];\n    }\n  }), ne({\n    store: p,\n    to: 'b'\n  }), se({\n    fn: function fn(e, _ref51, a) {\n      var t = _ref51.clone,\n          r = _ref51.key;\n      a.b && (a.a = t(a.a)), a.a[r] = e;\n    }\n  }), ne({\n    from: \"a\",\n    target: c\n  }), ne({\n    from: \"value\",\n    store: 0,\n    target: p\n  }), ae({\n    priority: \"barrier\"\n  }), ne({\n    from: \"value\",\n    store: 1,\n    target: p\n  }), ne({\n    store: c\n  }), a && se({\n    fn: a\n  }), oe.changed({\n    store: be(d)\n  })],\n      h = c.before = [];\n  return i(t, function (e, t) {\n    if (!W(e)) return void (f[t] = s[t] = e);\n    s[t] = e.defaultState, f[t] = e.getState();\n    var r = ft(e, d, {\n      scope: {\n        key: t,\n        clone: n\n      },\n      node: m,\n      meta: {\n        op: 'combine'\n      }\n    }),\n        a = be(e);\n    h.push({\n      type: 'field',\n      field: t,\n      from: a\n    }), l && (tt(l.plain, a) || r.seq.unshift(l.loader));\n  }), d.defaultShape = t, c.after = [a ? {\n    type: $,\n    to: be(d),\n    fn: a\n  } : {\n    type: 'copy',\n    to: be(d)\n  }], l || (d.defaultState = a ? be(d).current = a(f) : s), d;\n};\n\nvar St = function St(_ref52) {\n  var e = _ref52.params,\n      t = _ref52.req,\n      r = _ref52.ok,\n      a = _ref52.anyway,\n      o = _ref52.stack;\n  return function (s) {\n    return n({\n      target: [a, qt],\n      params: [r ? {\n        status: 'done',\n        params: e,\n        result: s\n      } : {\n        status: 'fail',\n        params: e,\n        error: s\n      }, {\n        fn: r ? t.rs : t.rj,\n        value: s\n      }],\n      defer: 1,\n      page: o.page,\n      forkPage: Ne(o)\n    });\n  };\n},\n    qt = a({\n  node: [ie({\n    fn: function fn(_ref53) {\n      var e = _ref53.fn,\n          t = _ref53.value;\n      e(t);\n    }\n  })],\n  meta: {\n    op: 'fx',\n    fx: 'sidechain'\n  }\n});\n\nvar xt = function xt(e, t, r) {\n  return e.create = function (t) {\n    return n(e, t), t;\n  }, ge(e).seq.push(se({\n    fn: function fn(e, t, r) {\n      return r.forkPage = null, e;\n    }\n  })), e.watch(function (e) {\n    Ae(r, [e]), t.add(e), e.ownerSet || (e.ownerSet = t), xe(e) || (e.parent = r);\n  }), Ae(r, [e]), function (r) {\n    return t.forEach(r), e.watch(r);\n  };\n},\n    Nt = ['source', 'clock', 'target'],\n    At = function At(e, t, r, a) {\n  var o = e[t];\n  o && n({\n    target: o,\n    params: Array.isArray(o) ? o.map(function () {\n      return r;\n    }) : r,\n    defer: 1,\n    stack: a\n  });\n},\n    Ct = \"21.8.12\";\n\nexport { F as allSettled, h as attach, st as clearNode, p as combine, g as createApi, y as createDomain, m as createEffect, c as createEvent, a as createNode, u as createStore, p as createStoreObject, O as fork, ct as forward, k as fromObservable, w as guard, x as hydrate, U as is, n as launch, b as merge, S as restore, v as sample, C as scopeBind, A as serialize, s as setStoreName, q as split, ce as step, Ct as version, Pe as withFactory, r as withRegion };","map":null,"metadata":{},"sourceType":"module"}