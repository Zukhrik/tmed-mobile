{"ast":null,"code":"'use strict';\n\nfunction e(e, r) {\n  (null == r || r > e.length) && (r = e.length);\n\n  for (var n = 0, t = new Array(r); n < r; n++) t[n] = e[n];\n\n  return t;\n}\n\nfunction r(r, n) {\n  var it = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n  if (it) return (it = it.call(r)).next.bind(it);\n\n  if (Array.isArray(r) || (it = function (r, n) {\n    if (r) {\n      if (\"string\" == typeof r) return e(r, n);\n      var t = {}.toString.call(r).slice(8, -1);\n      return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? e(r, n) : void 0;\n    }\n  }(r)) || n && r && \"number\" == typeof r.length) {\n    it && (r = it);\n    var t = 0;\n    return function () {\n      return t >= r.length ? {\n        done: 1\n      } : {\n        done: 0,\n        value: r[t++]\n      };\n    };\n  }\n\n  throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction n(e, r, n, t) {\n  (E(e) || z(e)) && ('family' in e || 'graphite' in e) || M(r + \": expect \" + n + \" to be a unit (store, event or effect)\" + t);\n}\n\nfunction t(e, r, t) {\n  if (Array.isArray(e)) for (var a = 0; a < e.length; a++) n(e[a], r, a + \" item of \" + t, '');else n(e, r, t, ' or array of units');\n}\n\nfunction a(e, r) {\n  var n = ue(e).meta;\n  ye = {\n    parent: ye,\n    value: e,\n    template: n.template || be(),\n    sidRoot: n.sidRoot || ye && ye.sidRoot\n  };\n\n  try {\n    return r();\n  } finally {\n    ye = ve(ye);\n  }\n}\n\nfunction o(e) {\n  for (var r = void 0 === e ? {} : e, n = r.node, t = void 0 === n ? [] : n, a = r.parent, o = r.child, i = void 0 === o ? r.to || r.target : o, u = r.scope, f = void 0 === u ? {} : u, c = r.meta, s = void 0 === c ? {} : c, l = r.family, p = void 0 === l ? {\n    type: 'regular'\n  } : l, d = r.regional, m = we(void 0 === a ? r.from || r.source : a), v = we(p.links), h = we(p.owners), g = [], y = {}, b = 0; b < t.length; b++) {\n    var k = t[b];\n    k && (g.push(k), xe(k, y));\n  }\n\n  for (var w = {\n    id: B(),\n    seq: g,\n    next: we(i),\n    meta: s,\n    scope: f,\n    family: {\n      type: p.type || \"crosslink\",\n      links: v,\n      owners: h\n    },\n    reg: y\n  }, x = 0; x < v.length; x++) fe(v[x]).push(w);\n\n  for (var S = 0; S < h.length; S++) ce(h[S]).push(w);\n\n  for (var A = 0; A < m.length; A++) m[A].next.push(w);\n\n  return d && ye && ge(de(ye), [w]), w;\n}\n\nfunction i(e, r, n) {\n  var t = Me,\n      a = null,\n      o = je;\n  if (e.target && (r = e.params, n = e.defer, t = 'page' in e ? e.page : t, e.stack && (a = e.stack), o = he(e) || o, e = e.target), o && je && o !== je && (je = null), Array.isArray(e)) for (var i = 0; i < e.length; i++) Pe('pure', t, ue(e[i]), a, r[i], o);else Pe('pure', t, ue(e), a, r, o);\n\n  if (!n || De) {\n    var u,\n        f,\n        c,\n        s,\n        l,\n        p,\n        d = {\n      isRoot: De,\n      currentPage: Me,\n      forkPage: je,\n      isWatch: Ie\n    };\n    De = 0;\n\n    e: for (; s = Ce();) {\n      var m = s.idx,\n          v = s.stack,\n          h = s.type;\n      c = v.node, Me = l = v.page, je = he(v), p = (l || c).reg;\n      var g = {\n        fail: 0,\n        scope: c.scope\n      };\n      u = f = 0;\n\n      for (var y = m; y < c.seq.length && !u; y++) {\n        var b = c.seq[y],\n            k = b.data;\n\n        switch (b.type) {\n          case \"barrier\":\n            var w = k.barrierID;\n            l && (w = l.fullID + \"_\" + w);\n            var x = k.priority;\n\n            if (y !== m || h !== x) {\n              _e.has(w) || (_e.add(w), Fe(y, v, x, w));\n              continue e;\n            }\n\n            _e.delete(w);\n\n            break;\n\n          case 'mov':\n            var S = void 0;\n\n            switch (k.from) {\n              case O:\n                S = de(v);\n                break;\n\n              case \"a\":\n              case 'b':\n                S = v[k.from];\n                break;\n\n              case \"value\":\n                S = k.store;\n                break;\n\n              case N:\n                p[k.store.id] || (v.page = l = Te(l, k.store.id), p = l ? l.reg : c.reg), S = te(p[k.store.id]);\n            }\n\n            switch (k.to) {\n              case O:\n                v.value = S;\n                break;\n\n              case \"a\":\n              case 'b':\n                v[k.to] = S;\n                break;\n\n              case N:\n                We(l, c, k.target.id).current = S;\n            }\n\n            break;\n\n          case 'check':\n            switch (k.type) {\n              case 'defined':\n                f = void 0 === de(v);\n                break;\n\n              case 'changed':\n                f = de(v) === te(We(l, c, k.store.id));\n            }\n\n            break;\n\n          case \"filter\":\n            f = !He(g, k, v);\n            break;\n\n          case 'run':\n            if (y !== m || \"effect\" !== h) {\n              Fe(y, v, \"effect\");\n              continue e;\n            }\n\n          case 'compute':\n            Ie = 'watch' === c.meta.op, v.value = He(g, k, v), Ie = d.isWatch;\n        }\n\n        u = g.fail || f;\n      }\n\n      if (!u) for (var A = 0; A < c.next.length; A++) Pe('child', l, c.next[A], v, de(v), he(v));\n    }\n\n    De = d.isRoot, Me = d.currentPage, je = he(d);\n  }\n}\n\nfunction u(e, r) {\n  void 0 === r && (r = 'combine');\n  var n = r + '(',\n      t = '',\n      a = 0;\n\n  for (var o in e) {\n    var i = e[o];\n    if (null != i && (n += t, n += C(i) ? i.compositeName.fullName : i.toString()), 25 === (a += 1)) break;\n    t = ', ';\n  }\n\n  return n + ')';\n}\n\nfunction f(e, r) {\n  var n,\n      t,\n      a,\n      o = e;\n  return r ? (a = r.compositeName, 0 === e.length ? (n = a.path, t = a.fullName) : (n = a.path.concat([e]), t = 0 === a.fullName.length ? e : a.fullName + '/' + e)) : (n = 0 === e.length ? [] : [e], t = e), {\n    shortName: o,\n    fullName: t,\n    path: n\n  };\n}\n\nfunction c(e, r) {\n  for (var n in e) r(e[n], n);\n}\n\nfunction s(e, r) {\n  e.forEach(r);\n}\n\nfunction l(e, r, n, t) {\n  var a = Me,\n      o = null;\n  if (r) for (o = Me; o && o.template !== r;) o = ve(o);\n  ze(o);\n  var i = e.create(n, t);\n  return ze(a), i;\n}\n\nfunction p(e, r) {\n  var n = function e(r) {\n    for (var n = arguments.length, a = new Array(n > 1 ? n - 1 : 0), o = 1; o < n; o++) a[o - 1] = arguments[o];\n\n    return Me ? l(e, t, r, a) : e.create(r, a);\n  };\n\n  n.graphite = o({\n    meta: ar(\"event\", n, r, e),\n    regional: 1\n  }), n.create = function (e) {\n    return i(je ? je.find(n) : n, e), e;\n  }, n.watch = G(rr, n), n.map = function (e) {\n    var r, t;\n    E(e) && (r = e, t = e.name, e = e.fn);\n    var a = p(Be(n, t), r);\n    return ir(n, a, j, e), a;\n  }, n.filter = function (e) {\n    return ur(n, \"filter\", e.fn ? e : e.fn, [Y({\n      fn: ie\n    })]);\n  }, n.filterMap = function (e) {\n    return ur(n, 'filterMap', e, [X({\n      fn: ie\n    }), Q.defined()]);\n  }, n.prepend = function (e) {\n    var r = p('* → ' + n.shortName, {\n      parent: ve(n)\n    }),\n        t = be();\n    return t && ue(r).seq.push(t.upward), ir(r, n, 'prepend', e), tr(n, r), r;\n  };\n  var t = be();\n  return n;\n}\n\nfunction d(e, n) {\n  function a(e, r) {\n    p.off(e), me(p).set(e, Ye(fr(e, p, 'on', 1, r, v)));\n  }\n\n  var u = ne(e),\n      f = ne(e),\n      c = or('updates'),\n      s = be();\n  u.after = [{\n    type: 'copy',\n    to: f\n  }], s && s.plain.push(u, f);\n  var l = u.id,\n      p = {\n    subscribers: new Map(),\n    updates: c,\n    defaultState: e,\n    stateRef: u,\n    getState: function () {\n      var e,\n          r = u;\n\n      if (Me) {\n        for (var n = Me; n && !n.reg[l];) n = ve(n);\n\n        n && (e = n);\n      }\n\n      return !e && je && je.reg[l] && (e = je), e && (r = e.reg[l]), te(r);\n    },\n    setState: function (e) {\n      var r;\n      je && (r = je.nodeMap[ue(p).id]), r || (r = p), i({\n        target: r,\n        params: e,\n        defer: 1\n      });\n    },\n    reset: function () {\n      for (var e = arguments.length, r = new Array(e), n = 0; n < e; n++) r[n] = arguments[n];\n\n      for (var t = 0, a = r; t < a.length; t++) {\n        var o = a[t];\n        p.on(o, function () {\n          return p.defaultState;\n        });\n      }\n\n      return p;\n    },\n    on: function (e, n) {\n      if (t(e, '.on', 'first argument'), Array.isArray(e)) for (var o, i = r(e); !(o = i()).done;) a(o.value, n);else a(e, n);\n      return p;\n    },\n    off: function (e) {\n      var r = me(p).get(e);\n      return r && (r(), me(p).delete(e)), p;\n    },\n    map: function (e, r) {\n      var n, t, a;\n      E(e) && (n = e, t = e.name, r = e.firstState, e = e.fn);\n      var o = p.getState(),\n          i = be();\n      i ? a = null : void 0 !== o && (a = e(o, r));\n      var f = d(a, {\n        name: Be(p, t),\n        config: n,\n        strict: 0\n      }),\n          c = fr(p, f, j, 0, e);\n      return se(f).before = [{\n        type: j,\n        fn: e,\n        from: u\n      }], i && ($e(i.plain, u) || $e(c.seq, i.loader) || c.seq.unshift(i.loader)), f;\n    },\n    watch: function (e, r) {\n      if (!r || !C(e)) {\n        var n = rr(p, e),\n            t = be();\n        return t ? t.watch.push({\n          of: u,\n          fn: e\n        }) : e(p.getState()), n;\n      }\n\n      return z(r) || M('second argument should be a function'), e.watch(function (e) {\n        return r(p.getState(), e);\n      });\n    }\n  },\n      m = ar(N, p, n),\n      v = p.defaultConfig.updateFilter;\n  return p.graphite = o({\n    scope: {\n      state: u\n    },\n    node: [Q.defined(), Q.changed({\n      store: f\n    }), v && L({\n      store: f,\n      to: \"a\"\n    }), v && Y({\n      fn: function (e, r, n) {\n        return v(e, n.a);\n      }\n    }), ee({\n      store: u\n    }), ee({\n      store: f\n    })],\n    child: c,\n    meta: m,\n    regional: 1\n  }), Oe && void 0 === e && M(\"current state can't be undefined, use null instead\"), ge(p, [c]), p;\n}\n\nfunction m() {\n  for (var e = arguments.length, r = new Array(e), n = 0; n < e; n++) r[n] = arguments[n];\n\n  var t, a, o;\n  Ge(r[0], function (e, n) {\n    o = e, r = n;\n  });\n  var i,\n      u,\n      f = r[r.length - 1];\n\n  if (z(f) ? (a = r.slice(0, -1), t = f) : a = r, 1 === a.length) {\n    var c = a[0];\n    F(c) || (i = c, u = 1);\n  }\n\n  return u || (i = a, t && (t = cr(t))), E(i) || M('shape should be an object'), sr(Array.isArray(i), i, o, t);\n}\n\nfunction v() {\n  var e = {};\n  return e.req = new Promise(function (r, n) {\n    e.rs = r, e.rj = n;\n  }), e.req.catch(function () {}), e;\n}\n\nfunction h(e, r) {\n  var n = p(e, r),\n      t = n.defaultConfig.handler || function () {\n    return M(\"no handler used in \" + n.getType());\n  },\n      a = ue(n);\n\n  a.meta.onCopy = ['runner'], a.meta.unit = n.kind = \"effect\", n.use = function (e) {\n    return z(e) || M('.use argument should be a function'), t = e, n;\n  };\n  var u = n.finally = or('finally'),\n      f = n.done = u.filterMap({\n    named: 'done',\n    fn: function (e) {\n      if ('done' === e.status) return {\n        params: e.params,\n        result: e.result\n      };\n    }\n  }),\n      c = n.fail = u.filterMap({\n    named: 'fail',\n    fn: function (e) {\n      if ('fail' === e.status) return {\n        params: e.params,\n        error: e.error\n      };\n    }\n  }),\n      s = n.doneData = f.map({\n    named: 'doneData',\n    fn: function (e) {\n      return e.result;\n    }\n  }),\n      l = n.failData = c.map({\n    named: 'failData',\n    fn: function (e) {\n      return e.error;\n    }\n  }),\n      m = o({\n    scope: {\n      getHandler: n.use.getCurrent = function () {\n        return t;\n      },\n      finally: u\n    },\n    node: [Z({\n      fn: function (e, r, n) {\n        var t,\n            a = e.params,\n            o = e.req,\n            i = r.finally,\n            u = r.getHandler,\n            f = lr({\n          params: a,\n          req: o,\n          ok: 1,\n          anyway: i,\n          stack: n\n        }),\n            c = lr({\n          params: a,\n          req: o,\n          ok: 0,\n          anyway: i,\n          stack: n\n        });\n\n        try {\n          t = u()(a);\n        } catch (s) {\n          return void c(s);\n        }\n\n        E(t) && z(t.then) ? t.then(f, c) : f(t);\n      }\n    })],\n    meta: {\n      op: 'fx',\n      fx: 'runner',\n      onCopy: ['finally']\n    }\n  });\n  a.scope.runner = m, a.seq.push(X({\n    fn: function (e, r, n) {\n      return ve(n) ? {\n        params: e,\n        req: {\n          rs: function () {},\n          rj: function () {}\n        }\n      } : e;\n    }\n  }), Z({\n    fn: function (e, r, n) {\n      return i({\n        target: r.runner,\n        params: e,\n        defer: 1,\n        forkPage: he(n)\n      }), e.params;\n    }\n  })), n.create = function (e) {\n    var r = v(),\n        t = {\n      params: e,\n      req: r\n    };\n\n    if (je) {\n      if (!Ie) {\n        var a = je;\n        r.req.finally(function () {\n          Ee(a);\n        }).catch(function () {});\n      }\n\n      i(je.find(n), t);\n    } else i(n, t);\n\n    return r.req;\n  };\n  var h = n.inFlight = d(0, {\n    named: 'inFlight'\n  }).on(n, function (e) {\n    return e + 1;\n  }).on(u, function (e) {\n    return e - 1;\n  }),\n      g = n.pending = h.map({\n    fn: function (e) {\n      return e > 0;\n    },\n    named: 'pending'\n  });\n  return ge(n, [u, f, c, s, l, g, h, m]), n;\n}\n\nfunction g(e, r) {\n  var n = p(r || u(e, 'merge'));\n  return t(e, 'merge', 'first argument'), er({\n    from: e,\n    to: n,\n    meta: {\n      op: 'merge'\n    }\n  }), n;\n}\n\nfunction y(e) {\n  var r = 0;\n  return s(mr, function (n) {\n    n in e && (null == e[n] && M(\"sample: \" + n + \" should be defined\"), r = 1);\n  }), r;\n}\n\nfunction b() {\n  for (var e, r, n = arguments.length, a = new Array(n), i = 0; i < n; i++) a[i] = arguments[i];\n\n  var u,\n      f,\n      c = Ve(a),\n      s = c[0],\n      l = s[0],\n      v = s[1],\n      h = s[2],\n      b = c[1];\n  void 0 === v && E(l) && y(l) && (v = l.clock, h = l.fn, f = l.greedy, e = l.target, r = l.name, u = l.sid, l = l.source);\n  var k = 1;\n  void 0 === l && (t(v, 'sample', 'clock'), Array.isArray(v) && (v = g(v)), l = v, k = 0), k && !C(l) && (l = m(l)), void 0 === v && (v = l), t(v, 'sample', 'clock'), r = b || r || l.shortName;\n  var w = be(),\n      x = !!e;\n  if (!e) if (F(l) && F(v)) {\n    var S = h ? h(te(se(l)), te(se(v))) : te(se(l));\n    e = d(S, {\n      name: r,\n      sid: u\n    });\n  } else e = p(r), w && ue(e).seq.push(w.loader);\n  var A = x && C(e) && ue(e).meta.nativeTemplate;\n\n  if (F(l)) {\n    var q = se(l);\n    ge(l, [Ze(v, e, {\n      scope: {\n        fn: h,\n        targetTemplate: A\n      },\n      node: [w && w.loader, !f && K({\n        priority: \"sampler\"\n      }), L({\n        store: q,\n        to: h ? \"a\" : O\n      }), h && X({\n        fn: oe\n      }), w && x && w.upward],\n      meta: {\n        op: \"sample\",\n        sample: N\n      }\n    })]), w && ($e(w.plain, q) || $e(w.closure, q) || w.closure.push(q));\n  } else {\n    var j = ne(0),\n        P = ne(),\n        R = ne();\n    w && w.plain.push(j, P, R), o({\n      parent: l,\n      node: [ee({\n        store: P\n      }), L({\n        from: \"value\",\n        store: 1,\n        target: j\n      })],\n      family: {\n        owners: [l, e, v],\n        links: e\n      },\n      meta: {\n        op: \"sample\",\n        sample: 'source'\n      },\n      regional: 1\n    }), ge(l, [Ze(v, e, {\n      scope: {\n        fn: h,\n        targetTemplate: A\n      },\n      node: [w && w.loader, ee({\n        store: R\n      }), L({\n        store: j\n      }), Y({\n        fn: function (e) {\n          return e;\n        }\n      }), !f && K({\n        priority: \"sampler\"\n      }), L({\n        store: P\n      }), L({\n        store: R,\n        to: \"a\"\n      }), h && X({\n        fn: ae\n      }), w && x && w.upward],\n      meta: {\n        op: \"sample\",\n        sample: 'clock'\n      }\n    })]);\n  }\n\n  return e;\n}\n\nfunction k(e) {\n  var r = Object.values(e),\n      n = {};\n  return s(r, function (e) {\n    n[e.id] = [];\n  }), s(r, function (e) {\n    var r = e.id,\n        t = e.before,\n        a = e.after;\n    t && s(t, function (e) {\n      n[e.from.id].push(r);\n    }), a && s(a, function (e) {\n      n[r].push(e.to.id);\n    });\n  }), n;\n}\n\nfunction w(e, n) {\n  if (void 0 === n && (n = function () {}), e instanceof Map) {\n    for (var t, a = {}, o = r(e); !(t = o()).done;) {\n      var i = t.value,\n          u = i[0],\n          f = i[1];\n      C(u) || M('Map key should be a unit'), n(u, f), a[u.sid] = f;\n    }\n\n    return a;\n  }\n\n  return e;\n}\n\nfunction x(e, r) {\n  function n(e) {\n    u[e] = 1;\n\n    for (var r = t[e], a = 0; a < r.length; a++) {\n      var f = r[a];\n      u[f] || i[f] || n(f);\n    }\n\n    u[e] = 0, i[e] = 1, o.push(e);\n  }\n\n  var t = {};\n\n  for (var a in e) t[a] = [].concat(new Set(e[a]));\n\n  var o = [],\n      i = {},\n      u = {};\n\n  for (var f in t) i[f] || u[f] || n(f);\n\n  return o.reverse(), r && r.size > 0 && function () {\n    for (var e, n = [], a = [].concat(r); e = a.shift();) n.push(e), s(t[e], function (e) {\n      $e(n, e) || $e(a, e) || a.push(e);\n    });\n\n    s(n, function (e) {\n      Je(o, e);\n    });\n  }(), o;\n}\n\nfunction S(e) {\n  var r = [];\n  return function e(n) {\n    $e(r, n) || (r.push(n), A(n, e));\n  }(ue(e)), r;\n}\n\nfunction A(e, r) {\n  var n = e.meta.unit;\n  'fork' !== n && \"forkInFlightCounter\" !== n && (s(e.next, r), s(fe(e), r), s(ce(e), r));\n}\n\nObject.defineProperty(exports, '__esModule', {\n  value: 1\n});\n\nfor (var q = 'undefined' != typeof Symbol && Symbol.observable || '@@observable', N = 'store', j = 'map', O = 'stack', C = function (e) {\n  return (z(e) || E(e)) && ('kind' in e);\n}, P = function (e) {\n  return function (r) {\n    return C(r) && r.kind === e;\n  };\n}, F = P(N), R = P(\"event\"), _ = P(\"effect\"), D = P(\"domain\"), I = {\n  __proto__: null,\n  unit: C,\n  store: F,\n  event: R,\n  effect: _,\n  domain: D\n}, M = function (e) {\n  throw Error(e);\n}, E = function (e) {\n  return 'object' == typeof e && null !== e;\n}, z = function (e) {\n  return 'function' == typeof e;\n}, T = function (e) {\n  E(e) || z(e) || M('expect first argument be an object');\n}, W = function () {\n  var e = 0;\n  return function () {\n    return (++e).toString(36);\n  };\n}, H = W(), U = W(), B = W(), G = function (e, r) {\n  return e.bind(null, r);\n}, V = function (e, r, n) {\n  return e.bind(null, r, n);\n}, $ = function (e, r, n) {\n  return {\n    id: U(),\n    type: e,\n    data: n,\n    hasRef: r\n  };\n}, J = 0, K = function (e) {\n  var r = e.priority;\n  return $(\"barrier\", 0, {\n    barrierID: ++J,\n    priority: void 0 === r ? \"barrier\" : r\n  });\n}, L = function (e) {\n  var r = e.from,\n      n = void 0 === r ? N : r,\n      t = e.target,\n      a = e.to;\n  return $('mov', n === N, {\n    from: n,\n    store: e.store,\n    to: void 0 === a ? t ? N : O : a,\n    target: t\n  });\n}, Q = {\n  defined: function () {\n    return $('check', 0, {\n      type: 'defined'\n    });\n  },\n  changed: function (e) {\n    return $('check', 1, {\n      type: 'changed',\n      store: e.store\n    });\n  }\n}, X = V($, 'compute', 0), Y = V($, \"filter\", 0), Z = V($, 'run', 0), ee = function (e) {\n  return L({\n    from: O,\n    target: e.store\n  });\n}, re = {\n  __proto__: null,\n  barrier: K,\n  mov: L,\n  check: Q,\n  compute: X,\n  filter: Y,\n  run: Z,\n  update: ee\n}, ne = function (e) {\n  return {\n    id: U(),\n    current: e\n  };\n}, te = function (e) {\n  return e.current;\n}, ae = function (e, r, n) {\n  return (0, r.fn)(e, n.a);\n}, oe = function (e, r, n) {\n  return (0, r.fn)(n.a, e);\n}, ie = function (e, r) {\n  return (0, r.fn)(e);\n}, ue = function (e) {\n  return e.graphite || e;\n}, fe = function (e) {\n  return e.family.owners;\n}, ce = function (e) {\n  return e.family.links;\n}, se = function (e) {\n  return e.stateRef;\n}, le = function (e) {\n  return e.config;\n}, pe = function (e) {\n  return e.ɔ;\n}, de = function (e) {\n  return e.value;\n}, me = function (e) {\n  return e.subscribers;\n}, ve = function (e) {\n  return e.parent;\n}, he = function (e) {\n  return e.forkPage;\n}, ge = function (e, r) {\n  for (var n = ue(e), t = 0; t < r.length; t++) {\n    var a = ue(r[t]);\n    \"domain\" !== n.family.type && (a.family.type = \"crosslink\"), fe(a).push(n), ce(n).push(a);\n  }\n}, ye = null, be = function () {\n  return ye && ye.template;\n}, ke = function (e) {\n  return e && ye && ye.sidRoot && (e = ye.sidRoot + \"ɔ\" + e), e;\n}, we = function (e) {\n  void 0 === e && (e = []);\n  var r = [];\n  if (Array.isArray(e)) for (var n = 0; n < e.length; n++) Array.isArray(e[n]) ? r.push.apply(r, e[n]) : r.push(e[n]);else r.push(e);\n  return r.map(ue);\n}, xe = function (e, r) {\n  var n,\n      t = e.type,\n      a = e.data;\n  e.hasRef && (r[(n = a.store).id] = n), 'mov' === t && a.to === N && (r[(n = a.target).id] = n);\n}, Se = null, Ae = function e(r, n) {\n  if (!r) return n;\n  if (!n) return r;\n  var t,\n      a = r.v.type === n.v.type;\n  return (a && r.v.id > n.v.id || !a && \"sampler\" === r.v.type) && (t = r, r = n, n = t), t = e(r.r, n), r.r = r.l, r.l = t, r;\n}, qe = [], Ne = 0; Ne < 5;) qe.push({\n  first: null,\n  last: null,\n  size: 0\n}), Ne += 1;\n\nvar je,\n    Oe,\n    Ce = function () {\n  for (var e = 0; e < 5; e++) {\n    var r = qe[e];\n\n    if (r.size > 0) {\n      if (2 === e || 3 === e) {\n        r.size -= 1;\n        var n = Se.v;\n        return Se = Ae(Se.l, Se.r), n;\n      }\n\n      1 === r.size && (r.last = null);\n      var t = r.first;\n      return r.first = t.r, r.size -= 1, t.v;\n    }\n  }\n},\n    Pe = function (e, r, n, t, a, o) {\n  return Fe(0, {\n    a: null,\n    b: null,\n    node: n,\n    parent: t,\n    value: a,\n    page: r,\n    forkPage: o\n  }, e);\n},\n    Fe = function (e, r, n, t) {\n  void 0 === t && (t = 0);\n  var a = Re(n),\n      o = qe[a],\n      i = {\n    v: {\n      idx: e,\n      stack: r,\n      type: n,\n      id: t\n    },\n    l: 0,\n    r: 0\n  };\n  2 === a || 3 === a ? Se = Ae(Se, i) : (0 === o.size ? o.first = i : o.last.r = i, o.last = i), o.size += 1;\n},\n    Re = function (e) {\n  switch (e) {\n    case 'child':\n      return 0;\n\n    case 'pure':\n      return 1;\n\n    case \"barrier\":\n      return 2;\n\n    case \"sampler\":\n      return 3;\n\n    case \"effect\":\n      return 4;\n\n    default:\n      return -1;\n  }\n},\n    _e = new Set(),\n    De = 1,\n    Ie = 0,\n    Me = null,\n    Ee = function (e) {\n  je = e;\n},\n    ze = function (e) {\n  Me = e;\n},\n    Te = function (e, r) {\n  if (e) {\n    for (; e && !e.reg[r];) e = ve(e);\n\n    if (e) return e;\n  }\n\n  return null;\n},\n    We = function (e, r, n) {\n  return (Te(e, n) || r).reg[n];\n},\n    He = function (e, r, n) {\n  var t = r.fn;\n\n  try {\n    return t(de(n), e.scope, n);\n  } catch (a) {\n    console.error(a), e.fail = 1;\n  }\n},\n    Ue = function (e, r) {\n  return '' + e.shortName + r;\n},\n    Be = function (e, r) {\n  return null == r ? Ue(e, ' → *') : r;\n},\n    Ge = function (e, r) {\n  T(e), pe(e) && r(le(e), pe(e));\n},\n    Ve = function (e) {\n  var r;\n  return Ge(e[0], function (n, t) {\n    r = n, e = t;\n  }), [e, r];\n},\n    $e = function (e, r) {\n  return e.includes(r);\n},\n    Je = function (e, r) {\n  var n = e.indexOf(r);\n  -1 !== n && e.splice(n, 1);\n},\n    Ke = function (e, r) {\n  Je(e.next, r), Je(fe(e), r), Je(ce(e), r);\n},\n    Le = function e(r, n, t) {\n  var a;\n  r.next.length = 0, r.seq.length = 0, r.scope = null;\n\n  for (var o = ce(r); a = o.pop();) Ke(a, r), (n || t && !r.meta.sample || \"crosslink\" === a.family.type) && e(a, n, 'on' !== a.meta.op && t);\n\n  for (o = fe(r); a = o.pop();) Ke(a, r), t && \"crosslink\" === a.family.type && e(a, n, 'on' !== a.meta.op && t);\n},\n    Qe = function (e) {\n  return e.clear();\n},\n    Xe = function (e, r) {\n  var n = (void 0 === r ? {} : r).deep,\n      t = 0;\n  if (e.ownerSet && e.ownerSet.delete(e), F(e)) Qe(me(e));else if (D(e)) {\n    t = 1;\n    var a = e.history;\n    Qe(a.events), Qe(a.effects), Qe(a.stores), Qe(a.domains);\n  }\n  Le(ue(e), !!n, t);\n},\n    Ye = function (e) {\n  var r = V(Xe, e, void 0);\n  return r.unsubscribe = r, r;\n},\n    Ze = function (e, r, n) {\n  return o({\n    node: n.node,\n    parent: e,\n    child: r,\n    scope: n.scope,\n    meta: n.meta,\n    family: {\n      owners: [e, r],\n      links: r\n    },\n    regional: 1\n  });\n},\n    er = function (e) {\n  var r;\n  Ge(e, function (n, t) {\n    r = n, e = t;\n  });\n  var n = e.from,\n      a = e.to,\n      i = e.meta,\n      u = void 0 === i ? {\n    op: 'forward'\n  } : i;\n  return t(n, 'forward', '\"from\"'), t(a, 'forward', '\"to\"'), r && (u.config = r), Ye(o({\n    parent: n,\n    child: a,\n    meta: u,\n    family: {},\n    regional: 1\n  }));\n},\n    rr = function (e, r) {\n  if (z(r) || M('.watch argument should be a function'), je) {\n    var n = je.nodeMap[ue(e).id];\n    n && (e = n);\n  }\n\n  return Ye(o({\n    scope: {\n      fn: r\n    },\n    node: [Z({\n      fn: ie\n    })],\n    parent: e,\n    meta: {\n      op: 'watch'\n    },\n    family: {\n      owners: e\n    },\n    regional: 1\n  }));\n},\n    nr = function e(r, n) {\n  return E(r) && (e(le(r), n), null != r.name && (E(r.name) ? e(r.name, n) : z(r.name) ? n.handler = r.name : n.name = r.name), r.loc && (n.loc = r.loc), (r.sid || null === r.sid) && (n.sid = r.sid), r.handler && (n.handler = r.handler), r.updateFilter && (n.updateFilter = r.updateFilter), ve(r) && (n.parent = ve(r)), 'strict' in r && (n.strict = r.strict), r.named && (n.named = r.named), e(pe(r), n)), n;\n},\n    tr = function (e, r, n) {\n  void 0 === n && (n = \"event\"), ve(e) && ve(e).hooks[n](r);\n},\n    ar = function (e, r, n, t) {\n  var a = nr({\n    name: t,\n    config: n\n  }, {}),\n      o = \"domain\" === e,\n      i = H(),\n      u = a.parent,\n      c = void 0 === u ? null : u,\n      s = a.sid,\n      l = void 0 === s ? null : s,\n      p = a.strict,\n      d = void 0 === p ? 1 : p,\n      m = a.named,\n      v = void 0 === m ? null : m,\n      h = v || a.name || (o ? '' : i),\n      g = f(h, c),\n      y = {\n    unit: r.kind = e,\n    name: r.shortName = h,\n    sid: r.sid = ke(l),\n    named: v,\n    unitId: r.id = i\n  };\n\n  if (r.parent = c, r.compositeName = g, r.defaultConfig = a, r.thru = function (e) {\n    return e(r);\n  }, r.getType = function () {\n    return g.fullName;\n  }, !o) {\n    r.subscribe = function (e) {\n      return T(e), r.watch(z(e) ? e : function (r) {\n        e.next && e.next(r);\n      });\n    }, r[q] = function () {\n      return r;\n    };\n    var b = be();\n    b && (y.nativeTemplate = b);\n  }\n\n  return Oe = d, y;\n},\n    or = function (e) {\n  return p({\n    named: e\n  });\n},\n    ir = function (e, r, n, t) {\n  return Ze(e, r, {\n    scope: {\n      fn: t\n    },\n    node: [X({\n      fn: ie\n    })],\n    meta: {\n      op: n\n    }\n  });\n},\n    ur = function (e, r, n, t) {\n  var a;\n  E(n) && (a = n, n = n.fn);\n  var o = p(Ue(e, ' →? *'), a);\n  return Ze(e, o, {\n    scope: {\n      fn: n\n    },\n    node: t,\n    meta: {\n      op: r\n    }\n  }), o;\n},\n    fr = function (e, r, n, t, a, o) {\n  var i = se(r),\n      u = [L({\n    store: i,\n    to: \"a\"\n  }), X({\n    fn: t ? oe : ae\n  }), Q.defined(), Q.changed({\n    store: i\n  }), o && Y({\n    fn: function (e, r, n) {\n      return o(e, n.a);\n    }\n  }), ee({\n    store: i\n  })],\n      f = be();\n\n  if (f && (u.unshift(f.loader), u.push(f.upward), F(e))) {\n    var c = se(e);\n    $e(f.plain, c) || ($e(f.closure, c) || f.closure.push(c), i.before || (i.before = []), i.before.push({\n      type: 'closure',\n      of: c\n    }));\n  }\n\n  return Ze(e, r, {\n    scope: {\n      fn: a\n    },\n    node: u,\n    meta: {\n      op: n\n    }\n  });\n},\n    cr = function (e) {\n  return function (r) {\n    return e.apply(void 0, r);\n  };\n},\n    sr = function (e, r, n, t) {\n  var a = e ? function (e) {\n    return e.slice();\n  } : function (e) {\n    return Object.assign({}, e);\n  },\n      o = e ? [] : {},\n      i = be(),\n      f = a(o),\n      s = ne(f),\n      l = ne(1);\n  s.type = e ? 'list' : 'shape', i && i.plain.push(s, l);\n  var p = d(f, {\n    name: n || u(r)\n  });\n  ue(p).meta.isCombine = 1;\n  var m = [Q.defined(), L({\n    store: s,\n    to: \"a\"\n  }), Y({\n    fn: function (e, r, n) {\n      return e !== n.a[r.key];\n    }\n  }), L({\n    store: l,\n    to: 'b'\n  }), X({\n    fn: function (e, r, n) {\n      var t = r.key;\n      n.b && (n.a = (0, r.clone)(n.a)), n.a[t] = e;\n    }\n  }), L({\n    from: \"a\",\n    target: s\n  }), L({\n    from: \"value\",\n    store: 0,\n    target: l\n  }), K({\n    priority: \"barrier\"\n  }), L({\n    from: \"value\",\n    store: 1,\n    target: l\n  }), L({\n    store: s\n  }), t && X({\n    fn: t\n  }), Q.changed({\n    store: se(p)\n  })],\n      v = s.before = [];\n  return c(r, function (e, r) {\n    if (F(e)) {\n      o[r] = e.defaultState, f[r] = e.getState();\n      var n = Ze(e, p, {\n        scope: {\n          key: r,\n          clone: a\n        },\n        node: m,\n        meta: {\n          op: 'combine'\n        }\n      }),\n          t = se(e);\n      v.push({\n        type: 'field',\n        field: r,\n        from: t\n      }), i && ($e(i.plain, t) || n.seq.unshift(i.loader));\n    } else f[r] = o[r] = e;\n  }), p.defaultShape = r, s.after = [t ? {\n    type: j,\n    to: se(p),\n    fn: t\n  } : {\n    type: 'copy',\n    to: se(p)\n  }], i || (p.defaultState = t ? se(p).current = t(f) : o), p;\n},\n    lr = function (e) {\n  var r = e.params,\n      n = e.req,\n      t = e.ok,\n      a = e.anyway,\n      o = e.stack;\n  return function (e) {\n    return i({\n      target: [a, pr],\n      params: [t ? {\n        status: 'done',\n        params: r,\n        result: e\n      } : {\n        status: 'fail',\n        params: r,\n        error: e\n      }, {\n        fn: t ? n.rs : n.rj,\n        value: e\n      }],\n      defer: 1,\n      page: o.page,\n      forkPage: he(o)\n    });\n  };\n},\n    pr = o({\n  node: [Z({\n    fn: function (e) {\n      (0, e.fn)(e.value);\n    }\n  })],\n  meta: {\n    op: 'fx',\n    fx: 'sidechain'\n  }\n}),\n    dr = function (e, r, n) {\n  return e.create = function (r) {\n    return i(e, r), r;\n  }, ue(e).seq.push(X({\n    fn: function (e, r, n) {\n      return n.forkPage = null, e;\n    }\n  })), e.watch(function (e) {\n    ge(n, [e]), r.add(e), e.ownerSet || (e.ownerSet = r), ve(e) || (e.parent = n);\n  }), ge(n, [e]), function (n) {\n    return r.forEach(n), e.watch(n);\n  };\n},\n    mr = ['source', 'clock', 'target'],\n    vr = function (e, r, n, t) {\n  var a = e[r];\n  a && i({\n    target: a,\n    params: Array.isArray(a) ? a.map(function () {\n      return n;\n    }) : n,\n    defer: 1,\n    stack: t\n  });\n};\n\nexports.allSettled = function (e, r) {\n  var n = r.scope,\n      t = r.params;\n  if (!C(e)) return Promise.reject(Error('first argument should be unit'));\n  var a = v();\n  a.parentFork = je;\n  var o = n.graphite.scope.forkInFlightCounter;\n  o.scope.defers.push(a);\n  var u = [n.find(e)],\n      f = [];\n  return _(e) ? f.push({\n    params: t,\n    req: {\n      rs: function (e) {\n        a.value = {\n          status: 'done',\n          value: e\n        };\n      },\n      rj: function (e) {\n        a.value = {\n          status: 'fail',\n          value: e\n        };\n      }\n    }\n  }) : f.push(t), u.push(o), f.push(null), i({\n    target: u,\n    params: f,\n    forkPage: n\n  }), a.req;\n}, exports.attach = function (e) {\n  var r, n;\n  Ge(e, function (r, t) {\n    n = r, e = t;\n  });\n  var t = e.source,\n      a = e.effect,\n      o = e.mapParams;\n  o || (o = t ? function (e, r) {\n    return r;\n  } : function (e) {\n    return e;\n  });\n\n  var u,\n      f = h(e, n),\n      c = ue(f).scope.runner,\n      s = function (e, r, n) {\n    var t,\n        a = e.params,\n        u = e.req,\n        f = r.finally,\n        c = r.effect,\n        s = lr({\n      params: a,\n      req: u,\n      ok: 0,\n      anyway: f,\n      stack: n\n    });\n\n    try {\n      t = o(a, n.a);\n    } catch (l) {\n      return s(l);\n    }\n\n    i({\n      target: c,\n      params: {\n        params: t,\n        req: {\n          rs: lr({\n            params: a,\n            req: u,\n            ok: 1,\n            anyway: f,\n            stack: n\n          }),\n          rj: s\n        }\n      },\n      page: n.page,\n      defer: 1\n    });\n  };\n\n  if (t) {\n    var l;\n    F(t) ? (l = t, ge(t, [f])) : (l = m(t), ge(f, [l]));\n    var p = L({\n      from: N,\n      store: se(l),\n      to: \"a\"\n    });\n    u = [Z({\n      fn: function (e) {\n        return e;\n      }\n    }), p, X({\n      fn: s\n    })], xe(p, c.reg);\n  } else u = [Z({\n    fn: s\n  })];\n\n  return ge(a, [f]), c.scope.effect = a, c.meta.onCopy.push(\"effect\"), (r = c.seq).splice.apply(r, [0, 1].concat(u)), tr(a, f, \"effect\"), f;\n}, exports.clearNode = Xe, exports.combine = m, exports.createApi = function () {\n  for (var e = arguments.length, r = new Array(e), n = 0; n < e; n++) r[n] = arguments[n];\n\n  var t = Ve(r),\n      a = t[0],\n      o = a[0],\n      i = a[1],\n      u = t[1],\n      f = {};\n  return c(i, function (e, r) {\n    var n = f[r] = p(r, {\n      parent: ve(o),\n      config: u\n    });\n    o.on(n, e), tr(o, n);\n  }), f;\n}, exports.createDomain = function e(r, n) {\n  var t = new Set(),\n      a = new Set(),\n      i = new Set(),\n      u = new Set(),\n      f = o({\n    family: {\n      type: \"domain\"\n    },\n    regional: 1\n  }),\n      s = {\n    history: {\n      domains: t,\n      stores: a,\n      effects: i,\n      events: u\n    },\n    graphite: f\n  };\n  f.meta = ar(\"domain\", s, n, r);\n  var l = ['onEvent', 'onEffect', 'onStore', 'onDomain'].map(or),\n      m = l[0],\n      v = l[1],\n      g = l[2],\n      y = l[3];\n  s.hooks = {\n    event: m,\n    effect: v,\n    store: g,\n    domain: y\n  }, s.onCreateEvent = dr(m, u, s), s.onCreateEffect = dr(v, i, s), s.onCreateStore = dr(g, a, s), s.onCreateDomain = dr(y, t, s), s.createEvent = s.event = function (e, r) {\n    return m(p(e, {\n      parent: s,\n      config: r\n    }));\n  }, s.createEffect = s.effect = function (e, r) {\n    return v(h(e, {\n      parent: s,\n      config: r\n    }));\n  }, s.createDomain = s.domain = function (r, n) {\n    return e({\n      name: r,\n      parent: s,\n      config: n\n    });\n  }, s.createStore = s.store = function (e, r) {\n    return g(d(e, {\n      parent: s,\n      config: r\n    }));\n  };\n  var b = ve(s);\n  return b && (c(s.hooks, function (e, r) {\n    er({\n      from: e,\n      to: b.hooks[r]\n    });\n  }), b.hooks.domain(s)), s;\n}, exports.createEffect = h, exports.createEvent = p, exports.createNode = o, exports.createStore = d, exports.createStoreObject = m, exports.fork = function (e, r) {\n  var n = void 0 === r ? {} : r,\n      t = n.values,\n      a = n.handlers;\n  D(e) || M('first argument of fork should be domain');\n  var i = !!t;\n  t = w(t || {}, function (e) {\n    return !F(e) && M('Values map can contain only stores as keys');\n  });\n\n  var u,\n      f,\n      l,\n      p,\n      d,\n      m,\n      v = function (e) {\n    function r(e) {\n      var r = ue(e),\n          t = n.indexOf(r);\n\n      if (-1 === t) {\n        var a = 'unit';\n        e !== r && e.id !== e.shortName && (a = e.shortName), M(a + \" not found in forked scope\");\n      }\n\n      return p[t];\n    }\n\n    var n = S(e),\n        t = new Map(),\n        a = new Set(),\n        i = X({\n      fn: function (e, r, n) {\n        return (!n.node.meta.isCombine || ve(n) && 'combine' !== ve(n).node.meta.op) && a.add(n.node.meta.forkOf.id), e;\n      }\n    }),\n        u = o({\n      scope: {\n        defers: [],\n        inFlight: 0,\n        fxID: 0\n      },\n      node: [X({\n        fn: function (e, r, n) {\n          n.parent ? 'finally' === n.parent.node.meta.named ? r.inFlight -= 1 : (r.inFlight += 1, r.fxID += 1) : r.fxID += 1;\n        }\n      }), K({\n        priority: \"sampler\"\n      }), Z({\n        fn: function (e, r) {\n          var n = r.defers,\n              t = r.fxID;\n          r.inFlight > 0 || 0 === n.length || Promise.resolve().then(function () {\n            r.fxID === t && s(n.splice(0, n.length), function (e) {\n              Ee(e.parentFork), e.rs(e.value);\n            });\n          });\n        }\n      })],\n      meta: {\n        unit: \"forkInFlightCounter\"\n      }\n    }),\n        f = {},\n        l = {},\n        p = n.map(function (e) {\n      var r = e.next,\n          n = e.meta,\n          t = e.scope,\n          a = o({\n        node: e.seq.map(function (e) {\n          return {\n            id: e.id,\n            type: e.type,\n            data: Object.assign({}, e.data),\n            hasRef: e.hasRef\n          };\n        }),\n        child: [].concat(r),\n        meta: Object.assign({\n          forkOf: e\n        }, n),\n        scope: Object.assign({}, t)\n      });\n      return a.family = {\n        type: e.family.type,\n        links: [].concat(ce(e)),\n        owners: [].concat(fe(e))\n      }, f[e.id] = a, n.sid && (l[n.sid] = a), a;\n    }),\n        d = {};\n    return s(p, function (e) {\n      var n = e.reg,\n          a = e.scope,\n          o = e.meta,\n          f = o.onCopy,\n          l = o.op,\n          p = o.unit;\n\n      switch (c(n, function (e, r) {\n        var a = t.get(e);\n        a || t.set(e, a = {\n          id: e.id,\n          current: e.current\n        }), d[r] = n[r] = a;\n      }), f && s(f, function (e) {\n        var n = a[e];\n        a[e] = Array.isArray(n) ? n.map(r) : r(n);\n      }), A(e, function (e, n, t) {\n        t[n] = r(e);\n      }), l || p) {\n        case N:\n          e.meta.wrapped = function (e) {\n            return {\n              kind: N,\n              getState: function () {\n                return e.reg[e.scope.state.id].current;\n              },\n              updates: {\n                watch: G(rr, e)\n              },\n              graphite: e,\n              family: e.family\n            };\n          }(e), e.meta.sid && e.seq.push(i);\n          break;\n\n        case \"effect\":\n          e.next.push(u);\n          break;\n\n        case 'fx':\n          a.finally.next.push(u);\n      }\n    }), {\n      cloneOf: e,\n      changedStores: a,\n      nodeMap: f,\n      sidMap: l,\n      clones: p,\n      find: r,\n      reg: d,\n      getState: function (e) {\n        return r(e).meta.wrapped.getState();\n      },\n      graphite: o({\n        family: {\n          type: \"domain\",\n          links: [u].concat(p)\n        },\n        meta: {\n          unit: 'fork'\n        },\n        scope: {\n          forkInFlightCounter: u\n        }\n      })\n    };\n  }(e);\n\n  if (i && (u = S(e), f = {}, l = {}, p = new Set(), d = new Set(), m = Object.getOwnPropertyNames(t), s(u, function (e) {\n    var r = e.meta.nativeTemplate;\n    c(e.reg, function (e, n) {\n      f[n] = e, r && d.add(n);\n    });\n  }), s(v.clones, function (e) {\n    var r = e.reg,\n        n = e.meta,\n        a = n.sid;\n\n    if (n.unit === N && a && $e(m, a)) {\n      var o = e.scope.state;\n      r[o.id].current = t[a], p.add(o), v.changedStores.add(e.meta.forkOf.id);\n    }\n\n    c(r, function (e, r) {\n      l[r] = e;\n    });\n  }), s(x(k(f), d), function (e) {\n    (function (e, r) {\n      var n = 0;\n\n      if (r && r.before && !p.has(e) && s(r.before, function (r) {\n        switch (r.type) {\n          case j:\n            e.current = r.fn(l[r.from.id].current);\n            break;\n\n          case 'field':\n            var t = l[r.from.id];\n            n || (n = 1, e.current = Array.isArray(e.current) ? [].concat(e.current) : Object.assign({}, e.current)), e.current[r.field] = t.current;\n        }\n      }), r && r.after) {\n        var t = e.current;\n        s(r.after, function (e) {\n          var r = l[e.to.id];\n\n          switch (e.type) {\n            case 'copy':\n              r.current = t;\n              break;\n\n            case j:\n              r.current = e.fn(t);\n          }\n        });\n      }\n    })(l[e], f[e]);\n  })), a) {\n    a = w(a, function (e) {\n      return !_(e) && M(\"Handlers map can contain only effects as keys\");\n    });\n    var h = Object.keys(a);\n    s(v.clones, function (e) {\n      var r = e.scope,\n          n = e.meta;\n      n.sid && $e(h, n.sid) && (r.runner.scope.getHandler = function () {\n        return a[n.sid];\n      });\n    });\n  }\n\n  return v;\n}, exports.forward = er, exports.fromObservable = function (e) {\n  T(e);\n  var r = q in e ? e[q]() : e;\n  r.subscribe || M('expect observable to have .subscribe');\n  var n = p(),\n      t = V(Xe, n, void 0);\n  return r.subscribe({\n    next: n,\n    error: t,\n    complete: t\n  }), n;\n}, exports.guard = function () {\n  for (var e = {\n    op: 'guard'\n  }, r = 'guard', n = arguments.length, a = new Array(n), i = 0; i < n; i++) a[i] = arguments[i];\n\n  var u = Ve(a),\n      f = u[0],\n      c = f[0],\n      s = f[1],\n      l = u[1];\n  l && (e.config = l, l.name && (r = l.name)), s || (c = (s = c).source);\n  var d = s,\n      v = d.filter,\n      h = d.greedy,\n      y = d.clock,\n      k = d.name,\n      w = void 0 === k ? r : k,\n      x = s.target || p(w, e.config),\n      S = C(v),\n      A = 1;\n  return void 0 === c && (t(y, 'guard', 'clock'), Array.isArray(y) && (y = g(y)), c = y, A = 0), A && !C(c) && (c = m(c)), y && (t(y, 'guard', 'clock'), c = b({\n    source: c,\n    clock: y,\n    greedy: h,\n    fn: S ? null : function (e, r) {\n      return {\n        source: e,\n        clock: r\n      };\n    }\n  })), t(x, 'guard', 'target'), S ? b({\n    source: v,\n    clock: c,\n    target: o({\n      node: [Y({\n        fn: function (e) {\n          return e.guard;\n        }\n      }), X({\n        fn: function (e) {\n          return e.data;\n        }\n      })],\n      child: x,\n      meta: e,\n      family: {\n        owners: [c, v, x].concat([].concat(y || [])),\n        links: x\n      },\n      regional: 1\n    }),\n    fn: function (e, r) {\n      return {\n        guard: e,\n        data: r\n      };\n    },\n    greedy: h,\n    name: w\n  }) : (z(v) || M('`filter` should be function or unit'), Ze(c, x, {\n    scope: {\n      fn: v\n    },\n    node: y ? [Y({\n      fn: function (e, r) {\n        return (0, r.fn)(e.source, e.clock);\n      }\n    }), X({\n      fn: function (e) {\n        return e.source;\n      }\n    })] : [Y({\n      fn: ie\n    })],\n    meta: e\n  })), x;\n}, exports.hydrate = function (e, r) {\n  var n = r.values,\n      t = E(e) && e.cloneOf;\n  D(e) || t || M('first argument of hydrate should be domain or scope'), E(n) || M('values property should be an object');\n  var a,\n      o,\n      u = w(n);\n  if (t) a = [], o = [], c(u, function (r, n) {\n    var t = e.sidMap[n];\n    t && (a.push(t), o.push(r), e.changedStores.add(t.meta.forkOf.id));\n  });else {\n    var f = function (e) {\n      var r = e.flatGraphUnits,\n          n = e.values,\n          t = e.collectWatches,\n          a = [],\n          o = [],\n          i = {},\n          u = new Set(),\n          f = Object.getOwnPropertyNames(n);\n      return s(r, function (e) {\n        var r = e.reg,\n            s = e.meta,\n            l = s.op,\n            p = s.sid;\n\n        if (s.unit === N && p && $e(f, p)) {\n          var d = e.scope.state;\n          d.current = n[p], u.add(d);\n        }\n\n        if (t && 'watch' === l) {\n          var m = e.family.owners[0];\n          m.meta.unit === N && (a.push(e), o.push(m.scope.state));\n        }\n\n        c(r, function (e, r) {\n          i[r] = e;\n        });\n      }), s(x(k(i)), function (e) {\n        (function (e) {\n          var r = 0;\n\n          if (e.before && !u.has(e) && s(e.before, function (n) {\n            switch (n.type) {\n              case j:\n                e.current = n.fn(n.from.current);\n                break;\n\n              case 'field':\n                var t = n.from;\n                r || (r = 1, e.current = Array.isArray(e.current) ? [].concat(e.current) : Object.assign({}, e.current)), e.current[n.field] = t.current;\n            }\n          }), e.after) {\n            var n = e.current;\n            s(e.after, function (e) {\n              var r = e.to;\n\n              switch (e.type) {\n                case 'copy':\n                  r.current = n;\n                  break;\n\n                case j:\n                  r.current = e.fn(n);\n              }\n            });\n          }\n        })(i[e]);\n      }), {\n        storeWatches: a,\n        storeWatchesRefs: o\n      };\n    }({\n      flatGraphUnits: S(e),\n      values: u,\n      collectWatches: 1\n    });\n\n    a = f.storeWatches, o = f.storeWatchesRefs.map(function (e) {\n      return e.current;\n    });\n  }\n  i({\n    target: a,\n    params: o,\n    forkPage: t ? e : 0\n  });\n}, exports.is = I, exports.launch = i, exports.merge = g, exports.restore = function (e, r, n) {\n  if (F(e)) return e;\n\n  if (C(e)) {\n    var t,\n        a = ve(e);\n    return R(e) && (t = d(r, {\n      parent: a,\n      name: e.shortName,\n      \"ɔ\": n\n    }).on(e, function (e, r) {\n      return r;\n    })), _(e) && (t = d(r, {\n      parent: a,\n      name: e.shortName,\n      \"ɔ\": n\n    }).on(e.done, function (e, r) {\n      return r.result;\n    })), a && a.hooks.store(t), t;\n  }\n\n  var o = Array.isArray(e) ? [] : {};\n  return c(e, function (e, r) {\n    o[r] = F(e) ? e : d(e, {\n      name: r\n    });\n  }), o;\n}, exports.sample = b, exports.scopeBind = function (e) {\n  je || M('scopeBind cannot be called outside of forked .watch');\n  var r = je,\n      n = je.find(e);\n  return _(e) ? function (e) {\n    var t = v();\n    i({\n      target: n,\n      params: {\n        params: e,\n        req: t\n      },\n      forkPage: r\n    });\n  } : function (e) {\n    return i({\n      target: n,\n      params: e,\n      forkPage: r\n    }), e;\n  };\n}, exports.serialize = function (e, r) {\n  var n = e.changedStores,\n      t = void 0 === r ? {} : r,\n      a = t.ignore,\n      o = void 0 === a ? [] : a,\n      i = t.onlyChanges,\n      u = {};\n  return s(e.clones, function (e) {\n    var r = e.meta,\n        t = e.scope,\n        a = e.reg;\n\n    if (r.unit === N) {\n      var o = r.sid;\n      o && (!i && !r.isCombine || n.has(r.forkOf.id)) && (u[o] = a[t.state.id].current);\n    }\n  }), s(o, function (e) {\n    var r = e.sid;\n    r && delete u[r];\n  }), u;\n}, exports.setStoreName = function (e, r) {\n  var n = f(r, ve(e));\n\n  if (e.shortName = r, e.compositeName) {\n    var t = e.compositeName;\n    t.path = n.path, t.shortName = n.shortName, t.fullName = n.fullName;\n  } else e.compositeName = n;\n}, exports.split = function () {\n  for (var e, r = arguments.length, n = new Array(r), t = 0; t < r; t++) n[t] = arguments[t];\n\n  var a = Ve(n),\n      i = a[0],\n      u = i[0],\n      f = i[1],\n      s = a[1],\n      l = !f;\n  l && (e = u.cases, f = u.match, u = u.source);\n  var d = F(f),\n      m = !C(f) && z(f),\n      v = !d && !m && E(f);\n  e || (e = {}), l || (v || M('match should be an object'), c(f, function (r, n) {\n    e[n] = p(s);\n  }), e.__ = p(s));\n  var h,\n      g = be(),\n      y = new Set([].concat(u, Object.values(e))),\n      b = Object.keys(d || m ? e : f);\n  if (d || m) d && y.add(f), h = [d && K({\n    priority: 'sampler'\n  }), d && L({\n    store: se(f),\n    to: 'a'\n  }), Y({\n    fn: function (e, r, n) {\n      var t = String(d ? n.a : f(e));\n      vr(r, $e(b, t) ? t : '__', e, n);\n    }\n  })];else if (v) {\n    var k = ne({});\n    k.type = 'shape';\n    var w,\n        x = k.before = [],\n        S = [L({\n      store: k,\n      to: \"a\"\n    }), X({\n      fn: function (e, r, n) {\n        n.a[r.key] = e;\n      }\n    })],\n        A = [];\n    c(f, function (e, r) {\n      if (C(e)) {\n        w = 1, A.push(r), y.add(e);\n        var n = Ze(e, [], {\n          node: S,\n          scope: {\n            key: r\n          }\n        });\n\n        if (F(e)) {\n          k.current[r] = e.getState();\n          var t = se(e);\n          x.push({\n            type: 'field',\n            field: r,\n            from: t\n          }), g && ($e(g.plain, t) || n.seq.unshift(g.loader));\n        }\n      }\n    }), w && g && g.plain.push(k), h = [w && K({\n      priority: 'sampler'\n    }), w && L({\n      store: k,\n      to: 'a'\n    }), Y({\n      fn: function (e, r, n) {\n        for (var t = 0; t < b.length; t++) {\n          var a = b[t];\n          if ($e(A, a) ? n.a[a] : f[a](e)) return void vr(r, a, e, n);\n        }\n\n        vr(r, '__', e, n);\n      }\n    })];\n  } else M('expect match to be unit, function or object');\n  if (o({\n    meta: {\n      onCopy: Object.keys(e),\n      op: 'split'\n    },\n    parent: u,\n    scope: e,\n    node: h,\n    family: {\n      type: 'crosslink',\n      owners: Array.from(y)\n    },\n    regional: 1\n  }), !l) return e;\n}, exports.step = re, exports.version = \"21.8.12\", exports.withFactory = function (e) {\n  var r = e.name,\n      n = e.loc,\n      t = e.method,\n      i = e.fn;\n  return a(o({\n    meta: {\n      sidRoot: ke(e.sid),\n      name: r,\n      loc: n,\n      method: t\n    }\n  }), i);\n}, exports.withRegion = a;","map":{"version":3,"sources":["effector/is.ts","effector/region.ts","effector/createNode.ts","effector/tag.ts","effector/kernel.ts","effector/naming.ts","effector/collection.ts","effector/createUnit.ts","effector/combine.ts","effector/defer.ts","effector/createEffect.ts","effector/merge.ts","effector/sample.ts","effector/fork.ts","effector/observable.ts","effector/validate.ts","effector/throw.ts","effector/id.ts","effector/bind.ts","effector/step.ts","effector/stateRef.ts","effector/caller.ts","effector/getter.ts","effector/own.ts","effector/config.ts","effector/clearNode.ts","effector/subscription.ts","effector/forward.ts","effector/watch.ts","effector/createDomain.ts","effector/split.ts","effector/attach.ts","effector/createApi.ts","effector/fromObservable.ts","effector/guard.ts","effector/restore.ts"],"names":["isObject","value","isFunction","assertObject","throwError","assertNodeSetItem","method","valueName","reason","assertNodeSet","Array","isArray","i","length","regionStack","readTemplate","template","readSidRoot","sid","sidRoot","withRegion","unit","cb","unitMeta","getGraph","meta","parent","getParent","name","loc","fn","createNode","arrifyNodes","list","result","push","map","addToReg","hasRef","type","data","reg","store","id","to","STORE","target","node","from","source","child","scope","family","familyRaw","regional","sources","links","owners","seq","item","nextNodeID","next","getOwners","getLinks","own","getValue","MAP","STACK","heap","merge","a","b","ret","isSameType","v","r","l","queue","ix","first","last","size","deleteMin","pushFirstHeapItem","page","forkPage","pushHeap","idx","stack","priority","getPriority","bucket","t","barriers","Set","isRoot","isWatch","currentPage","setForkPage","newForkPage","setCurrentPage","newPage","getPageForRef","getPageRef","launch","payload","upsert","pageForLaunch","stackForLaunch","forkPageForLaunch","params","defer","getForkPage","lastStartedState","stop","skip","kernelLoop","local","fail","stepn","step","barrierID","fullID","has","add","delete","readRef","current","undefined","tryRun","op","err","console","error","joinName","tag","shortName","mapName","unitObjectName","objOrArr","comma","key","is","compositeName","fullName","toString","rawName","createName","currentComposite","path","composite","concat","forIn","obj","includes","removeItem","pos","indexOf","splice","forEach","normalizeConfig","part","config","getConfig","handler","updateFilter","strict","named","getNestedConfig","applyParentHook","hookType","hooks","isStrict","initUnit","kind","rawConfigA","rawConfigB","isDomain","nextUnitID","unitId","defaultConfig","thru","getType","subscribe","observer","watch","upd","observableSymbol","nativeTemplate","createNamedEvent","createEvent","createComputation","createLinkNode","callStack","createEventFiltration","event","mapped","callCreate","args","oldPage","create","nameOrConfig","maybeConfig","graphite","find","bind","watchUnit","filter","filterMap","defined","prepend","contramapped","upward","createStore","defaultState","props","plainState","createStateRef","oldState","updates","after","plain","plainStateId","subscribers","Map","stateRef","getState","targetRef","reachedPage","setState","state","nodeMap","reset","units","on","nodeSet","onEvent","off","currentSubscription","getSubscribers","get","firstState","lastResult","storeState","innerStore","linkNode","updateStore","getStoreState","before","loader","unshift","eventOrFn","subscription","of","set","createSubscription","changed","update","_","stateFirst","storeRef","callARegStack","callStackAReg","ref","closure","combine","stores","onConfigNesting","injectedData","userConfig","rawHandler","slice","structStoreShape","shapeReady","spreadArgs","storeCombination","clone","stateNew","rawShape","isFresh","isCombine","childRef","field","defaultShape","createDefer","req","Promise","rs","rj","catch","createEffect","instance","onCopy","use","anyway","finally","done","status","doneData","failData","effectRunner","getHandler","getCurrent","onResolve","onSettled","ok","onReject","then","fx","runner","savedFork","inFlight","x","pending","amount","sidechain","events","forward","sampleConfigFields","validateSampleConfig","atLeastOneFieldExists","sample","clock","metadata","processArgsToConfig","greedy","needToCombine","isUpward","initialState","targetTemplate","sourceRef","hasSource","sourceState","clockState","domain","values","isScope","cloneOf","normalizedValues","normalizeValues","storeWatches","storeWatchesRefs","val","sidMap","changedStores","forkOf","fillResult","fillValues","flatGraphUnits","flatGraph","collectWatches","refsMap","predefinedRefs","valuesSidList","Object","getOwnPropertyNames","owner","createRefGraph","toposort","execRef","cmd","items","refGraph","clones","ignore","onlyChanges","savedForkPage","localUnit","assertEach","handlers","needToFill","forked","cloneGraph","handlerKeys","keys","sourceList","sourceRefsMap","templateOwnedRefs","rawGraph","graph","visited","temp","topologicalSortHelper","reverse","processed","ignored","shift","neighbors","n","start","ctx","reject","Error","parentFork","forkInFlightCounter","defers","launchUnits","launchParams","traverse","forEachRelatedNode","refs","fxID","putStoreToChanged","resolve","newRef","copyField","origValue","findClone","siblings","wrapped","wrapStore","index","unitName","Symbol","observable","effect","message","idCount","nextStepID","bind2","arg","nextBarrierID","barrier","mov","check","compute","run","opts","ɔ","ownerUnit","link","rawConfig","injected","removeFromNode","currentNode","targetNode","clearNodeNormalized","deep","isDomainUnit","pop","clearMap","clear","clearNode","ownerSet","history","effects","domains","unsubscribe","forkedNode","createHook","trigger","acc","res","hook","createDomain","onCreateEvent","onCreateEffect","onCreateStore","onCreateDomain","launchCase","scopeTargets","targets","match","knownCases","cases","matchIsUnit","matchIsFunction","matchIsShape","__","caseNames","splitterSeq","String","lastValues","updaterSteps","needBarrier","storeOrFn","updater","caseName","mapParams","attached","runnerSteps","runnerFn","computedParams","readStateRef","setters","observableItem","disposer","complete","filterIsUnit","guard"],"mappings":"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","sourcesContent":["//eslint-disable-next-line\nexport * as is from './validate'\nimport {throwError} from './throw'\n\nexport const isObject = (value: any) =>\n  typeof value === 'object' && value !== null\nexport const isFunction = (value: any) => typeof value === 'function'\n\nexport const assertObject = (value: any) => {\n  if (!isObject(value) && !isFunction(value))\n    throwError('expect first argument be an object') // or function\n}\n\nfunction assertNodeSetItem(value: any, method: string, valueName: string, reason: string) {\n  if ((!isObject(value) && !isFunction(value)) || (!('family' in value) && !('graphite' in value))) {\n    throwError(`${method}: expect ${valueName} to be a unit (store, event or effect)${reason}`)\n  }\n}\nexport function assertNodeSet(value: any, method: string, valueName: string) {\n  if (Array.isArray(value)) {\n    for (let i = 0; i < value.length; i++) {\n      const item = value[i]\n      assertNodeSetItem(item, method, `${i} item of ${valueName}`, '')\n    }\n  } else {\n    assertNodeSetItem(value, method, valueName, ' or array of units')\n  }\n}\n","import {getValue, getGraph, getParent} from './getter'\nimport {own} from './own'\nimport {createNode} from './createNode'\n\ntype RegionStack = {\n  parent: RegionStack | null\n  value: any\n  template: any\n  sidRoot?: string\n}\n\nexport let regionStack: RegionStack | null = null\n\nexport const readTemplate = () => regionStack && regionStack.template\nexport const readSidRoot = (sid?: string | null) => {\n  if (sid && regionStack && regionStack.sidRoot)\n    sid = `${regionStack.sidRoot}ɔ${sid}`\n  return sid\n}\n\nexport function withRegion(unit: any, cb: () => void) {\n  const unitMeta = getGraph(unit).meta\n  regionStack = {\n    parent: regionStack,\n    value: unit,\n    template: unitMeta.template || readTemplate(),\n    sidRoot: unitMeta.sidRoot || (regionStack && regionStack.sidRoot),\n  }\n  try {\n    return cb()\n  } finally {\n    regionStack = getParent(regionStack)\n  }\n}\n\nexport const withFactory = ({\n  sid,\n  name,\n  loc,\n  method,\n  fn,\n}: {\n  sid: string\n  name?: string\n  loc?: any\n  method?: string\n  fn: () => any\n}) => {\n  const sidNode = createNode({\n    meta: {\n      sidRoot: readSidRoot(sid),\n      name,\n      loc,\n      method,\n    },\n  })\n  return withRegion(sidNode, fn)\n}\n","import {Node, NodeUnit, Cmd, StateRef} from './index.h'\nimport {getGraph, getOwners, getLinks, getValue} from './getter'\nimport {nextNodeID} from './id'\nimport {CROSSLINK, STORE} from './tag'\nimport {regionStack} from './region'\nimport {own} from './own'\n\nconst arrifyNodes = (\n  list: NodeUnit | Array<NodeUnit | NodeUnit[]> = [],\n): Node[] => {\n  const result = []\n  if (Array.isArray(list)) {\n    for (let i = 0; i < list.length; i++) {\n      if (Array.isArray(list[i])) result.push(...(list[i] as any))\n      else result.push(list[i])\n    }\n  } else {\n    result.push(list)\n  }\n  return result.map(getGraph)\n}\nexport const addToReg = (\n  {hasRef, type, data}: any,\n  reg: Record<string, StateRef>,\n) => {\n  let store\n  if (hasRef) {\n    store = data.store\n    reg[store.id] = store\n  }\n  if (type === 'mov' && data.to === STORE) {\n    store = data.target\n    reg[store.id] = store\n  }\n}\nexport function createNode({\n  node = [],\n  from,\n  source,\n  parent = from || source,\n  to,\n  target,\n  child = to || target,\n  scope = {},\n  meta = {},\n  family: familyRaw = {type: 'regular'},\n  regional,\n}: {\n  node?: Array<Cmd | false | void | null>\n  from?: NodeUnit | NodeUnit[]\n  source?: NodeUnit | NodeUnit[]\n  parent?: NodeUnit | NodeUnit[]\n  to?: NodeUnit | NodeUnit[]\n  target?: NodeUnit | NodeUnit[]\n  child?: NodeUnit | NodeUnit[]\n  scope?: {[name: string]: any}\n  meta?: {[name: string]: any}\n  family?: {\n    type?: 'regular' | 'crosslink' | 'domain'\n    links?: NodeUnit | NodeUnit[]\n    owners?: NodeUnit | Array<NodeUnit | NodeUnit[]>\n  }\n  regional?: boolean\n} = {}): Node {\n  const sources = arrifyNodes(parent)\n  const links = arrifyNodes(familyRaw.links)\n  const owners = arrifyNodes(familyRaw.owners)\n  const seq: Cmd[] = []\n  const reg: {[id: string]: StateRef} = {}\n  for (let i = 0; i < node.length; i++) {\n    const item = node[i]\n    if (!item) continue\n    seq.push(item)\n    addToReg(item, reg)\n  }\n  const result: Node = {\n    id: nextNodeID(),\n    seq,\n    next: arrifyNodes(child),\n    meta,\n    scope,\n    family: {\n      type: familyRaw.type || CROSSLINK,\n      links,\n      owners,\n    },\n    reg,\n  }\n  for (let i = 0; i < links.length; i++) {\n    getOwners(links[i]).push(result)\n  }\n  for (let i = 0; i < owners.length; i++) {\n    getLinks(owners[i]).push(result)\n  }\n  for (let i = 0; i < sources.length; i++) {\n    sources[i].next.push(result)\n  }\n  if (regional && regionStack) {\n    own(getValue(regionStack), [result])\n  }\n  return result\n}\n","export const STORE = 'store'\nexport const EVENT = 'event'\nexport const EFFECT = 'effect'\nexport const DOMAIN = 'domain'\nexport const SAMPLER = 'sampler'\nexport const CROSSLINK = 'crosslink'\nexport const MAP = 'map'\nexport const STACK = 'stack'\nexport const BARRIER = 'barrier'\nexport const VALUE = 'value'\nexport const FORK_COUNTER = 'forkInFlightCounter'\nexport const SAMPLE = 'sample'\nexport const FILTER = 'filter'\nexport const REG_A = 'a'\n","import {Node, NodeUnit} from './index.h'\nimport {readRef} from './stateRef'\nimport {getForkPage, getGraph, getParent, getValue} from './getter'\nimport {\n  STORE,\n  EFFECT,\n  SAMPLER,\n  STACK,\n  BARRIER,\n  VALUE,\n  FILTER,\n  REG_A,\n} from './tag'\n\n/** Names of priority groups */\ntype PriorityTag = 'child' | 'pure' | 'barrier' | 'sampler' | 'effect'\n\n/**\n * Position in the current branch,\n * including call stack, priority type\n * and index of next step in the executed Node\n */\ntype Layer = {\n  idx: number\n  stack: Stack\n  type: PriorityTag\n  id: number\n}\n\n/** Call stack */\ntype Stack = {\n  value: any\n  a: any\n  b: any\n  parent: Stack | null\n  node: Node\n  page: {[id: string]: any} | null\n  forkPage?: any\n}\n\n/** Queue as linked list or skew heap */\ntype QueueItem = {\n  /** node value */\n  v: Layer\n  /** left node. always null in queue but used in skew heap */\n  l: QueueItem | null\n  /** right node */\n  r: QueueItem | null\n}\ntype QueueBucket = {\n  first: QueueItem | null\n  last: QueueItem | null\n  size: number\n}\n\n/** Dedicated local metadata */\ntype Local = {\n  fail: boolean\n  scope: {[key: string]: any}\n}\n\nlet heap: QueueItem | null = null\n\nconst merge = (a: QueueItem | null, b: QueueItem | null): QueueItem | null => {\n  if (!a) return b\n  if (!b) return a\n\n  let ret\n  const isSameType = a.v.type === b.v.type\n  if (\n    /**\n     * if both nodes has the same PriorityType\n     * and first node is created after second one\n     */\n    (isSameType && a.v.id > b.v.id) ||\n    /** if first node is \"sampler\" and second node is \"barrier\" */\n    (!isSameType && a.v.type === SAMPLER)\n  ) {\n    ret = a\n    a = b\n    b = ret\n  }\n  ret = merge(a.r, b)\n  a.r = a.l\n  a.l = ret\n\n  return a\n}\n\n/** queue buckets for each PriorityType */\nconst queue: QueueBucket[] = []\nlet ix = 0\nwhile (ix < 5) {\n  /**\n   * although \"sampler\" and \"barrier\" are using heap instead of linked list,\n   * their buckets are still useful: they maintains size of heap queue\n   */\n  queue.push({first: null, last: null, size: 0})\n  ix += 1\n}\n\nconst deleteMin = () => {\n  for (let i = 0; i < 5; i++) {\n    const list = queue[i]\n    if (list.size > 0) {\n      /**\n       * second bucket is for \"barrier\" PriorityType (used in combine)\n       * and third bucket is for \"sampler\" PriorityType (used in sample and guard)\n       */\n      if (i === 2 || i === 3) {\n        list.size -= 1\n        const value = heap!.v\n        heap = merge(heap!.l, heap!.r)\n        return value\n      }\n      if (list.size === 1) {\n        list.last = null\n      }\n      const item = list.first\n      list.first = item!.r\n      list.size -= 1\n      return item!.v\n    }\n  }\n}\nconst pushFirstHeapItem = (\n  type: PriorityTag,\n  page: {[id: string]: any} | null,\n  node: Node,\n  parent: Stack | null,\n  value: any,\n  forkPage: any | void,\n) =>\n  pushHeap(\n    0,\n    {\n      a: null,\n      b: null,\n      node,\n      parent,\n      value,\n      page,\n      forkPage,\n    },\n    type,\n  )\nconst pushHeap = (idx: number, stack: Stack, type: PriorityTag, id = 0) => {\n  const priority = getPriority(type)\n  const bucket: QueueBucket = queue[priority]\n  const item: QueueItem = {\n    v: {\n      idx,\n      stack,\n      type,\n      id,\n    },\n    //@ts-ignore\n    l: 0,\n    //@ts-ignore\n    r: 0,\n  }\n  /**\n   * second bucket is for \"barrier\" PriorityType (used in combine)\n   * and third bucket is for \"sampler\" PriorityType (used in sample and guard)\n   */\n  if (priority === 2 || priority === 3) {\n    heap = merge(heap, item)\n  } else {\n    if (bucket.size === 0) {\n      bucket.first = item\n    } else {\n      bucket.last!.r = item\n    }\n    bucket.last = item\n  }\n  bucket.size += 1\n}\n\nconst getPriority = (t: PriorityTag) => {\n  switch (t) {\n    case 'child':\n      return 0\n    case 'pure':\n      return 1\n    case BARRIER:\n      return 2\n    case SAMPLER:\n      return 3\n    case EFFECT:\n      return 4\n    default:\n      return -1\n  }\n}\n\nconst barriers = new Set()\n\nlet isRoot = true\nexport let isWatch = false\nexport let currentPage: any = null\nexport let forkPage: any\nexport const setForkPage = (newForkPage: any) => {\n  forkPage = newForkPage\n}\nexport const setCurrentPage = (newPage: any) => {\n  currentPage = newPage\n}\n\nconst getPageForRef = (page: any, id: string) => {\n  if (page) {\n    while (page && !page.reg[id]) {\n      page = getParent(page)\n    }\n    if (page) return page\n  }\n  return null\n}\nconst getPageRef = (page: any, node: Node, id: string) => {\n  const pageForRef = getPageForRef(page, id)\n  return (pageForRef ? pageForRef : node).reg[id]\n}\n\nexport function launch(config: {\n  target: NodeUnit | NodeUnit[]\n  params?: any\n  defer?: boolean\n  page?: any\n  forkPage?: any\n  stack?: Stack\n}): void\nexport function launch(unit: NodeUnit, payload?: any, upsert?: boolean): void\nexport function launch(unit: any, payload?: any, upsert?: boolean) {\n  let pageForLaunch = currentPage\n  let stackForLaunch = null\n  let forkPageForLaunch = forkPage\n  if (unit.target) {\n    payload = unit.params\n    upsert = unit.defer\n    pageForLaunch = 'page' in unit ? unit.page : pageForLaunch\n    if (unit[STACK]) stackForLaunch = unit[STACK]\n    forkPageForLaunch = getForkPage(unit) || forkPageForLaunch\n    unit = unit.target\n  }\n  if (forkPageForLaunch && forkPage && forkPageForLaunch !== forkPage) {\n    forkPage = null\n  }\n  if (Array.isArray(unit)) {\n    for (let i = 0; i < unit.length; i++) {\n      pushFirstHeapItem(\n        'pure',\n        pageForLaunch,\n        getGraph(unit[i]),\n        stackForLaunch,\n        payload[i],\n        forkPageForLaunch,\n      )\n    }\n  } else {\n    pushFirstHeapItem(\n      'pure',\n      pageForLaunch,\n      getGraph(unit),\n      stackForLaunch,\n      payload,\n      forkPageForLaunch,\n    )\n  }\n  if (upsert && !isRoot) return\n  /** main execution code */\n  const lastStartedState = {isRoot, currentPage, forkPage, isWatch}\n  isRoot = false\n  let stop\n  let skip\n  let node\n  let value\n  let page\n  let reg\n  kernelLoop: while ((value = deleteMin())) {\n    const {idx, stack, type} = value\n    node = stack.node\n    currentPage = page = stack.page\n    forkPage = getForkPage(stack)\n    reg = (page ? page : node).reg\n    const local: Local = {\n      fail: false,\n      scope: node.scope,\n    }\n    stop = skip = false\n    for (let stepn = idx; stepn < node.seq.length && !stop; stepn++) {\n      const step = node.seq[stepn]\n      const data = step.data\n      switch (step.type) {\n        case BARRIER: {\n          let id = data.barrierID\n          if (page) {\n            id = `${page.fullID}_${id}`\n          }\n          const priority = data.priority\n          if (stepn !== idx || type !== priority) {\n            if (!barriers.has(id)) {\n              barriers.add(id)\n              pushHeap(stepn, stack, priority, id)\n            }\n            continue kernelLoop\n          }\n          barriers.delete(id)\n          break\n        }\n        case 'mov': {\n          let value\n          //prettier-ignore\n          switch (data.from) {\n            case STACK: value = getValue(stack); break\n            case REG_A: /** fall-through case */\n            case 'b':\n              value = stack[data.from]\n              break\n            case VALUE: value = data.store; break\n            case STORE:\n              if (!reg[data.store.id]) {\n                // if (!page.parent) {\n                stack.page = page = getPageForRef(page, data.store.id)\n                reg = page ? page.reg : node.reg\n                // }\n              }\n              // value = getPageRef(page, node, data.store.id).current\n              value = readRef(reg[data.store.id])\n              break\n          }\n          //prettier-ignore\n          switch (data.to) {\n            case STACK: stack.value = value; break\n            case REG_A: /** fall-through case */\n            case 'b':\n              stack[data.to] = value\n              break\n            case STORE:\n              getPageRef(page, node, data.target.id).current = value\n              break\n          }\n          break\n        }\n        case 'check':\n          switch (data.type) {\n            case 'defined':\n              skip = getValue(stack) === undefined\n              break\n            case 'changed':\n              skip =\n                getValue(stack) ===\n                readRef(getPageRef(page, node, data.store.id))\n              break\n          }\n          break\n        case FILTER:\n          /**\n           * handled edge case: if step.fn will throw,\n           * tryRun will return null\n           * thereby forcing that branch to stop\n           */\n          skip = !tryRun(local, data, stack)\n          break\n        case 'run':\n          /** exec 'compute' step when stepn === idx */\n          if (stepn !== idx || type !== EFFECT) {\n            pushHeap(stepn, stack, EFFECT)\n            continue kernelLoop\n          }\n        case 'compute':\n          isWatch = node.meta.op === 'watch'\n          stack.value = tryRun(local, data, stack)\n          isWatch = lastStartedState.isWatch\n          break\n      }\n      stop = local.fail || skip\n    }\n    if (!stop) {\n      for (let stepn = 0; stepn < node.next.length; stepn++) {\n        pushFirstHeapItem(\n          'child',\n          page,\n          node.next[stepn],\n          stack,\n          getValue(stack),\n          getForkPage(stack),\n        )\n      }\n    }\n  }\n  isRoot = lastStartedState.isRoot\n  currentPage = lastStartedState.currentPage\n  forkPage = getForkPage(lastStartedState)\n}\n\n/** try catch for external functions */\nconst tryRun = (local: Local, {fn}: any, stack: Stack) => {\n  try {\n    return fn(getValue(stack), local.scope, stack)\n  } catch (err) {\n    console.error(err)\n    local.fail = true\n  }\n}\n","import {Store, Domain} from './unit.h'\nimport {is} from './is'\nimport {getParent} from './getter'\n\nexport const joinName = (unit: any, tag: string) => '' + unit.shortName + tag\n\nexport const mapName = (unit: any, name?: string) =>\n  name == null ? joinName(unit, ' → *') : name\n\nexport function unitObjectName(objOrArr: any, method: string = 'combine') {\n  let name = method + '('\n  let comma = ''\n  let i = 0\n  //@ts-ignore\n  for (const key in objOrArr) {\n    //@ts-ignore\n    const unit = objOrArr[key]\n    if (unit != null) {\n      name += comma\n      //@ts-ignore\n      name += is.unit(unit) ? unit.compositeName.fullName : unit.toString()\n    }\n    i += 1\n    /* inlined max object names constant */\n    if (i === 25) break\n    comma = ', '\n  }\n  name += ')'\n  return name\n}\n\nexport function setStoreName<State>(store: Store<State>, rawName: string) {\n  const compositeName = createName(rawName, getParent(store))\n  store.shortName = rawName\n  if (!store.compositeName) {\n    store.compositeName = compositeName\n    return\n  }\n  const currentComposite = store.compositeName\n  currentComposite.path = compositeName.path\n  currentComposite.shortName = compositeName.shortName\n  currentComposite.fullName = compositeName.fullName\n}\n\nexport type CompositeName = {\n  shortName: string\n  fullName: string\n  path: string[]\n}\n\nexport function createName(name: string, parent?: Domain): CompositeName {\n  let path: string[]\n  let fullName\n  let composite\n  const shortName = name\n  if (!parent) {\n    if (name.length === 0) {\n      path = []\n    } else {\n      path = [name]\n    }\n    fullName = name\n  } else {\n    composite = parent.compositeName\n    if (name.length === 0) {\n      path = composite.path\n      fullName = composite.fullName\n    } else {\n      path = composite.path.concat([name])\n      if (composite.fullName.length === 0) {\n        fullName = name\n      } else {\n        fullName = '' + composite.fullName + '/' + name\n      }\n    }\n  }\n  return {shortName, fullName, path}\n}\n","export function forIn<T>(\n  obj: Record<string, T>,\n  cb: (value: T, key: string) => void,\n) {\n  for (const key in obj) {\n    cb(obj[key], key)\n  }\n}\n\nexport const includes = (list: any[], item: any) => list.includes(item)\n\nexport const removeItem = (list: any[], item: any) => {\n  const pos = list.indexOf(item)\n  if (pos !== -1) {\n    list.splice(pos, 1)\n  }\n}\n\nexport function forEach<T>(\n  list: T[],\n  fn: (item: T, index: number, list: T[]) => void,\n): void\nexport function forEach<T>(list: Set<T>, fn: (item: T) => void): void\nexport function forEach(list: any, fn: Function) {\n  list.forEach(fn)\n}\n","import {observableSymbol} from './observable'\n\nimport {is, isObject, isFunction, assertObject, assertNodeSet} from './is'\nimport {Store, Event} from './unit.h'\n\nimport {step} from './typedef'\nimport {createStateRef, readRef} from './stateRef'\nimport {nextUnitID} from './id'\nimport {callStackAReg, callARegStack, callStack} from './caller'\nimport {bind} from './bind'\nimport {own} from './own'\nimport {createNode} from './createNode'\nimport {launch, currentPage, forkPage, setCurrentPage} from './kernel'\n\nimport {Subscriber, Config} from './index.h'\nimport {createName, mapName, joinName} from './naming'\nimport {createLinkNode} from './forward'\nimport {watchUnit} from './watch'\nimport {createSubscription} from './subscription'\nimport {readTemplate, readSidRoot} from './region'\nimport {\n  getSubscribers,\n  getConfig,\n  getNestedConfig,\n  getStoreState,\n  getGraph,\n  getParent,\n} from './getter'\nimport {includes} from './collection'\nimport {throwError} from './throw'\nimport {DOMAIN, STORE, EVENT, MAP, FILTER, REG_A} from './tag'\n\nconst normalizeConfig = (part: any, config: any) => {\n  if (isObject(part)) {\n    normalizeConfig(getConfig(part), config)\n    if (part.name != null) {\n      if (isObject(part.name)) normalizeConfig(part.name, config)\n      else if (isFunction(part.name)) config.handler = part.name\n      else config.name = part.name\n    }\n    if (part.loc) config.loc = part.loc\n    if (part.sid || part.sid === null) config.sid = part.sid\n    if (part.handler) config.handler = part.handler\n    if (part.updateFilter) config.updateFilter = part.updateFilter\n    if (getParent(part)) config.parent = getParent(part)\n    if ('strict' in part) config.strict = part.strict\n    if (part.named) config.named = part.named\n    normalizeConfig(getNestedConfig(part), config)\n  }\n  return config\n}\n\nexport const applyParentHook = (\n  source: any,\n  target: any,\n  hookType: 'event' | 'effect' = EVENT,\n) => {\n  if (getParent(source)) getParent(source).hooks[hookType](target)\n}\n\nlet isStrict: boolean\nexport const initUnit = (\n  kind: any,\n  unit: any,\n  rawConfigA: any,\n  rawConfigB?: any,\n) => {\n  const config = normalizeConfig(\n    {\n      name: rawConfigB,\n      config: rawConfigA,\n    },\n    {},\n  )\n  const isDomain = kind === DOMAIN\n  const id = nextUnitID()\n  let {parent = null, sid = null, strict = true, named = null} = config\n  const name = named ? named : config.name || (isDomain ? '' : id)\n  const compositeName = createName(name, parent)\n\n  const meta: Record<string, any> = {\n    unit: unit.kind = kind,\n    name: unit.shortName = name,\n    sid: unit.sid = readSidRoot(sid),\n    named,\n    unitId: unit.id = id,\n  }\n  unit.parent = parent\n  unit.compositeName = compositeName\n  unit.defaultConfig = config\n  unit.thru = (fn: Function) => fn(unit)\n  unit.getType = () => compositeName.fullName\n  if (!isDomain) {\n    unit.subscribe = (observer: Subscriber<any>) => {\n      assertObject(observer)\n      return unit.watch(\n        isFunction(observer)\n          ? observer\n          : (upd: any) => {\n              if (observer.next) {\n                observer.next(upd)\n              }\n            },\n      )\n    }\n    unit[observableSymbol] = () => unit\n    const template = readTemplate()\n    if (template) meta.nativeTemplate = template\n  }\n  isStrict = strict\n  return meta\n}\nexport const createNamedEvent = (named: string) => createEvent({named})\n\nconst createComputation = (from: any, to: any, op: any, fn: Function) =>\n  createLinkNode(from, to, {\n    scope: {fn},\n    node: [step.compute({fn: callStack})],\n    meta: {op},\n  })\n\nconst createEventFiltration = (event: any, op: string, fn: any, node: any) => {\n  let config\n  if (isObject(fn)) {\n    config = fn\n    fn = fn.fn\n  }\n  const mapped = createEvent(joinName(event, ' →? *'), config)\n  createLinkNode(event, mapped, {\n    scope: {fn},\n    node,\n    meta: {op},\n  })\n  return mapped\n}\n\nfunction callCreate(unit: any, template: any, payload: any, args: any[]): any {\n  const oldPage = currentPage\n  let page = null\n  if (template) {\n    page = currentPage\n    while (page && page.template !== template) {\n      page = getParent(page)\n    }\n  }\n  setCurrentPage(page)\n  const result = unit.create(payload, args)\n  setCurrentPage(oldPage)\n  return result\n}\n\nexport function createEvent<Payload = any>(\n  nameOrConfig?: any,\n  maybeConfig?: any,\n): Event<Payload> {\n  const event: any = (payload: Payload, ...args: any[]) => {\n    if (currentPage) {\n      return callCreate(event, template, payload, args)\n    }\n    return event.create(payload, args)\n  }\n  event.graphite = createNode({\n    meta: initUnit(EVENT, event, maybeConfig, nameOrConfig),\n    regional: true,\n  })\n  //eslint-disable-next-line no-unused-vars\n  event.create = (params: any, _: any) => {\n    const target = forkPage ? forkPage.find(event) : event\n    launch(target, params)\n    return params\n  }\n  event.watch = bind(watchUnit, event)\n  event.map = (fn: any) => {\n    let config\n    let name\n    if (isObject(fn)) {\n      config = fn\n      name = fn.name\n      fn = fn.fn\n    }\n    const mapped = createEvent(mapName(event, name), config)\n    createComputation(event, mapped, MAP, fn)\n    return mapped\n  }\n  event.filter = (fn: any) =>\n    createEventFiltration(event, FILTER, fn.fn ? fn : fn.fn, [\n      step.filter({fn: callStack}),\n    ])\n  event.filterMap = (fn: any) =>\n    createEventFiltration(event, 'filterMap', fn, [\n      step.compute({fn: callStack}),\n      step.check.defined(),\n    ])\n  event.prepend = (fn: any) => {\n    const contramapped: Event<any> = createEvent('* → ' + event.shortName, {\n      parent: getParent(event),\n    })\n    const template = readTemplate()\n    if (template) {\n      getGraph(contramapped).seq.push(template.upward)\n    }\n    createComputation(contramapped, event, 'prepend', fn)\n    applyParentHook(event, contramapped)\n    return contramapped\n  }\n  const template = readTemplate()\n  return event\n}\n\nexport function createStore<State>(\n  defaultState: State,\n  props?: Config,\n): Store<State> {\n  const plainState = createStateRef(defaultState)\n  const oldState = createStateRef(defaultState)\n  const updates = createNamedEvent('updates')\n  const template = readTemplate()\n  plainState.after = [{type: 'copy', to: oldState}]\n  if (template) {\n    template.plain.push(plainState, oldState)\n  }\n  const plainStateId = plainState.id\n  const store: any = {\n    subscribers: new Map(),\n    updates,\n    defaultState,\n    stateRef: plainState,\n    getState() {\n      let targetRef = plainState\n      let reachedPage\n      if (currentPage) {\n        let page = currentPage\n        while (page && !page.reg[plainStateId]) {\n          page = getParent(page)\n        }\n        if (page) reachedPage = page\n      }\n      if (!reachedPage && forkPage && forkPage.reg[plainStateId]) {\n        reachedPage = forkPage\n      }\n      if (reachedPage) targetRef = reachedPage.reg[plainStateId]\n      return readRef(targetRef)\n    },\n    setState(state: any) {\n      let target\n      if (forkPage) {\n        target = forkPage.nodeMap[getGraph(store).id]\n      }\n      if (!target) target = store\n      launch({\n        target,\n        params: state,\n        defer: true,\n      })\n    },\n    reset(...units: any[]) {\n      for (const unit of units) store.on(unit, () => store.defaultState)\n      return store\n    },\n    on(nodeSet: any, fn: Function) {\n      assertNodeSet(nodeSet, '.on', 'first argument')\n      if (Array.isArray(nodeSet)) {\n        for (const event of nodeSet) {\n          onEvent(event, fn)\n        }\n      } else {\n        onEvent(nodeSet, fn)\n      }\n      return store\n    },\n    off(unit: any) {\n      const currentSubscription = getSubscribers(store).get(unit)\n      if (currentSubscription) {\n        currentSubscription()\n        getSubscribers(store).delete(unit)\n      }\n      return store\n    },\n    map(fn: any, firstState?: any) {\n      let config\n      let name\n      if (isObject(fn)) {\n        config = fn\n        name = fn.name\n        firstState = fn.firstState\n        fn = fn.fn\n      }\n      let lastResult\n      const storeState = store.getState()\n      const template = readTemplate()\n      if (template) {\n        lastResult = null\n      } else if (storeState !== undefined) {\n        lastResult = fn(storeState, firstState)\n      }\n\n      const innerStore: Store<any> = createStore(lastResult, {\n        name: mapName(store, name),\n        config,\n        strict: false,\n      })\n      const linkNode = updateStore(store, innerStore, MAP, false, fn)\n\n      getStoreState(innerStore).before = [\n        {\n          type: MAP,\n          fn,\n          from: plainState,\n        },\n      ]\n      if (template) {\n        if (!includes(template.plain, plainState)) {\n          if (!includes(linkNode.seq, template.loader)) {\n            linkNode.seq.unshift(template.loader)\n          }\n        }\n      }\n      return innerStore\n    },\n    watch(eventOrFn: any, fn?: Function) {\n      if (!fn || !is.unit(eventOrFn)) {\n        const subscription = watchUnit(store, eventOrFn)\n        const template = readTemplate()\n        if (template) {\n          template.watch.push({\n            of: plainState,\n            fn: eventOrFn,\n          })\n        } else {\n          eventOrFn(store.getState())\n        }\n        return subscription\n      }\n      if (!isFunction(fn)) throwError('second argument should be a function')\n      return eventOrFn.watch((payload: any) => fn(store.getState(), payload))\n    },\n  }\n  function onEvent(event: any, fn: Function) {\n    store.off(event)\n    getSubscribers(store).set(\n      event,\n      createSubscription(\n        updateStore(event, store, 'on', true, fn, updateFilter),\n      ),\n    )\n  }\n  const meta = initUnit(STORE, store, props)\n  const updateFilter = store.defaultConfig.updateFilter\n  store.graphite = createNode({\n    scope: {state: plainState},\n    node: [\n      step.check.defined(),\n      step.check.changed({\n        store: oldState,\n      }),\n      updateFilter && step.mov({store: oldState, to: REG_A}),\n      updateFilter &&\n        step.filter({\n          fn: (update, _, {a}) => updateFilter(update, a),\n        }),\n      step.update({\n        store: plainState,\n      }),\n      step.update({\n        store: oldState,\n      }),\n    ],\n    child: updates,\n    meta,\n    regional: true,\n  })\n  if (isStrict && defaultState === undefined)\n    throwError(\"current state can't be undefined, use null instead\")\n  own(store, [updates])\n  return store\n}\n\nconst updateStore = (\n  from: any,\n  store: Store<any>,\n  op: string,\n  stateFirst: boolean,\n  fn: Function,\n  updateFilter?: Function,\n) => {\n  const storeRef = getStoreState(store)\n  const node = [\n    step.mov({store: storeRef, to: REG_A}),\n    step.compute({\n      fn: stateFirst ? callARegStack : callStackAReg,\n    }),\n    step.check.defined(),\n    step.check.changed({store: storeRef}),\n    updateFilter &&\n      step.filter({\n        fn: (update, _, {a}) => updateFilter(update, a),\n      }),\n    step.update({store: storeRef}),\n  ]\n  const template = readTemplate()\n  if (template) {\n    node.unshift(template.loader)\n    node.push(template.upward)\n    if (is.store(from)) {\n      const ref = getStoreState(from)\n      if (!includes(template.plain, ref)) {\n        //if (!includes(node, template.loader)) {\n        //  node.unshift(template.loader)\n        //}\n        if (!includes(template.closure, ref)) {\n          template.closure.push(ref)\n        }\n        if (!storeRef.before) storeRef.before = []\n        storeRef.before.push({\n          type: 'closure',\n          of: ref,\n        })\n      }\n    } else {\n      //if (!includes(node, template.loader)) {\n      //  node.unshift(template.loader)\n      //}\n    }\n  }\n  return createLinkNode(from, store, {\n    scope: {fn},\n    node,\n    meta: {op},\n  })\n}\n","import {Store} from './unit.h'\nimport {createStore} from './createUnit'\nimport {createStateRef} from './stateRef'\nimport {step} from './typedef'\nimport {onConfigNesting} from './config'\nimport {getGraph, getStoreState} from './getter'\nimport {is, isFunction, isObject} from './is'\nimport {unitObjectName} from './naming'\nimport {createLinkNode} from './forward'\nimport {throwError} from './throw'\nimport {readTemplate} from './region'\nimport {forIn, includes} from './collection'\nimport {BARRIER, MAP, REG_A, VALUE} from './tag'\n\nexport function combine(...args: any[]): Store<any> {\n  let handler\n  let stores\n  let config\n  onConfigNesting(args[0], (injectedData, userConfig) => {\n    config = injectedData\n    args = userConfig\n  })\n  const rawHandler = args[args.length - 1]\n  if (isFunction(rawHandler)) {\n    stores = args.slice(0, -1)\n    handler = rawHandler\n  } else {\n    stores = args\n  }\n\n  let structStoreShape\n  let shapeReady\n  if (stores.length === 1) {\n    const obj = stores[0]\n    /*\n      without edge case combine(Color, (Color) => '~')\n      */\n    if (!is.store(obj)) {\n      /*\n      case combine([R,G,B], ([R,G,B]) => '~')\n      case combine({R,G,B}, ({R,G,B}) => '~')\n\n      edge case combine([Color], ([Color]) => '~')\n      edge case combine({Color}, ({Color}) => '~')\n\n      edge case combine([R,G,B])\n      edge case combine({R,G,B})\n\n      edge case combine([Color])\n      edge case combine({Color})\n      */\n      structStoreShape = obj\n      shapeReady = true\n    }\n  }\n  if (!shapeReady) {\n    /*\n    case combine(R,G,B, (R,G,B) => '~')\n    */\n    structStoreShape = stores\n    /*\n    without edge case combine(R,G,B)\n    without edge case combine(Color)\n    */\n    if (handler) {\n      handler = spreadArgs(handler)\n    }\n  }\n  if (!isObject(structStoreShape)) throwError('shape should be an object')\n  return storeCombination(\n    Array.isArray(structStoreShape),\n    structStoreShape,\n    config,\n    handler,\n  )\n}\n\nconst spreadArgs = (fn: Function) => (list: any[]) => fn(...list)\n\nconst storeCombination = (\n  isArray: boolean,\n  obj: any,\n  config?: string,\n  fn?: (upd: any) => any,\n) => {\n  const clone = isArray ? (list: any) => list.slice() : (obj: any) => ({...obj})\n  const defaultState: any = isArray ? [] : {}\n  const template = readTemplate()\n  const stateNew = clone(defaultState)\n  const rawShape = createStateRef(stateNew)\n  const isFresh = createStateRef(true)\n  rawShape.type = isArray ? 'list' : 'shape'\n  if (template) {\n    template.plain.push(rawShape, isFresh)\n  }\n  const store = createStore(stateNew, {\n    name: config ? config : unitObjectName(obj),\n  })\n  getGraph(store).meta.isCombine = true\n  const node = [\n    step.check.defined(),\n    step.mov({\n      store: rawShape,\n      to: REG_A,\n    }),\n    //prettier-ignore\n    step.filter({\n      fn: (upd, {key}, {a}) => upd !== a[key],\n    }),\n    step.mov({\n      store: isFresh,\n      to: 'b',\n    }),\n    step.compute({\n      fn(upd, {clone, key}, reg) {\n        if (reg.b) {\n          reg.a = clone(reg.a)\n        }\n        reg.a[key] = upd\n      },\n    }),\n    step.mov({\n      from: REG_A,\n      target: rawShape,\n    }),\n    step.mov({\n      from: VALUE,\n      store: false,\n      target: isFresh,\n    }),\n    step.barrier({priority: BARRIER}),\n    step.mov({\n      from: VALUE,\n      store: true,\n      target: isFresh,\n    }),\n    step.mov({store: rawShape}),\n    fn && step.compute({fn}),\n    step.check.changed({\n      store: getStoreState(store),\n    }),\n  ]\n  const before: any[] = (rawShape.before = [])\n  forIn(obj, (child: Store<any> | any, key) => {\n    if (!is.store(child)) {\n      stateNew[key] = defaultState[key] = child\n      return\n    }\n    defaultState[key] = child.defaultState\n    stateNew[key] = child.getState()\n    const linkNode = createLinkNode(child, store, {\n      scope: {key, clone},\n      node,\n      meta: {op: 'combine'},\n    })\n    const childRef = getStoreState(child)\n    before.push({\n      type: 'field',\n      field: key,\n      from: childRef,\n    })\n    if (template) {\n      if (!includes(template.plain, childRef)) {\n        linkNode.seq.unshift(template.loader)\n      }\n    }\n  })\n\n  store.defaultShape = obj\n  rawShape.after = [\n    fn\n      ? {\n          type: MAP,\n          to: getStoreState(store),\n          fn,\n        }\n      : {\n          type: 'copy',\n          to: getStoreState(store),\n        },\n  ]\n  if (!template) {\n    store.defaultState = fn\n      ? (getStoreState(store).current = fn(stateNew))\n      : defaultState\n  }\n  return store\n}\n","export function createDefer(): {\n  rs: (value: any) => any\n  rj: (value: any) => any\n  req: Promise<any>\n} {\n  const result = {} as {\n    rs: (value: any) => any\n    rj: (value: any) => any\n    req: Promise<any>\n  }\n  result.req = new Promise((rs, rj) => {\n    result.rs = rs\n    result.rj = rj\n  })\n  result.req.catch(err => {})\n  return result\n}\n","import {step} from './typedef'\nimport {getForkPage, getGraph, getParent} from './getter'\nimport {own} from './own'\nimport {createNode} from './createNode'\nimport {launch, setForkPage, forkPage, isWatch} from './kernel'\nimport {createNamedEvent, createStore, createEvent} from './createUnit'\nimport {createDefer} from './defer'\nimport {isObject, isFunction} from './is'\nimport {throwError} from './throw'\nimport {EFFECT} from './tag'\n\nexport function createEffect<Payload, Done>(\n  nameOrConfig: any,\n  maybeConfig: any,\n) {\n  const instance: any = createEvent(nameOrConfig, maybeConfig)\n  let handler =\n    instance.defaultConfig.handler ||\n    (() => throwError(`no handler used in ${instance.getType()}`))\n  const node = getGraph(instance)\n  node.meta.onCopy = ['runner']\n  node.meta.unit = instance.kind = EFFECT\n  instance.use = (fn: Function) => {\n    if (!isFunction(fn)) throwError('.use argument should be a function')\n    handler = fn\n    return instance\n  }\n  const anyway = (instance.finally = createNamedEvent('finally'))\n  const done = (instance.done = (anyway as any).filterMap({\n    named: 'done',\n    fn({status, params, result}: any) {\n      if (status === 'done') return {params, result}\n    },\n  }))\n  const fail = (instance.fail = (anyway as any).filterMap({\n    named: 'fail',\n    fn({status, params, error}: any) {\n      if (status === 'fail') return {params, error}\n    },\n  }))\n  const doneData = (instance.doneData = done.map({\n    named: 'doneData',\n    fn: ({result}: any) => result,\n  }))\n  const failData = (instance.failData = fail.map({\n    named: 'failData',\n    fn: ({error}: any) => error,\n  }))\n\n  const effectRunner = createNode({\n    scope: {\n      getHandler: instance.use.getCurrent = () => handler,\n      finally: anyway,\n    },\n    node: [\n      step.run({\n        fn({params, req}, {finally: anyway, getHandler}, stack) {\n          const onResolve = onSettled({\n            params,\n            req,\n            ok: true,\n            anyway,\n            stack,\n          })\n          const onReject = onSettled({\n            params,\n            req,\n            ok: false,\n            anyway,\n            stack,\n          })\n          let result\n          try {\n            result = getHandler()(params)\n          } catch (err) {\n            return void onReject(err)\n          }\n          if (isObject(result) && isFunction(result.then)) {\n            result.then(onResolve, onReject)\n          } else {\n            onResolve(result)\n          }\n        },\n      }),\n    ],\n    meta: {\n      op: 'fx',\n      fx: 'runner',\n      onCopy: ['finally'],\n    },\n  })\n  node.scope.runner = effectRunner\n  node.seq.push(\n    step.compute({\n      fn(params, scope, stack) {\n        // empty stack means that this node was launched directly\n        if (!getParent(stack)) return params\n        return {\n          params,\n          req: {\n            rs(data: any) {},\n            rj(data: any) {},\n          },\n        }\n      },\n    }),\n    step.run({\n      fn(upd, {runner}, stack) {\n        launch({\n          target: runner,\n          params: upd,\n          defer: true,\n          forkPage: getForkPage(stack),\n        })\n        return upd.params\n      },\n    }),\n  )\n  instance.create = (params: Payload) => {\n    const req = createDefer()\n    const payload = {params, req}\n    if (forkPage) {\n      if (!isWatch) {\n        const savedFork = forkPage\n        req.req\n          .finally(() => {\n            setForkPage(savedFork)\n          })\n          .catch(() => {})\n      }\n      launch(forkPage.find(instance), payload)\n    } else {\n      launch(instance, payload)\n    }\n    return req.req\n  }\n\n  const inFlight = (instance.inFlight = createStore(0, {named: 'inFlight'})\n    .on(instance, x => x + 1)\n    .on(anyway, x => x - 1))\n\n  const pending = (instance.pending = inFlight.map({\n    //@ts-ignore\n    fn: amount => amount > 0,\n    named: 'pending',\n  }))\n\n  own(instance, [\n    anyway,\n    done,\n    fail,\n    doneData,\n    failData,\n    pending,\n    inFlight,\n    effectRunner,\n  ])\n  return instance\n}\n\nexport const onSettled = ({\n  params,\n  req,\n  ok,\n  anyway,\n  stack,\n}: {\n  params: any\n  req: {\n    rs(_: any): any\n    rj(_: any): any\n  }\n  ok: boolean\n  anyway: any\n  stack: any\n}) => (data: any) =>\n  launch({\n    target: [anyway, sidechain],\n    params: [\n      ok\n        ? {\n            status: 'done',\n            params,\n            result: data,\n          }\n        : {\n            status: 'fail',\n            params,\n            error: data,\n          },\n      {\n        fn: ok ? req.rs : req.rj,\n        value: data,\n      },\n    ],\n    defer: true,\n    page: stack.page,\n    forkPage: getForkPage(stack),\n  })\n\nexport const sidechain = createNode({\n  node: [\n    step.run({\n      fn({fn, value}) {\n        fn(value)\n      },\n    }),\n  ],\n  meta: {op: 'fx', fx: 'sidechain'},\n})\n","import {Store, Event, Effect} from './unit.h'\nimport {createEvent} from './createUnit'\nimport {forward} from './forward'\nimport {unitObjectName} from './naming'\nimport {assertNodeSet} from './is'\n\nexport function merge<T>(\n  events: Array<Event<T> | Store<T> | Effect<T, any, any>>,\n  config?: object,\n): Event<T> {\n  const result = createEvent(config || unitObjectName(events, 'merge'))\n  assertNodeSet(events, 'merge', 'first argument')\n  forward({\n    from: events,\n    to: result,\n    meta: {op: 'merge'},\n  })\n  return result\n}\n","import {combine} from './combine'\nimport {step} from './typedef'\nimport {createStateRef, readRef} from './stateRef'\nimport {callStackAReg, callARegStack} from './caller'\nimport {processArgsToConfig} from './config'\nimport {getStoreState, getGraph} from './getter'\nimport {own} from './own'\nimport {assertNodeSet, is, isObject} from './is'\nimport {createStore} from './createUnit'\nimport {createEvent} from './createUnit'\nimport {createLinkNode} from './forward'\nimport {createNode} from './createNode'\nimport {readTemplate} from './region'\nimport {throwError} from './throw'\nimport {includes, forEach} from './collection'\nimport {REG_A, SAMPLE, SAMPLER, STACK, STORE, VALUE} from './tag'\nimport {merge} from './merge'\n\nconst sampleConfigFields = ['source', 'clock', 'target']\n\nfunction validateSampleConfig(config: any) {\n  let atLeastOneFieldExists = false\n  forEach(sampleConfigFields, field => {\n    if (field in config) {\n      if (config[field] == null) {\n        throwError(`sample: ${field} should be defined`)\n      }\n      atLeastOneFieldExists = true\n    }\n  })\n  return atLeastOneFieldExists\n}\n\nexport function sample(...args: any): any {\n  let target\n  let name\n  let [[source, clock, fn], metadata] = processArgsToConfig(args)\n  let sid\n  let greedy\n  //config case\n  if (clock === undefined && isObject(source) && validateSampleConfig(source)) {\n    clock = source.clock\n    fn = source.fn\n    greedy = source.greedy\n    //optional target & name accepted only from config\n    target = source.target\n    name = source.name\n    sid = source.sid\n    source = source.source\n  }\n  let needToCombine = true\n  if (source === undefined) {\n    assertNodeSet(clock, 'sample', 'clock')\n    if (Array.isArray(clock)) {\n      clock = merge(clock)\n    }\n    source = clock\n    needToCombine = false\n  }\n  if (needToCombine && !is.unit(source)) {\n    source = combine(source)\n  }\n  if (clock === undefined) {\n    //still undefined!\n    clock = source\n  }\n  assertNodeSet(clock, 'sample', 'clock')\n  name = metadata || name || source.shortName\n  const template = readTemplate()\n  const isUpward = !!target\n  if (!target) {\n    if (is.store(source) && is.store(clock)) {\n      const initialState = fn\n        ? fn(readRef(getStoreState(source)), readRef(getStoreState(clock)))\n        : readRef(getStoreState(source))\n      target = createStore(initialState, {name, sid})\n    } else {\n      target = createEvent(name)\n      if (template) {\n        getGraph(target).seq.push(template.loader)\n      }\n    }\n  }\n  const targetTemplate =\n    isUpward && is.unit(target) && getGraph(target).meta.nativeTemplate\n  if (is.store(source)) {\n    const sourceRef = getStoreState(source)\n    own(source, [\n      createLinkNode(clock, target, {\n        scope: {fn, targetTemplate},\n        node: [\n          template && template.loader,\n          //@ts-ignore\n          !greedy && step.barrier({priority: SAMPLER}),\n          step.mov({\n            store: sourceRef,\n            to: fn ? REG_A : STACK,\n          }),\n          fn && step.compute({fn: callARegStack}),\n          template && isUpward && template.upward,\n        ],\n        meta: {op: SAMPLE, sample: STORE},\n      }),\n    ])\n    if (template) {\n      if (\n        !includes(template.plain, sourceRef) &&\n        !includes(template.closure, sourceRef)\n      ) {\n        template.closure.push(sourceRef)\n      }\n    }\n  } else {\n    const hasSource = createStateRef(false)\n    const sourceState = createStateRef()\n    const clockState = createStateRef()\n    if (template) {\n      template.plain.push(hasSource, sourceState, clockState)\n    }\n    createNode({\n      parent: source,\n      node: [\n        step.update({store: sourceState}),\n        step.mov({\n          from: VALUE,\n          store: true,\n          target: hasSource,\n        }),\n      ],\n      family: {\n        owners: [source, target, clock],\n        links: target,\n      },\n      meta: {op: SAMPLE, sample: 'source'},\n      regional: true,\n    })\n    own(source, [\n      createLinkNode(clock, target, {\n        scope: {\n          fn,\n          targetTemplate,\n        },\n        node: [\n          template && template.loader,\n          step.update({store: clockState}),\n          step.mov({store: hasSource}),\n          step.filter({fn: hasSource => hasSource}),\n          //@ts-ignore\n          !greedy && step.barrier({priority: SAMPLER}),\n          step.mov({store: sourceState}),\n          step.mov({\n            store: clockState,\n            to: REG_A,\n          }),\n          fn && step.compute({fn: callStackAReg}),\n          template && isUpward && template.upward,\n        ],\n        meta: {op: SAMPLE, sample: 'clock'},\n      }),\n    ])\n  }\n  return target\n}\n","import {getForkPage, getGraph, getLinks, getOwners, getParent} from './getter'\nimport {bind} from './bind'\nimport {createDefer} from './defer'\nimport {watchUnit} from './watch'\nimport {is, isObject} from './is'\nimport {throwError} from './throw'\nimport {launch, forkPage, setForkPage, currentPage} from './kernel'\nimport {createNode} from './createNode'\nimport {step} from './typedef'\nimport {Domain, Store} from './unit.h'\nimport {Node, StateRef} from './index.h'\nimport {removeItem, forEach, includes, forIn} from './collection'\nimport {DOMAIN, STORE, EVENT, EFFECT, SAMPLER, MAP, FORK_COUNTER} from './tag'\n\n/**\n hydrate state on client\n\n const root = createDomain()\n hydrate(root, {\n  values: window.__initialState__\n})\n\n */\nexport function hydrate(domain: Domain, {values}: {values: any}) {\n  const isScope = isObject(domain) && (domain as any).cloneOf\n  if (!is.domain(domain) && !isScope) {\n    throwError('first argument of hydrate should be domain or scope')\n  }\n  if (!isObject(values)) {\n    throwError('values property should be an object')\n  }\n  const normalizedValues = normalizeValues(values)\n  let storeWatches: Node[]\n  let storeWatchesRefs: any[]\n  if (isScope) {\n    storeWatches = []\n    storeWatchesRefs = []\n    forIn(normalizedValues, (val, sid) => {\n      //@ts-ignore\n      const node = domain.sidMap[sid]\n      if (node) {\n        storeWatches.push(node)\n        storeWatchesRefs.push(val)\n        ;(domain as any).changedStores.add(node.meta.forkOf.id)\n      }\n    })\n  } else {\n    const fillResult = fillValues({\n      flatGraphUnits: flatGraph(domain),\n      values: normalizedValues,\n      collectWatches: true,\n    })\n    storeWatches = fillResult.storeWatches\n    storeWatchesRefs = fillResult.storeWatchesRefs.map(({current}) => current)\n  }\n\n  launch({\n    target: storeWatches,\n    params: storeWatchesRefs,\n    forkPage: isScope ? domain : false,\n  })\n}\n\nfunction fillValues({\n  flatGraphUnits,\n  values,\n  collectWatches,\n}: {\n  flatGraphUnits: Node[]\n  values: Record<string, any>\n  collectWatches: boolean\n}) {\n  const storeWatches: Node[] = []\n  const storeWatchesRefs: StateRef[] = []\n  const refsMap = {} as Record<string, StateRef>\n  const predefinedRefs = new Set()\n  const valuesSidList = Object.getOwnPropertyNames(values)\n  forEach(flatGraphUnits, node => {\n    const {reg} = node\n    const {op, unit, sid} = node.meta\n    if (unit === STORE) {\n      if (sid && includes(valuesSidList, sid)) {\n        const {state} = node.scope\n        state.current = values[sid]\n        predefinedRefs.add(state)\n      }\n    }\n    if (collectWatches && op === 'watch') {\n      const owner = node.family.owners[0]\n      if (owner.meta.unit === STORE) {\n        storeWatches.push(node)\n        storeWatchesRefs.push(owner.scope.state)\n      }\n    }\n    forIn(reg, (ref, id) => {\n      refsMap[id] = ref\n    })\n  })\n  const refGraph = createRefGraph(refsMap)\n  const result = toposort(refGraph)\n  forEach(result, id => {\n    execRef(refsMap[id])\n  })\n\n  return {\n    storeWatches,\n    storeWatchesRefs,\n  }\n\n  function execRef(ref: StateRef) {\n    let isFresh = false\n    if (ref.before && !predefinedRefs.has(ref)) {\n      forEach(ref.before, cmd => {\n        switch (cmd.type) {\n          case MAP: {\n            const from = cmd.from\n            ref.current = cmd.fn(from.current)\n            break\n          }\n          case 'field': {\n            const from = cmd.from\n            if (!isFresh) {\n              isFresh = true\n              if (Array.isArray(ref.current)) {\n                ref.current = [...ref.current]\n              } else {\n                ref.current = {...ref.current}\n              }\n            }\n            ref.current[cmd.field] = from.current\n            break\n          }\n          case 'closure':\n            break\n        }\n      })\n    }\n    if (!ref.after) return\n    const value = ref.current\n    forEach(ref.after, cmd => {\n      const to = cmd.to\n      // if (predefinedRefs.has(to)) continue\n      switch (cmd.type) {\n        case 'copy':\n          to.current = value\n          break\n        case MAP:\n          to.current = cmd.fn(value)\n          break\n      }\n    })\n  }\n}\n\nfunction createRefGraph(refsMap: Record<string, StateRef>) {\n  const items = Object.values(refsMap)\n  const refGraph = {} as Record<string, string[]>\n  forEach(items, ({id}) => {\n    refGraph[id] = []\n  })\n  //prettier-ignore\n  forEach(items, ({id, before, after}) => {\n    before && forEach(before, cmd => {\n      refGraph[cmd.from.id].push(id)\n    })\n    after && forEach(after, cmd => {\n      refGraph[id].push(cmd.to.id)\n    })\n  })\n  return refGraph\n}\n\n/**\n serialize state on server\n */\nexport function serialize(\n  {clones, changedStores}: any,\n  {\n    ignore = [],\n    onlyChanges,\n  }: {ignore?: Array<Store<any>>; onlyChanges?: boolean} = {},\n) {\n  const result = {} as Record<string, any>\n  forEach(clones, ({meta, scope, reg}) => {\n    if (meta.unit !== STORE) return\n    const {sid} = meta\n    if (!sid) return\n    if (onlyChanges || meta.isCombine) {\n      if (!changedStores.has(meta.forkOf.id)) return\n    }\n    result[sid] = reg[scope.state.id].current\n  })\n  forEach(ignore, ({sid}) => {\n    if (sid) delete result[sid]\n  })\n  return result\n}\n\n/** bind event to scope */\nexport function scopeBind(unit: any) {\n  if (!forkPage) {\n    throwError('scopeBind cannot be called outside of forked .watch')\n  }\n  const savedForkPage = forkPage\n  const localUnit = forkPage.find(unit)\n  return is.effect(unit)\n    ? (params: any) => {\n        const req = createDefer()\n        launch({\n          target: localUnit,\n          params: {\n            params,\n            req,\n          },\n          forkPage: savedForkPage,\n        })\n      }\n    : (params: any) => {\n        launch({target: localUnit, params, forkPage: savedForkPage})\n        return params\n      }\n}\n\nfunction normalizeValues(\n  values: Map<Store<any>, any> | Record<string, any>,\n  assertEach = (key: any, value: any) => {},\n) {\n  if (values instanceof Map) {\n    const result = {} as Record<string, any>\n    for (const [key, value] of values) {\n      if (!is.unit(key)) throwError('Map key should be a unit')\n      assertEach(key, value)\n      result[key.sid!] = value\n    }\n    return result\n  }\n  return values\n}\n\nexport function fork(\n  domain: Domain,\n  {values, handlers}: {values?: any; handlers?: any} = {},\n) {\n  if (!is.domain(domain)) throwError('first argument of fork should be domain')\n  const needToFill = !!values\n  values = normalizeValues(\n    values || {},\n    unit =>\n      !is.store(unit) &&\n      throwError('Values map can contain only stores as keys'),\n  )\n  const forked = cloneGraph(domain)\n  if (needToFill) {\n    fillValues()\n  }\n  if (handlers) {\n    handlers = normalizeValues(\n      handlers,\n      unit =>\n        !is.effect(unit) &&\n        throwError(`Handlers map can contain only effects as keys`),\n    )\n    const handlerKeys = Object.keys(handlers)\n    forEach(forked.clones, ({scope, meta}) => {\n      if (meta.sid && includes(handlerKeys, meta.sid)) {\n        scope.runner.scope.getHandler = () => handlers[meta.sid]\n      }\n    })\n  }\n  return forked\n\n  function fillValues() {\n    const sourceList = flatGraph(domain)\n    const sourceRefsMap = {} as Record<string, StateRef>\n    const refsMap = {} as Record<string, StateRef>\n    const predefinedRefs = new Set()\n    const templateOwnedRefs = new Set<string>()\n    const valuesSidList = Object.getOwnPropertyNames(values)\n    forEach(sourceList, ({reg, meta}) => {\n      const {nativeTemplate} = meta\n      forIn(reg, (ref, id) => {\n        sourceRefsMap[id] = ref\n        if (nativeTemplate) {\n          templateOwnedRefs.add(id)\n        }\n      })\n    })\n    forEach(forked.clones, node => {\n      const {reg} = node\n      const {unit, sid} = node.meta\n      if (unit === STORE) {\n        if (sid && includes(valuesSidList, sid)) {\n          const {state} = node.scope\n          reg[state.id].current = values[sid]\n          predefinedRefs.add(state)\n          forked.changedStores.add(node.meta.forkOf.id)\n        }\n      }\n      forIn(reg, (ref, id) => {\n        refsMap[id] = ref\n      })\n    })\n    const refGraph = createRefGraph(sourceRefsMap)\n    const result = toposort(refGraph, templateOwnedRefs)\n    forEach(result, id => {\n      execRef(refsMap[id], sourceRefsMap[id])\n    })\n\n    function execRef(ref: StateRef, sourceRef?: StateRef) {\n      let isFresh = false\n      if (sourceRef && sourceRef.before && !predefinedRefs.has(ref)) {\n        forEach(sourceRef.before, cmd => {\n          switch (cmd.type) {\n            case MAP: {\n              const from = refsMap[cmd.from.id]\n              ref.current = cmd.fn(from.current)\n              break\n            }\n            case 'field': {\n              const from = refsMap[cmd.from.id]\n              if (!isFresh) {\n                isFresh = true\n                if (Array.isArray(ref.current)) {\n                  ref.current = [...ref.current]\n                } else {\n                  ref.current = {...ref.current}\n                }\n              }\n              ref.current[cmd.field] = from.current\n              break\n            }\n            case 'closure':\n              break\n          }\n        })\n      }\n      if (!sourceRef || !sourceRef.after) return\n      const value = ref.current\n      forEach(sourceRef.after, cmd => {\n        const to = refsMap[cmd.to.id]\n        // if (predefinedRefs.has(to)) continue\n        switch (cmd.type) {\n          case 'copy':\n            to.current = value\n            break\n          case MAP:\n            to.current = cmd.fn(value)\n            break\n        }\n      })\n    }\n  }\n}\n\nfunction toposort(rawGraph: Record<string, string[]>, ignore?: Set<string>) {\n  const graph = {} as Record<string, string[]>\n  for (const id in rawGraph) {\n    graph[id] = [...new Set(rawGraph[id])]\n  }\n  const result = [] as string[]\n  const visited = {} as Record<string, boolean>\n  const temp = {} as Record<string, boolean>\n  for (const node in graph) {\n    if (!visited[node] && !temp[node]) {\n      topologicalSortHelper(node)\n    }\n  }\n  result.reverse()\n  if (ignore && ignore.size > 0) {\n    const processed = [] as string[]\n    const ignored = [...ignore]\n    let item: string | void\n    while ((item = ignored.shift())) {\n      processed.push(item)\n      forEach(graph[item], child => {\n        if (includes(processed, child) || includes(ignored, child)) return\n        ignored.push(child)\n      })\n    }\n    forEach(processed, item => {\n      removeItem(result, item)\n    })\n  }\n  return result\n\n  function topologicalSortHelper(node: string) {\n    temp[node] = true\n    const neighbors = graph[node]\n    for (let i = 0; i < neighbors.length; i++) {\n      const n = neighbors[i]\n      if (temp[n]) {\n        continue\n        // throw Error('found cycle in DAG')\n      }\n      if (!visited[n]) {\n        topologicalSortHelper(n)\n      }\n    }\n    temp[node] = false\n    visited[node] = true\n    result.push(node)\n  }\n}\n\nexport function allSettled(\n  start: any,\n  {scope, params: ctx}: {scope: any; params?: any},\n) {\n  if (!is.unit(start))\n    return Promise.reject(Error('first argument should be unit'))\n  const defer = createDefer()\n  //@ts-ignore\n  defer.parentFork = forkPage\n  const {forkInFlightCounter} = scope.graphite.scope\n  forkInFlightCounter.scope.defers.push(defer)\n  const contextStart = scope.find(start)\n\n  const launchUnits = [contextStart]\n  const launchParams = []\n  if (is.effect(start)) {\n    launchParams.push({\n      params: ctx,\n      req: {\n        rs(value: any) {\n          //@ts-ignore\n          defer.value = {status: 'done', value}\n        },\n        rj(value: any) {\n          //@ts-ignore\n          defer.value = {status: 'fail', value}\n        },\n      },\n    })\n  } else {\n    launchParams.push(ctx)\n  }\n  launchUnits.push(forkInFlightCounter)\n  launchParams.push(null)\n  launch({\n    target: launchUnits,\n    params: launchParams,\n    forkPage: scope,\n  })\n  return defer.req\n}\n\nfunction flatGraph(unit: any) {\n  const list = [] as Node[]\n  ;(function traverse(node) {\n    if (includes(list, node)) return\n    list.push(node)\n    forEachRelatedNode(node, traverse)\n  })(getGraph(unit))\n  return list\n}\n\n/**\n everything we need to clone graph section\n reachable from given unit\n */\nfunction cloneGraph(unit: any) {\n  const list = flatGraph(unit)\n  const refs = new Map()\n  const scope = {\n    defers: [],\n    inFlight: 0,\n    fxID: 0,\n  }\n  const changedStores = new Set<string>()\n  const putStoreToChanged = step.compute({\n    fn(upd, _, stack) {\n      if (\n        !stack.node.meta.isCombine ||\n        (getParent(stack) && getParent(stack).node.meta.op !== 'combine')\n      )\n        changedStores.add(stack.node.meta.forkOf.id)\n      return upd\n    },\n  })\n  const forkInFlightCounter = createNode({\n    scope,\n    node: [\n      step.compute({\n        fn(_, scope, stack) {\n          if (!stack.parent) {\n            scope.fxID += 1\n            return\n          }\n          if (stack.parent.node.meta.named === 'finally') {\n            scope.inFlight -= 1\n          } else {\n            scope.inFlight += 1\n            scope.fxID += 1\n          }\n        },\n      }),\n      step.barrier({priority: SAMPLER}),\n      step.run({\n        fn(_, scope) {\n          const {inFlight, defers, fxID} = scope\n          if (inFlight > 0 || defers.length === 0) return\n          Promise.resolve().then(() => {\n            if (scope.fxID !== fxID) return\n            forEach(defers.splice(0, defers.length), (defer: any) => {\n              setForkPage(defer.parentFork)\n              defer.rs(defer.value)\n            })\n          })\n        },\n      }),\n    ],\n    meta: {unit: FORK_COUNTER},\n  })\n  const nodeMap = {} as Record<string, Node>\n  const sidMap = {} as Record<string, Node>\n  const clones = list.map(node => {\n    const {seq, next, meta, scope} = node\n    const result = createNode({\n      node: seq.map(step => ({\n        id: step.id,\n        type: step.type,\n        data: {...step.data},\n        hasRef: step.hasRef,\n      })) as any,\n      child: [...next],\n      meta: {forkOf: node, ...meta},\n      scope: {...scope},\n    })\n    result.family = {\n      type: node.family.type,\n      links: [...getLinks(node)],\n      owners: [...getOwners(node)],\n    }\n    nodeMap[node.id] = result\n    if (meta.sid) sidMap[meta.sid] = result\n    return result\n  })\n  const page = {} as Record<string, StateRef>\n  forEach(clones, node => {\n    const {\n      reg,\n      scope,\n      meta: {onCopy, op, unit},\n    } = node\n    forIn(reg, (ref, id) => {\n      let newRef = refs.get(ref)\n      if (!newRef) {\n        newRef = {\n          id: ref.id,\n          current: ref.current, //ref.id in values ? values[ref.id] : ref.current,\n        }\n        refs.set(ref, newRef)\n      }\n      page[id] = reg[id] = newRef\n    })\n    if (onCopy) {\n      forEach(onCopy, (copyField: string) => {\n        const origValue = scope[copyField]\n        scope[copyField] = Array.isArray(origValue)\n          ? origValue.map(findClone)\n          : findClone(origValue)\n      })\n    }\n    forEachRelatedNode(node, (node, i, siblings) => {\n      siblings[i] = findClone(node)\n    })\n    const itemTag = op || unit\n    switch (itemTag) {\n      case STORE:\n        node.meta.wrapped = wrapStore(node)\n        if (node.meta.sid) node.seq.push(putStoreToChanged)\n        break\n      // case EVENT:\n      //   break\n      case EFFECT:\n        node.next.push(forkInFlightCounter)\n        break\n      case 'fx': {\n        scope.finally.next.push(forkInFlightCounter)\n        break\n      }\n      // case 'watch':\n      //   break\n    }\n  })\n\n  return {\n    cloneOf: unit,\n    changedStores,\n    nodeMap,\n    sidMap,\n    clones,\n    find: findClone,\n    reg: page,\n    getState: (store: any) => findClone(store).meta.wrapped.getState(),\n    graphite: createNode({\n      family: {\n        type: DOMAIN,\n        links: [forkInFlightCounter, ...clones],\n      },\n      meta: {unit: 'fork'},\n      scope: {forkInFlightCounter},\n    }),\n  }\n\n  function findClone(unit: any) {\n    const node = getGraph(unit)\n    const index = list.indexOf(node)\n    if (index === -1) {\n      let unitName = 'unit'\n      if (unit !== node && unit.id !== unit.shortName) unitName = unit.shortName\n      throwError(`${unitName} not found in forked scope`)\n    }\n    return clones[index]\n  }\n}\n\nfunction wrapStore(node: Node) {\n  return {\n    kind: STORE,\n    getState: () => node.reg[node.scope.state.id].current,\n    updates: {\n      watch: bind(watchUnit, node),\n    },\n    graphite: node,\n    family: node.family,\n  }\n}\n\nfunction forEachRelatedNode(\n  node: Node,\n  cb: (node: Node, index: number, siblings: Node[]) => void,\n) {\n  const unit = node.meta.unit\n  if (unit === 'fork' || unit === FORK_COUNTER) return\n  forEach(node.next, cb)\n  forEach(getOwners(node), cb)\n  forEach(getLinks(node), cb)\n}\n","export const observableSymbol: any =\n  (typeof Symbol !== 'undefined' && Symbol.observable) || '@@observable'\n","import {kind} from './index.h'\nimport {DOMAIN, STORE, EVENT, EFFECT} from './tag'\nimport {isObject, isFunction} from './is'\n\nexport const unit = (obj: any) =>\n  (isFunction(obj) || isObject(obj)) && 'kind' in obj\n\nconst is = (type: kind) => (obj: any) => unit(obj) && obj.kind === type\n\nexport const store = is(STORE)\nexport const event = is(EVENT)\nexport const effect = is(EFFECT)\nexport const domain = is(DOMAIN)\n","export const throwError = (message: string) => {\n  throw Error(message)\n}\n","const idCount = () => {\n  let id = 0\n  return () => (++id).toString(36)\n}\n\nexport const nextUnitID = idCount()\nexport const nextStepID = idCount()\nexport const nextNodeID = idCount()\n","export const bind = (fn: Function, target: any) => fn.bind(null, target)\nexport const bind2 = (fn: Function, target: any, arg: any) =>\n  fn.bind(null, target, arg)\n","import {StateRef, Run, Filter, Compute, Barrier, Check, Mov} from './index.h'\nimport {nextStepID} from './id'\nimport {bind2} from './bind'\nimport {BARRIER, FILTER, STACK, STORE} from './tag'\n\nconst cmd = (type: any, hasRef: boolean, data: any): any => ({\n  id: nextStepID(),\n  type,\n  data,\n  hasRef,\n})\n\nlet nextBarrierID = 0\n\nexport const barrier: (data: {priority?: 'barrier' | 'sampler'}) => Barrier = ({\n  priority = BARRIER,\n}) =>\n  cmd(BARRIER, false, {\n    barrierID: ++nextBarrierID,\n    priority,\n  })\nexport const mov: (data: {\n  from?: 'value' | 'store' | 'stack' | 'a' | 'b'\n  to?: 'stack' | 'a' | 'b' | 'store'\n  store?: any\n  target?: any\n}) => Mov = ({from = STORE, store, target, to = target ? STORE : STACK}) =>\n  cmd('mov', from === STORE, {from, store, to, target})\nexport const check: {\n  defined(): Check\n  changed(config: {store: StateRef}): Check\n} = {\n  defined: () => cmd('check', false, {type: 'defined'}),\n  changed: ({store}) => cmd('check', true, {type: 'changed', store}),\n}\nexport const compute: (data: {\n  fn: (data: any, scope: {[key: string]: any}, stack: any) => any\n}) => Compute = bind2(cmd, 'compute', false)\nexport const filter: (data: {\n  fn: (data: any, scope: {[key: string]: any}, stack: any) => any\n}) => Filter = bind2(cmd, FILTER, false)\nexport const run: (data: {\n  fn: (data: any, scope: {[key: string]: any}, stack: any) => any\n}) => Run = bind2(cmd, 'run', false)\nexport const update: (data: {store: StateRef}) => Mov = ({store}) =>\n  mov({from: STACK, target: store})\n","import {StateRef} from './index.h'\nimport {nextStepID} from './id'\n\nexport const createStateRef = (current?: any): StateRef => ({\n  id: nextStepID(),\n  current,\n})\nexport const readRef = ({current}: StateRef | {current: any}) => current\n","export const callStackAReg = (stack: any, {fn}: any, {a}: any) => fn(stack, a)\nexport const callARegStack = (stack: any, {fn}: any, {a}: any) => fn(a, stack)\nexport const callStack = (stack: any, {fn}: any, _: any) => fn(stack)\n","import {Node, StateRef} from './index.h'\n\nexport const getGraph = (graph: any): Node => graph.graphite || graph\nexport const getOwners = (node: Node) => node.family.owners\nexport const getLinks = (node: Node) => node.family.links\nexport const getStoreState = (store: any): StateRef => store.stateRef\nexport const getConfig = (opts: any) => opts.config\nexport const getNestedConfig = (opts: any) => opts.ɔ\nexport const getValue = (stack: any) => stack.value\nexport const getSubscribers = (store: any) => store.subscribers\nexport const getParent = (unit: any) => unit.parent\nexport const getForkPage = (val: any) => val.forkPage\n","import {NodeUnit} from './index.h'\nimport {getGraph, getOwners, getLinks} from './getter'\nimport {DOMAIN, CROSSLINK} from './tag'\n\nexport const own = (ownerUnit: NodeUnit, links: NodeUnit[]) => {\n  const owner = getGraph(ownerUnit)\n  for (let i = 0; i < links.length; i++) {\n    const link = getGraph(links[i])\n    if (owner.family.type !== DOMAIN) link.family.type = CROSSLINK\n    getOwners(link).push(owner)\n    getLinks(owner).push(link)\n  }\n}\n","import {getConfig, getNestedConfig} from './getter'\nimport {assertObject} from './is'\n\nexport const onConfigNesting = (\n  rawConfig: any,\n  fn: (babelData: any, userConfig: any) => void,\n) => {\n  assertObject(rawConfig)\n  if (getNestedConfig(rawConfig)) {\n    fn(getConfig(rawConfig), getNestedConfig(rawConfig))\n  }\n}\n\nexport const processArgsToConfig = (args: any[]): [any[], any | void] => {\n  let metadata\n  onConfigNesting(args[0], (injected, config) => {\n    metadata = injected\n    args = config\n  })\n  return [args, metadata]\n}\n","import {Node, NodeUnit} from './index.h'\nimport {getGraph, getOwners, getLinks, getSubscribers} from './getter'\nimport {is} from './is'\nimport {removeItem} from './collection'\nimport {CROSSLINK} from './tag'\n\nconst removeFromNode = (currentNode: Node, targetNode: Node) => {\n  removeItem(currentNode.next, targetNode)\n  removeItem(getOwners(currentNode), targetNode)\n  removeItem(getLinks(currentNode), targetNode)\n}\nconst clearNodeNormalized = (\n  targetNode: Node,\n  deep: boolean,\n  isDomainUnit: boolean,\n) => {\n  targetNode.next.length = 0\n  targetNode.seq.length = 0\n  //@ts-ignore\n  targetNode.scope = null\n  let currentNode\n  let list = getLinks(targetNode)\n  while ((currentNode = list.pop())) {\n    removeFromNode(currentNode, targetNode)\n    if (\n      deep ||\n      (isDomainUnit && !targetNode.meta.sample) ||\n      currentNode.family.type === CROSSLINK\n    ) {\n      clearNodeNormalized(\n        currentNode,\n        deep,\n        currentNode.meta.op !== 'on' && isDomainUnit,\n      )\n    }\n  }\n  list = getOwners(targetNode)\n  while ((currentNode = list.pop())) {\n    removeFromNode(currentNode, targetNode)\n    if (isDomainUnit && currentNode.family.type === CROSSLINK) {\n      clearNodeNormalized(\n        currentNode,\n        deep,\n        currentNode.meta.op !== 'on' && isDomainUnit,\n      )\n    }\n  }\n}\nconst clearMap = (map: any) => map.clear()\nexport const clearNode = (\n  graphite: NodeUnit,\n  {\n    deep,\n  }: {\n    deep?: boolean\n  } = {},\n) => {\n  let isDomainUnit = false\n  //@ts-ignore\n  if (graphite.ownerSet) graphite.ownerSet.delete(graphite)\n  if (is.store(graphite)) {\n    clearMap(getSubscribers(graphite))\n  } else if (is.domain(graphite)) {\n    isDomainUnit = true\n    //@ts-ignore\n    const history = graphite.history\n    clearMap(history.events)\n    clearMap(history.effects)\n    clearMap(history.stores)\n    clearMap(history.domains)\n  }\n  clearNodeNormalized(getGraph(graphite), !!deep, isDomainUnit)\n}\n","import {Subscription, NodeUnit} from './index.h'\nimport {bind2} from './bind'\nimport {clearNode} from './clearNode'\n\nexport const createSubscription = (node: NodeUnit): Subscription => {\n  const result = bind2(clearNode, node, undefined)\n  result.unsubscribe = result\n  return result\n}\n","import {onConfigNesting} from './config'\nimport {createNode} from './createNode'\nimport {Subscription, NodeUnit, Cmd} from './index.h'\nimport {createSubscription} from './subscription'\nimport {assertNodeSet} from './is'\n\nexport const createLinkNode = (\n  parent: NodeUnit,\n  child: NodeUnit | NodeUnit[],\n  {\n    node,\n    scope,\n    meta,\n  }: {\n    node?: Array<Cmd | false | void | null>\n    scope?: {[name: string]: any}\n    meta?: {[name: string]: any}\n  },\n) =>\n  createNode({\n    node,\n    parent,\n    child,\n    scope,\n    meta,\n    family: {\n      owners: [parent, child],\n      links: child,\n    },\n    regional: true,\n  })\nexport const forward = (opts: {\n  from: NodeUnit | NodeUnit[]\n  to: NodeUnit | NodeUnit[]\n  meta?: Record<string, any>\n}): Subscription => {\n  let config\n  onConfigNesting(opts, (injectedData, userConfig) => {\n    config = injectedData\n    opts = userConfig\n  })\n  const {from, to, meta = {op: 'forward'}} = opts\n  assertNodeSet(from, 'forward', '\"from\"')\n  assertNodeSet(to, 'forward', '\"to\"')\n  if (config) meta.config = config\n  return createSubscription(\n    createNode({\n      parent: from,\n      child: to,\n      meta,\n      family: {},\n      regional: true,\n    }),\n  )\n}\n","import {step} from './typedef'\nimport {callStack} from './caller'\nimport {createNode} from './createNode'\nimport {Subscription, NodeUnit} from './index.h'\nimport {createSubscription} from './subscription'\nimport {throwError} from './throw'\nimport {isFunction} from './is'\nimport {forkPage} from './kernel'\nimport {getGraph} from './getter'\n\nexport const watchUnit = (\n  unit: NodeUnit,\n  handler: (payload: any) => any,\n): Subscription => {\n  if (!isFunction(handler)) throwError('.watch argument should be a function')\n  if (forkPage) {\n    const forkedNode = forkPage.nodeMap[getGraph(unit).id]\n    if (forkedNode) unit = forkedNode\n  }\n  return createSubscription(\n    createNode({\n      scope: {fn: handler},\n      node: [step.run({fn: callStack})],\n      parent: unit,\n      meta: {op: 'watch'},\n      family: {\n        owners: unit,\n      },\n      regional: true,\n    }),\n  )\n}\n","import {Store, Event, Effect, Domain} from './unit.h'\nimport {own} from './own'\nimport {createNode} from './createNode'\nimport {Config, NodeUnit} from './index.h'\nimport {\n  createEvent,\n  createStore,\n  createNamedEvent,\n  initUnit,\n} from './createUnit'\nimport {createEffect} from './createEffect'\nimport {forward} from './forward'\nimport {forIn} from './collection'\nimport {getGraph, getParent} from './getter'\nimport {DOMAIN} from './tag'\nimport {launch} from './kernel'\nimport {step} from './typedef'\n\nconst createHook = (trigger: Event<any>, acc: Set<any>, node: any) => {\n  trigger.create = res => {\n    launch(trigger, res)\n    return res\n  }\n  getGraph(trigger).seq.push(\n    step.compute({\n      fn(upd, _, stack) {\n        stack.forkPage = null\n        return upd\n      },\n    }),\n  )\n  trigger.watch(data => {\n    own(node, [data])\n    acc.add(data)\n    if (!data.ownerSet) data.ownerSet = acc\n    if (!getParent(data)) data.parent = node\n  })\n  own(node, [trigger])\n  return (hook: (data: any) => any) => {\n    acc.forEach(hook)\n    return trigger.watch(hook)\n  }\n}\n\nexport function createDomain(nameOrConfig: any, maybeConfig?: any): Domain {\n  const domains: Set<Domain> = new Set()\n  const stores: Set<Store<any>> = new Set()\n  const effects: Set<Effect<any, any, any>> = new Set()\n  const events: Set<Event<any>> = new Set()\n\n  const node = createNode({\n    family: {type: DOMAIN},\n    regional: true,\n  })\n\n  const result: any = {\n    history: {\n      domains,\n      stores,\n      effects,\n      events,\n    },\n    graphite: node,\n  }\n\n  node.meta = initUnit(DOMAIN, result, maybeConfig, nameOrConfig)\n  const [event, effect, store, domain] = [\n    'onEvent',\n    'onEffect',\n    'onStore',\n    'onDomain',\n  ].map(createNamedEvent)\n\n  result.hooks = {\n    event,\n    effect,\n    store,\n    domain,\n  }\n  result.onCreateEvent = createHook(event, events, result)\n  result.onCreateEffect = createHook(effect, effects, result)\n  result.onCreateStore = createHook(store, stores, result)\n  result.onCreateDomain = createHook(domain, domains, result)\n\n  result.createEvent = result.event = (nameOrConfig: any, config?: Config) =>\n    event(\n      createEvent(nameOrConfig, {\n        parent: result,\n        config,\n      }),\n    )\n  result.createEffect = result.effect = (nameOrConfig: any, config?: Config) =>\n    effect(\n      createEffect(nameOrConfig, {\n        parent: result,\n        config,\n      }),\n    )\n  result.createDomain = result.domain = (nameOrConfig: any, config?: Config) =>\n    createDomain({\n      name: nameOrConfig,\n      parent: result,\n      config,\n    })\n  result.createStore = result.store = (state: any, config?: Config) =>\n    store(\n      createStore(state, {\n        parent: result,\n        config,\n      }),\n    )\n  const parent = getParent(result)\n  if (parent) {\n    forIn(result.hooks, (from: NodeUnit, key) => {\n      forward({from, to: parent.hooks[key]})\n    })\n    parent.hooks.domain(result)\n  }\n  return result\n}\n","import {Event} from './unit.h'\nimport {NodeUnit, Cmd} from './index.h'\nimport {is, isFunction, isObject} from './is'\nimport {forIn, includes} from './collection'\nimport {createStateRef} from './stateRef'\nimport {readTemplate} from './region'\nimport {createLinkNode} from './forward'\nimport {processArgsToConfig} from './config'\nimport {step} from './typedef'\nimport {createNode} from './createNode'\nimport {launch} from './kernel'\nimport {getStoreState} from './getter'\nimport {REG_A} from './tag'\nimport {throwError} from './throw'\nimport {createEvent} from './createUnit'\n\nconst launchCase = (\n  scopeTargets: Record<string, NodeUnit>,\n  field: string,\n  data: any,\n  stack: any,\n) => {\n  const target = scopeTargets[field]\n  if (target) {\n    launch({\n      target,\n      params: Array.isArray(target) ? target.map(() => data) : data,\n      defer: true,\n      stack,\n    })\n  }\n}\n\nexport function split(...args: any[]): any {\n  let targets: Record<string, Event<any> | NodeUnit>\n  let [[source, match], metadata] = processArgsToConfig(args)\n  const knownCases = !match\n  if (knownCases) {\n    targets = source.cases\n    match = source.match\n    source = source.source\n  }\n  const matchIsUnit = is.store(match)\n  const matchIsFunction = !is.unit(match) && isFunction(match)\n  const matchIsShape = !matchIsUnit && !matchIsFunction && isObject(match)\n  if (!targets!) targets = {}\n  if (!knownCases) {\n    if (!matchIsShape) throwError('match should be an object')\n    forIn(match, (_, key) => {\n      //@ts-ignore\n      targets[key] = createEvent(metadata)\n    })\n    targets.__ = createEvent(metadata)\n  }\n  //@ts-ignore\n  const template = readTemplate()\n  const owners = new Set(\n    ([] as NodeUnit[]).concat(source, Object.values(targets)),\n  )\n  const caseNames = Object.keys(\n    matchIsUnit || matchIsFunction ? targets : match,\n  )\n  let splitterSeq: Array<Cmd | false>\n  if (matchIsUnit || matchIsFunction) {\n    if (matchIsUnit) owners.add(match)\n    splitterSeq = [\n      matchIsUnit && step.barrier({priority: 'sampler'}),\n      matchIsUnit &&\n        step.mov({\n          store: getStoreState(match),\n          to: 'a',\n        }),\n      step.filter({\n        fn(data, scopeTargets, stack) {\n          const value = String(matchIsUnit ? stack.a : match(data))\n          launchCase(\n            scopeTargets,\n            includes(caseNames, value) ? value : '__',\n            data,\n            stack,\n          )\n        },\n      }),\n    ]\n  } else if (matchIsShape) {\n    const lastValues = createStateRef({})\n    lastValues.type = 'shape'\n    const before: any[] = (lastValues.before = [])\n    const updaterSteps = [\n      step.mov({\n        store: lastValues,\n        to: REG_A,\n      }),\n      step.compute({\n        fn(upd, {key}, {a}) {\n          a[key] = upd\n        },\n      }),\n    ]\n    const units = [] as string[]\n    let needBarrier: boolean\n    forIn(match, (storeOrFn: any, key) => {\n      if (is.unit(storeOrFn)) {\n        needBarrier = true\n        units.push(key)\n        owners.add(storeOrFn)\n        const updater = createLinkNode(storeOrFn, [], {\n          node: updaterSteps,\n          scope: {key},\n        })\n        if (is.store(storeOrFn)) {\n          lastValues.current[key] = storeOrFn.getState()\n          const storeRef = getStoreState(storeOrFn)\n          before.push({\n            type: 'field',\n            field: key,\n            from: storeRef,\n          })\n          if (template) {\n            if (!includes(template.plain, storeRef)) {\n              updater.seq.unshift(template.loader)\n            }\n          }\n        }\n      }\n    })\n    if (needBarrier! && template) {\n      template.plain.push(lastValues)\n    }\n    splitterSeq = [\n      needBarrier! && step.barrier({priority: 'sampler'}),\n      needBarrier! &&\n        step.mov({\n          store: lastValues,\n          to: 'a',\n        }),\n      step.filter({\n        fn(data, scopeTargets, stack) {\n          for (let i = 0; i < caseNames.length; i++) {\n            const caseName = caseNames[i]\n            const caseValue = includes(units, caseName)\n              ? stack.a[caseName]\n              : match[caseName](data)\n            if (caseValue) {\n              launchCase(scopeTargets, caseName, data, stack)\n              return\n            }\n          }\n          launchCase(scopeTargets, '__', data, stack)\n        },\n      }),\n    ]\n  } else {\n    throwError('expect match to be unit, function or object')\n  }\n  createNode({\n    meta: {\n      onCopy: Object.keys(targets),\n      op: 'split',\n    },\n    parent: source,\n    scope: targets,\n    node: splitterSeq!,\n    family: {\n      type: 'crosslink',\n      owners: Array.from(owners),\n    },\n    regional: true,\n  })\n  if (!knownCases) return targets\n}\n","import {combine} from './combine'\nimport {createEffect, onSettled} from './createEffect'\nimport {applyParentHook} from './createUnit'\nimport {onConfigNesting} from './config'\nimport {getGraph, getStoreState} from './getter'\nimport {own} from './own'\nimport {is} from './is'\nimport {step} from './typedef'\nimport {launch} from './kernel'\nimport {addToReg} from './createNode'\nimport {STORE, EFFECT, REG_A} from './tag'\n\nexport function attach(config: any) {\n  let injected\n  onConfigNesting(config, (injectedData, userConfig) => {\n    injected = injectedData\n    config = userConfig\n  })\n  let {source, effect, mapParams} = config\n  if (!mapParams)\n    mapParams = source\n      ? (_: any, source: any) => source\n      : (params: any) => params\n  const attached = createEffect(config, injected)\n  const {runner} = getGraph(attached).scope\n\n  let runnerSteps\n  const runnerFn = (\n    {params, req}: any,\n    {finally: anyway, effect}: any,\n    stack: any,\n  ) => {\n    const rj = onSettled({\n      params,\n      req,\n      ok: false,\n      anyway,\n      stack,\n    })\n    let computedParams\n    try {\n      computedParams = mapParams(params, stack.a)\n    } catch (err) {\n      return rj(err)\n    }\n    launch({\n      target: effect,\n      params: {\n        params: computedParams,\n        req: {\n          rs: onSettled({\n            params,\n            req,\n            ok: true,\n            anyway,\n            stack,\n          }),\n          rj,\n        },\n      },\n      page: stack.page,\n      defer: true,\n    })\n  }\n  if (source) {\n    let state\n    if (is.store(source)) {\n      state = source\n      own(source, [attached])\n    } else {\n      state = combine(source)\n      own(attached, [state])\n    }\n    const readStateRef = step.mov({\n      from: STORE,\n      store: getStoreState(state),\n      to: REG_A,\n    })\n    runnerSteps = [\n      /* let another side-effects run first */\n      step.run({fn: _ => _}),\n      /* read state. assumed it already stable here because of previous step */\n      readStateRef,\n      /* no need for step.run because of first step */\n      step.compute({fn: runnerFn}),\n    ]\n    addToReg(readStateRef, runner.reg)\n  } else {\n    runnerSteps = [step.run({fn: runnerFn})]\n  }\n  own(effect, [attached])\n  runner.scope.effect = effect\n  runner.meta.onCopy.push(EFFECT)\n  runner.seq.splice(0, 1, ...runnerSteps)\n  applyParentHook(effect, attached, EFFECT)\n  return attached\n}\n","import {Store, Event} from './unit.h'\nimport {createEvent, applyParentHook} from './createUnit'\nimport {forIn} from './collection'\nimport {getParent} from './getter'\nimport {processArgsToConfig} from './config'\n\nexport function createApi(...args: [Store<any>, {[key: string]: Function}]) {\n  let [[store, setters], metadata] = processArgsToConfig(args)\n  const result: Record<string, Event<any>> = {}\n  forIn(setters, (fn, key) => {\n    const event = (result[key] = createEvent(key, {\n      parent: getParent(store),\n      config: metadata,\n    }))\n    store.on(event, fn)\n    applyParentHook(store, event)\n  })\n  return result\n}\n","import {observableSymbol} from './observable'\nimport {Event} from './unit.h'\nimport {clearNode} from './clearNode'\nimport {createEvent} from './createUnit'\nimport {bind2} from './bind'\nimport {assertObject} from './is'\nimport {throwError} from './throw'\n\nexport function fromObservable<T>(observable: any): Event<T> {\n  assertObject(observable)\n  const observableItem =\n    observableSymbol in observable ? observable[observableSymbol]() : observable\n  if (!observableItem.subscribe)\n    throwError('expect observable to have .subscribe')\n  const event = createEvent<T>()\n  const disposer = bind2(clearNode, event, undefined)\n  observableItem.subscribe({\n    next: event,\n    error: disposer,\n    complete: disposer,\n  })\n  return event\n}\n","import {processArgsToConfig} from './config'\nimport {createLinkNode} from './forward'\nimport {sample} from './sample'\nimport {createEvent} from './createUnit'\nimport {combine} from './combine'\nimport {step} from './typedef'\nimport {callStack} from './caller'\nimport {assertNodeSet, is, isFunction} from './is'\nimport {createNode} from './createNode'\nimport {throwError} from './throw'\nimport {merge} from './merge'\n\nexport function guard(...args: any[]) {\n  const meta: Record<string, any> = {op: 'guard'}\n  let rawName = 'guard'\n  let [[source, config], metadata] = processArgsToConfig(args)\n  if (metadata) {\n    meta.config = metadata\n    if (metadata.name) rawName = metadata.name\n  }\n  if (!config) {\n    config = source\n    source = config.source\n  }\n  let {filter, greedy, clock, name = rawName} = config\n  const target = config.target || createEvent(name, meta.config)\n  const filterIsUnit = is.unit(filter)\n  let needToCombine = true\n  if (source === undefined) {\n    assertNodeSet(clock, 'guard', 'clock')\n    if (Array.isArray(clock)) {\n      clock = merge(clock)\n    }\n    source = clock\n    needToCombine = false\n  }\n  if (needToCombine && !is.unit(source)) source = combine(source)\n  if (clock) {\n    assertNodeSet(clock, 'guard', 'clock')\n    source = sample({\n      source,\n      clock,\n      greedy,\n      fn: filterIsUnit ? null : (source: any, clock: any) => ({source, clock}),\n    })\n  }\n  assertNodeSet(target, 'guard', 'target')\n  if (filterIsUnit) {\n    sample({\n      source: filter,\n      clock: source,\n      target: createNode({\n        node: [\n          step.filter({\n            fn: ({guard}) => guard,\n          }),\n          step.compute({\n            fn: ({data}) => data,\n          }),\n        ],\n        child: target,\n        meta,\n        family: {\n          owners: [source, filter, target, ...[].concat(clock ? clock : [])],\n          links: target,\n        },\n        regional: true,\n      }),\n      fn: (guard: any, data: any) => ({guard, data}),\n      greedy,\n      name,\n    })\n  } else {\n    if (!isFunction(filter)) throwError('`filter` should be function or unit')\n    createLinkNode(source, target, {\n      scope: {fn: filter},\n      node: clock\n        ? [\n            step.filter({\n              fn: ({source, clock}, {fn}) => fn(source, clock),\n            }),\n            step.compute({\n              fn: ({source}) => source,\n            }),\n          ]\n        : [step.filter({fn: callStack})],\n      meta,\n    })\n  }\n  return target\n}\n","import {createStore} from './createUnit'\nimport {is} from './is'\nimport {forIn} from './collection'\nimport {getParent} from './getter'\n\nexport function restore(obj: any, defaultState: any, config?: any): any {\n  if (is.store(obj)) {\n    return obj\n  }\n  if (is.unit(obj)) {\n    const domain = getParent(obj)\n    let result\n    if (is.event(obj)) {\n      result = createStore(defaultState, {\n        parent: domain,\n        name: obj.shortName,\n        ɔ: config,\n      }).on(obj, (_, v) => v)\n    }\n    if (is.effect(obj)) {\n      result = createStore(defaultState, {\n        parent: domain,\n        name: obj.shortName,\n        ɔ: config,\n      }).on(obj.done, (_: any, {result}: any) => result)\n    }\n    if (domain) domain.hooks.store(result)\n    return result\n  }\n  const result: Record<string, any> = Array.isArray(obj) ? [] : {}\n  forIn(obj, (value, key) => {\n    result[key] = is.store(value) ? value : createStore(value, {name: key})\n  })\n  return result\n}\n"]},"metadata":{},"sourceType":"script"}