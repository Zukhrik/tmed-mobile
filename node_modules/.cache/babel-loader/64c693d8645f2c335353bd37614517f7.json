{"ast":null,"code":"function e(e) {\n  i.store(e) || h('expect useStore argument to be a store');\n  let t = e.getState(),\n      n = f.useReducer(e => e + 1, 0)[1],\n      r = f.useRef({\n    store: e,\n    value: t,\n    pending: 0\n  });\n  return k(() => {\n    let t = e.updates.watch(e => {\n      let t = r.current;\n      t.pending || (t.value = e, t.pending = 1, n(), t.pending = 0);\n    }),\n        o = e.getState(),\n        u = r.current;\n    return u.store === e && u.value !== o && (u.value = o, u.pending = 1, n(), u.pending = 0), u.store = e, t;\n  }, [e]), t;\n}\n\nfunction t(t, n) {\n  let r, o, u, s;\n  n ? (r = n, u = t, s = []) : (r = t.fn, u = t.store, s = t.keys, o = t.updateFilter), i.store(u) || h('useStoreMap expects a store'), Array.isArray(s) || h('useStoreMap expects an array as keys'), 'function' != typeof r && h('useStoreMap expects a function');\n  let a = f.useMemo(() => p(r(u.getState(), s), {\n    updateFilter: o\n  }).on(u, (e, t) => r(t, s)), s),\n      l = e(a);\n  return k(() => () => {\n    a.off(u), m(a, {\n      deep: 1\n    });\n  }, s), l;\n}\n\nfunction n(e, t) {\n  return t.displayName = e, t;\n}\n\nfunction r(t, r) {\n  function o(t) {\n    let n = f.useRef(t),\n        o = e(u);\n    k(() => (a({\n      props: n.current,\n      state: u.getState()\n    }), () => {\n      l({\n        props: n.current,\n        state: u.getState()\n      });\n    }), []);\n    let s = r(t, o);\n    return n.current = t, s;\n  }\n\n  let u;\n  i.store(t) ? u = t : 'object' == typeof t && null !== t ? u = y(t) : h('shape should be a store or object with stores');\n  let s = 'Unknown';\n  u && u.shortName && (s = u.shortName);\n  let a = d(),\n      l = d();\n  return o.mounted = a, o.unmounted = l, n(`${s}.View`, o);\n}\n\nfunction o(e) {\n  return r(e, ({\n    children: e\n  }, t) => e(t));\n}\n\nfunction u(r, o) {\n  let u,\n      s,\n      a = [];\n  'object' == typeof o && null !== o ? (o.keys && (a = o.keys), u = o.fn, o.getKey && (s = o.getKey)) : u = o, i.store(r) || h('expect useList first argument to be a store'), 'function' != typeof u && h(\"expect useList's renderItem to be a function\"), Array.isArray(a) || h(\"expect useList's keys to be an array\");\n  let l = f.useMemo(() => {\n    let e = n(`${r.shortName || 'Unknown'}.Item`, e => {\n      let {\n        index: n,\n        keys: o,\n        keyVal: u,\n        value: s\n      } = e;\n      if (c.current[1]) return c.current[0](s, u);\n      let a = t({\n        store: r,\n        keys: [n, ...o],\n        fn: (e, t) => e[t[0]]\n      });\n      return c.current[0](a, n);\n    });\n    return f.memo(e);\n  }, [r, !!s]),\n      c = f.useRef([u, s]);\n  c.current = [u, s];\n  let p = f.useMemo(() => a, a);\n  if (s) return e(r).map(e => {\n    let t = c.current[1](e);\n    return f.createElement(l, {\n      keyVal: t,\n      key: t,\n      keys: p,\n      value: e\n    });\n  });\n  {\n    let e = t({\n      store: r,\n      keys: [r],\n      fn: e => e.length\n    });\n    return Array.from({\n      length: e\n    }, (e, t) => f.createElement(l, {\n      index: t,\n      key: t,\n      keys: p\n    }));\n  }\n}\n\nfunction s(t, r) {\n  return n(`Connect(${r.displayName || r.name || 'Unknown'})`, n => f.createElement(r, Object.assign({}, n, e(t))));\n}\n\nfunction a(e, t = {}) {\n  let n = f.useRef(null);\n  k(() => (e.open(n.current), () => e.close(n.current)), [e]), ((e, t) => {\n    if (e === t) return 1;\n\n    if ('object' == typeof e && null !== e && 'object' == typeof t && null !== t) {\n      let n = Object.keys(e),\n          r = Object.keys(t);\n      if (n.length !== r.length) return 0;\n\n      for (let r = 0; r < n.length; r++) {\n        let o = n[r];\n        if (e[o] !== t[o]) return 0;\n      }\n\n      return 1;\n    }\n\n    return 0;\n  })(n.current, t) || (n.current = t, e.set(t));\n}\n\nfunction l(e = \"gate\", t = {}) {\n  let r;\n  return 'object' == typeof e && null !== e && ('defaultState' in e && (t = e.defaultState), e.domain && (r = e.domain), e = e.name), (({\n    name: e = \"gate\",\n    domain: t,\n    defaultState: r,\n    hook: o\n  }) => {\n    function u(e) {\n      return o(u, e), null;\n    }\n\n    let s = `${t ? `${t.compositeName.fullName}/` : ''}${e}`,\n        a = d(`${s}.set`),\n        l = d(`${s}.open`),\n        c = d(`${s}.close`),\n        f = p(Boolean(0), {\n      name: `${s}.status`\n    }).on(l, () => Boolean(1)).on(c, () => Boolean(0)),\n        i = p(r, {\n      name: `${s}.state`\n    }).on(a, (e, t) => t).reset(c);\n\n    if (t) {\n      let {\n        hooks: e\n      } = t;\n      g({\n        target: [e.store, e.store, e.event, e.event, e.event],\n        params: [f, i, l, c, a]\n      });\n    }\n\n    return u.open = l, u.close = c, u.status = f, u.state = i, u.set = a, n(`Gate:${s}`, u);\n  })({\n    name: e,\n    domain: r,\n    defaultState: t,\n    hook: a\n  });\n}\n\nfunction c(e) {\n  return e;\n}\n\nimport f from 'react';\nimport { is as i, createStore as p, clearNode as m, combine as y, createEvent as d, launch as g } from 'effector/effector.mjs';\n\nlet k = 'undefined' != typeof window ? f.useLayoutEffect : f.useEffect,\n    h = e => {\n  throw Error(e);\n},\n    b = (t, r, o) => n(`${t.shortName || 'Unknown'}.ContextComponent`, n => {\n  let u = f.useContext(r),\n      s = e(t);\n  return o(n, s, u);\n}),\n    S = e => t => {\n  let n = e;\n  return 'function' != typeof e && (n = t, t = e), s(t, n);\n};\n\nexport { S as connect, r as createComponent, b as createContextComponent, l as createGate, s as createReactState, o as createStoreConsumer, c as useEvent, a as useGate, u as useList, e as useStore, t as useStoreMap };","map":null,"metadata":{},"sourceType":"module"}